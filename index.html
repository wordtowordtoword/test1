<!DOCTYPE html>
<html class='v2' dir='ltr' lang='en-GB'>
<head>
<link href='https://www.blogger.com/static/v1/widgets/573632073-css_bundle_v2.css' rel='stylesheet' type='text/css'/>
<meta content='width=1100' name='viewport'/>
<meta content='text/html; charset=UTF-8' http-equiv='Content-Type'/>
<meta content='blogger' name='generator'/>
<link href='https://testtesting10101010.blogspot.com/favicon.ico' rel='icon' type='image/x-icon'/>
<link href='https://testtesting10101010.blogspot.com/' rel='canonical'/>
<link rel="alternate" type="application/atom+xml" title="test - Atom" href="https://testtesting10101010.blogspot.com/feeds/posts/default" />
<link rel="alternate" type="application/rss+xml" title="test - RSS" href="https://testtesting10101010.blogspot.com/feeds/posts/default?alt=rss" />
<link rel="service.post" type="application/atom+xml" title="test - Atom" href="https://www.blogger.com/feeds/7134852494570757091/posts/default" />
<!--Can't find substitution for tag [blog.ieCssRetrofitLinks]-->
<meta content='https://testtesting10101010.blogspot.com/' property='og:url'/>
<meta content='test' property='og:title'/>
<meta content='' property='og:description'/>
<title>test</title>
<style id='page-skin-1' type='text/css'><!--
/*
-----------------------------------------------
Blogger Template Style
Name:     Simple
Designer: Blogger
URL:      www.blogger.com
----------------------------------------------- */
/* Content
----------------------------------------------- */
body {
font: normal normal 14px Georgia, Utopia, 'Palatino Linotype', Palatino, serif;
color: #222222;
background: #513831 url(//themes.googleusercontent.com/image?id=1KH22PlFqsiVYxboQNAoJjYmRbw5M4REHmdJbHT5M2x9zVMGrCqwSjZvaQW_A10KPc6Il) repeat scroll top center /* Credit: luoman (https://www.istockphoto.com/googleimages.php?id=11394138&amp;platform=blogger) */;
padding: 0 40px 40px 40px;
}
html body .region-inner {
min-width: 0;
max-width: 100%;
width: auto;
}
h2 {
font-size: 22px;
}
a:link {
text-decoration:none;
color: #993300;
}
a:visited {
text-decoration:none;
color: #888888;
}
a:hover {
text-decoration:underline;
color: #ff1900;
}
.body-fauxcolumn-outer .fauxcolumn-inner {
background: transparent none repeat scroll top left;
_background-image: none;
}
.body-fauxcolumn-outer .cap-top {
position: absolute;
z-index: 1;
height: 400px;
width: 100%;
}
.body-fauxcolumn-outer .cap-top .cap-left {
width: 100%;
background: transparent none repeat-x scroll top left;
_background-image: none;
}
.content-outer {
-moz-box-shadow: 0 0 40px rgba(0, 0, 0, .15);
-webkit-box-shadow: 0 0 5px rgba(0, 0, 0, .15);
-goog-ms-box-shadow: 0 0 10px #333333;
box-shadow: 0 0 40px rgba(0, 0, 0, .15);
margin-bottom: 1px;
}
.content-inner {
padding: 10px 10px;
}
.content-inner {
background-color: #fff9ee;
}
/* Header
----------------------------------------------- */
.header-outer {
background: #ccb666 url(https://resources.blogblog.com/blogblog/data/1kt/simple/gradients_light.png) repeat-x scroll 0 -400px;
_background-image: none;
}
.Header h1 {
font: normal normal 48px Georgia, Utopia, 'Palatino Linotype', Palatino, serif;
color: #ffffff;
text-shadow: 1px 2px 3px rgba(0, 0, 0, .2);
}
.Header h1 a {
color: #ffffff;
}
.Header .description {
font-size: 140%;
color: #ffffff;
}
.header-inner .Header .titlewrapper {
padding: 22px 30px;
}
.header-inner .Header .descriptionwrapper {
padding: 0 30px;
}
/* Tabs
----------------------------------------------- */
.tabs-inner .section:first-child {
border-top: 0 solid #eee5dd;
}
.tabs-inner .section:first-child ul {
margin-top: -0;
border-top: 0 solid #eee5dd;
border-left: 0 solid #eee5dd;
border-right: 0 solid #eee5dd;
}
.tabs-inner .widget ul {
background: #fff9ee none repeat-x scroll 0 -800px;
_background-image: none;
border-bottom: 1px solid #eee5dd;
margin-top: 0;
margin-left: -30px;
margin-right: -30px;
}
.tabs-inner .widget li a {
display: inline-block;
padding: .6em 1em;
font: normal normal 16px Georgia, Utopia, 'Palatino Linotype', Palatino, serif;
color: #998877;
border-left: 1px solid #fff9ee;
border-right: 1px solid #eee5dd;
}
.tabs-inner .widget li:first-child a {
border-left: none;
}
.tabs-inner .widget li.selected a, .tabs-inner .widget li a:hover {
color: #000000;
background-color: #fff9ee;
text-decoration: none;
}
/* Columns
----------------------------------------------- */
.main-outer {
border-top: 0 solid #eee5dd;
}
.fauxcolumn-left-outer .fauxcolumn-inner {
border-right: 1px solid #eee5dd;
}
.fauxcolumn-right-outer .fauxcolumn-inner {
border-left: 1px solid #eee5dd;
}
/* Headings
----------------------------------------------- */
div.widget > h2,
div.widget h2.title {
margin: 0 0 1em 0;
font: normal bold 12px Georgia, Utopia, 'Palatino Linotype', Palatino, serif;
color: #000000;
}
/* Widgets
----------------------------------------------- */
.widget .zippy {
color: #999999;
text-shadow: 2px 2px 1px rgba(0, 0, 0, .1);
}
.widget .popular-posts ul {
list-style: none;
}
/* Posts
----------------------------------------------- */
h2.date-header {
font: normal bold 11px Arial, Tahoma, Helvetica, FreeSans, sans-serif;
}
.date-header span {
background-color: transparent;
color: #222222;
padding: inherit;
letter-spacing: inherit;
margin: inherit;
}
.main-inner {
padding-top: 30px;
padding-bottom: 30px;
}
.main-inner .column-center-inner {
padding: 0 15px;
}
.main-inner .column-center-inner .section {
margin: 0 15px;
}
.post {
margin: 0 0 25px 0;
}
h3.post-title, .comments h4 {
font: normal normal 24px Georgia, Utopia, 'Palatino Linotype', Palatino, serif;
margin: .75em 0 0;
}
.post-body {
font-size: 110%;
line-height: 1.4;
position: relative;
}
.post-body img, .post-body .tr-caption-container, .Profile img, .Image img,
.BlogList .item-thumbnail img {
padding: 2px;
background: #ffffff;
border: 1px solid #eeeeee;
-moz-box-shadow: 1px 1px 5px rgba(0, 0, 0, .1);
-webkit-box-shadow: 1px 1px 5px rgba(0, 0, 0, .1);
box-shadow: 1px 1px 5px rgba(0, 0, 0, .1);
}
.post-body img, .post-body .tr-caption-container {
padding: 5px;
}
.post-body .tr-caption-container {
color: #222222;
}
.post-body .tr-caption-container img {
padding: 0;
background: transparent;
border: none;
-moz-box-shadow: 0 0 0 rgba(0, 0, 0, .1);
-webkit-box-shadow: 0 0 0 rgba(0, 0, 0, .1);
box-shadow: 0 0 0 rgba(0, 0, 0, .1);
}
.post-header {
margin: 0 0 1.5em;
line-height: 1.6;
font-size: 90%;
}
.post-footer {
margin: 20px -2px 0;
padding: 5px 10px;
color: #666555;
background-color: #eee9dd;
border-bottom: 1px solid #eeeeee;
line-height: 1.6;
font-size: 90%;
}
#comments .comment-author {
padding-top: 1.5em;
border-top: 1px solid #eee5dd;
background-position: 0 1.5em;
}
#comments .comment-author:first-child {
padding-top: 0;
border-top: none;
}
.avatar-image-container {
margin: .2em 0 0;
}
#comments .avatar-image-container img {
border: 1px solid #eeeeee;
}
/* Comments
----------------------------------------------- */
.comments .comments-content .icon.blog-author {
background-repeat: no-repeat;
background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASCAYAAABWzo5XAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEgAACxIB0t1+/AAAAAd0SU1FB9sLFwMeCjjhcOMAAAD+SURBVDjLtZSvTgNBEIe/WRRnm3U8RC1neQdsm1zSBIU9VVF1FkUguQQsD9ITmD7ECZIJSE4OZo9stoVjC/zc7ky+zH9hXwVwDpTAWWLrgS3QAe8AZgaAJI5zYAmc8r0G4AHYHQKVwII8PZrZFsBFkeRCABYiMh9BRUhnSkPTNCtVXYXURi1FpBDgArj8QU1eVXUzfnjv7yP7kwu1mYrkWlU33vs1QNu2qU8pwN0UpKoqokjWwCztrMuBhEhmh8bD5UDqur75asbcX0BGUB9/HAMB+r32hznJgXy2v0sGLBcyAJ1EK3LFcbo1s91JeLwAbwGYu7TP/3ZGfnXYPgAVNngtqatUNgAAAABJRU5ErkJggg==);
}
.comments .comments-content .loadmore a {
border-top: 1px solid #999999;
border-bottom: 1px solid #999999;
}
.comments .comment-thread.inline-thread {
background-color: #eee9dd;
}
.comments .continue {
border-top: 2px solid #999999;
}
/* Accents
---------------------------------------------- */
.section-columns td.columns-cell {
border-left: 1px solid #eee5dd;
}
.blog-pager {
background: transparent none no-repeat scroll top center;
}
.blog-pager-older-link, .home-link,
.blog-pager-newer-link {
background-color: #fff9ee;
padding: 5px;
}
.footer-outer {
border-top: 0 dashed #bbbbbb;
}
/* Mobile
----------------------------------------------- */
body.mobile  {
background-size: auto;
}
.mobile .body-fauxcolumn-outer {
background: transparent none repeat scroll top left;
}
.mobile .body-fauxcolumn-outer .cap-top {
background-size: 100% auto;
}
.mobile .content-outer {
-webkit-box-shadow: 0 0 3px rgba(0, 0, 0, .15);
box-shadow: 0 0 3px rgba(0, 0, 0, .15);
}
.mobile .tabs-inner .widget ul {
margin-left: 0;
margin-right: 0;
}
.mobile .post {
margin: 0;
}
.mobile .main-inner .column-center-inner .section {
margin: 0;
}
.mobile .date-header span {
padding: 0.1em 10px;
margin: 0 -10px;
}
.mobile h3.post-title {
margin: 0;
}
.mobile .blog-pager {
background: transparent none no-repeat scroll top center;
}
.mobile .footer-outer {
border-top: none;
}
.mobile .main-inner, .mobile .footer-inner {
background-color: #fff9ee;
}
.mobile-index-contents {
color: #222222;
}
.mobile-link-button {
background-color: #993300;
}
.mobile-link-button a:link, .mobile-link-button a:visited {
color: #ffffff;
}
.mobile .tabs-inner .section:first-child {
border-top: none;
}
.mobile .tabs-inner .PageList .widget-content {
background-color: #fff9ee;
color: #000000;
border-top: 1px solid #eee5dd;
border-bottom: 1px solid #eee5dd;
}
.mobile .tabs-inner .PageList .widget-content .pagelist-arrow {
border-left: 1px solid #eee5dd;
}

--></style>
<style id='template-skin-1' type='text/css'><!--
body {
min-width: 960px;
}
.content-outer, .content-fauxcolumn-outer, .region-inner {
min-width: 960px;
max-width: 960px;
_width: 960px;
}
.main-inner .columns {
padding-left: 0;
padding-right: 310px;
}
.main-inner .fauxcolumn-center-outer {
left: 0;
right: 310px;
/* IE6 does not respect left and right together */
_width: expression(this.parentNode.offsetWidth -
parseInt("0") -
parseInt("310px") + 'px');
}
.main-inner .fauxcolumn-left-outer {
width: 0;
}
.main-inner .fauxcolumn-right-outer {
width: 310px;
}
.main-inner .column-left-outer {
width: 0;
right: 100%;
margin-left: -0;
}
.main-inner .column-right-outer {
width: 310px;
margin-right: -310px;
}
#layout {
min-width: 0;
}
#layout .content-outer {
min-width: 0;
width: 800px;
}
#layout .region-inner {
min-width: 0;
width: auto;
}
body#layout div.add_widget {
padding: 8px;
}
body#layout div.add_widget a {
margin-left: 32px;
}
--></style>
<style>
    body {background-image:url(\/\/themes.googleusercontent.com\/image?id=1KH22PlFqsiVYxboQNAoJjYmRbw5M4REHmdJbHT5M2x9zVMGrCqwSjZvaQW_A10KPc6Il);}
    
@media (max-width: 200px) { body {background-image:url(\/\/themes.googleusercontent.com\/image?id=1KH22PlFqsiVYxboQNAoJjYmRbw5M4REHmdJbHT5M2x9zVMGrCqwSjZvaQW_A10KPc6Il&options=w200);}}
@media (max-width: 400px) and (min-width: 201px) { body {background-image:url(\/\/themes.googleusercontent.com\/image?id=1KH22PlFqsiVYxboQNAoJjYmRbw5M4REHmdJbHT5M2x9zVMGrCqwSjZvaQW_A10KPc6Il&options=w400);}}
@media (max-width: 800px) and (min-width: 401px) { body {background-image:url(\/\/themes.googleusercontent.com\/image?id=1KH22PlFqsiVYxboQNAoJjYmRbw5M4REHmdJbHT5M2x9zVMGrCqwSjZvaQW_A10KPc6Il&options=w800);}}
@media (max-width: 1200px) and (min-width: 801px) { body {background-image:url(\/\/themes.googleusercontent.com\/image?id=1KH22PlFqsiVYxboQNAoJjYmRbw5M4REHmdJbHT5M2x9zVMGrCqwSjZvaQW_A10KPc6Il&options=w1200);}}
/* Last tag covers anything over one higher than the previous max-size cap. */
@media (min-width: 1201px) { body {background-image:url(\/\/themes.googleusercontent.com\/image?id=1KH22PlFqsiVYxboQNAoJjYmRbw5M4REHmdJbHT5M2x9zVMGrCqwSjZvaQW_A10KPc6Il&options=w1600);}}
  </style>
<link href='https://www.blogger.com/dyn-css/authorization.css?targetBlogID=7134852494570757091&amp;zx=d7dc0e22-c739-41c5-9225-8b4d5599ecd8' media='none' onload='if(media!=&#39;all&#39;)media=&#39;all&#39;' rel='stylesheet'/><noscript><link href='https://www.blogger.com/dyn-css/authorization.css?targetBlogID=7134852494570757091&amp;zx=d7dc0e22-c739-41c5-9225-8b4d5599ecd8' rel='stylesheet'/></noscript>
<meta name='google-adsense-platform-account' content='ca-host-pub-1556223355139109'/>
<meta name='google-adsense-platform-domain' content='blogspot.com'/>

</head>
<body class='loading variant-literate'>
<div class='navbar section' id='navbar' name='Navbar'><div class='widget Navbar' data-version='1' id='Navbar1'><script type="text/javascript">
    function setAttributeOnload(object, attribute, val) {
      if(window.addEventListener) {
        window.addEventListener('load',
          function(){ object[attribute] = val; }, false);
      } else {
        window.attachEvent('onload', function(){ object[attribute] = val; });
      }
    }
  </script>
<div id="navbar-iframe-container"></div>
<script type="text/javascript" src="https://apis.google.com/js/platform.js"></script>
<script type="text/javascript">
      gapi.load("gapi.iframes:gapi.iframes.style.bubble", function() {
        if (gapi.iframes && gapi.iframes.getContext) {
          gapi.iframes.getContext().openChild({
              url: 'https://www.blogger.com/navbar/7134852494570757091?origin\x3dhttps://testtesting10101010.blogspot.com',
              where: document.getElementById("navbar-iframe-container"),
              id: "navbar-iframe"
          });
        }
      });
    </script><script type="text/javascript">
(function() {
var script = document.createElement('script');
script.type = 'text/javascript';
script.src = '//pagead2.googlesyndication.com/pagead/js/google_top_exp.js';
var head = document.getElementsByTagName('head')[0];
if (head) {
head.appendChild(script);
}})();
</script>
</div></div>
<div itemscope='itemscope' itemtype='http://schema.org/Blog' style='display: none;'>
<meta content='test' itemprop='name'/>
</div>
<div class='body-fauxcolumns'>
<div class='fauxcolumn-outer body-fauxcolumn-outer'>
<div class='cap-top'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
<div class='fauxborder-left'>
<div class='fauxborder-right'></div>
<div class='fauxcolumn-inner'>
</div>
</div>
<div class='cap-bottom'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
</div>
</div>
<div class='content'>
<div class='content-fauxcolumns'>
<div class='fauxcolumn-outer content-fauxcolumn-outer'>
<div class='cap-top'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
<div class='fauxborder-left'>
<div class='fauxborder-right'></div>
<div class='fauxcolumn-inner'>
</div>
</div>
<div class='cap-bottom'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
</div>
</div>
<div class='content-outer'>
<div class='content-cap-top cap-top'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
<div class='fauxborder-left content-fauxborder-left'>
<div class='fauxborder-right content-fauxborder-right'></div>
<div class='content-inner'>
<header>
<div class='header-outer'>
<div class='header-cap-top cap-top'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
<div class='fauxborder-left header-fauxborder-left'>
<div class='fauxborder-right header-fauxborder-right'></div>
<div class='region-inner header-inner'>
<div class='header section' id='header' name='Header'><div class='widget Header' data-version='1' id='Header1'>
<div id='header-inner'>
<div class='titlewrapper'>
<h1 class='title'>
test
</h1>
</div>
<div class='descriptionwrapper'>
<p class='description'><span>
</span></p>
</div>
</div>
</div></div>
</div>
</div>
<div class='header-cap-bottom cap-bottom'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
</div>
</header>
<div class='tabs-outer'>
<div class='tabs-cap-top cap-top'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
<div class='fauxborder-left tabs-fauxborder-left'>
<div class='fauxborder-right tabs-fauxborder-right'></div>
<div class='region-inner tabs-inner'>
<div class='tabs section' id='crosscol' name='Cross-column'><div class='widget HTML' data-version='1' id='HTML1'>
<div class='widget-content'>
<!doctype html>








   
    <style>


        /* Add your CSS styles here */


/* Modal container styling */
.modal-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start; /* Align items to the top */
    max-width: 800px; /* Limit width for readability */
    padding: 20px;
    border: 1px solid #ccc;
    border-radius: 10px;
    background-color: #f9f9f9;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); /* Subtle shadow */
    margin: 0 auto;
    gap: 20px; /* Add space between elements */
}

/* Styling for the paragraph */
.modal-container p {
    font-size: 18px;
    color: #333;
    margin-bottom: 10px; /* Space below the paragraph */
}

/* Styling for the select dropdown */
#editCategorySelect {
    font-size: 16px;
    padding: 12px 20px;
    margin-bottom: 20px; /* Space below the select */
    border-radius: 8px;
    border: 2px solid #ccc;
    background-color: #f9f9f9;
    width: 100%; /* Make the dropdown fill the container width */
    max-width: 300px; /* Limit the width of the dropdown */
    cursor: pointer;
}

/* Button styling */
button {
    font-size: 16px;
    padding: 12px 20px;
    border-radius: 8px;
    border: 2px solid #ccc;
    background-color: #f0f0f0;
    color: #333;
    cursor: pointer;
    margin: 10px 0; /* Space between buttons */
    transition: background-color 0.3s ease, transform 0.3s ease;
}

button:hover {
    background-color: #e0e0e0;
    transform: scale(1.05); /* Slightly enlarge on hover */
}

/* Specific styles for the Save and Add New Category buttons */
#saveEditedCategoryBtn {
    background-color: #4CAF50; /* Green for Save button */
    color: white;
}

#addNewCategoryBtn {
    background-color: #008CBA; /* Blue for Add New button */
    color: white;
}

#saveEditedCategoryBtn:hover {
    background-color: #45a049; /* Darker green on hover */
}

#addNewCategoryBtn:hover {
    background-color: #007bb5; /* Darker blue on hover */
}











#showModal {
    font-size: 16px; /* Adjust font size */
    padding: 12px 20px; /* Adjust button size with padding */
    border-radius: 8px; /* Rounded corners */
    border: 2px solid #ccc; /* Border style */
    background-color: #f0f0f0; /* Light background */
    color: #333; /* Text color */
    cursor: pointer; /* Pointer on hover */
    margin: 10px 0; /* Spacing around the button */
    transition: background-color 0.3s ease, transform 0.3s ease; /* Smooth transition */
}

#showModal:hover {
    background-color: #e0e0e0; /* Change background on hover */
    transform: scale(1.05); /* Slightly enlarge on hover */
}



#setReminder {
    font-size: 16px; /* Adjust font size */
    padding: 12px 20px; /* Adjust button size with padding */
    border-radius: 8px; /* Rounded corners */
    border: 2px solid #ccc; /* Border style */
    background-color: #f0f0f0; /* Light background */
    color: #333; /* Text color */
    cursor: pointer; /* Pointer on hover */
    margin: 10px 0; /* Spacing around the button */
    transition: background-color 0.3s ease, transform 0.3s ease; /* Smooth transition */
}

#setReminder:hover {
    background-color: #e0e0e0; /* Change background on hover */
    transform: scale(1.05); /* Slightly enlarge on hover */
}



#shareCompletedTasks, #clearCompleted {
    font-size: 16px; /* Adjust font size */
    padding: 12px 20px; /* Adjust button size with padding */
    border-radius: 8px; /* Rounded corners */
    border: 2px solid #ccc; /* Border style */
    background-color: #f0f0f0; /* Light background */
    color: #333; /* Text color */
    cursor: pointer; /* Pointer on hover */
    margin: 10px 0; /* Spacing between buttons */
    transition: background-color 0.3s ease, transform 0.3s ease; /* Smooth transition */
}

#shareCompletedTasks:hover, #clearCompleted:hover {
    background-color: #e0e0e0; /* Change background on hover */
    transform: scale(1.05); /* Slightly enlarge on hover */
}


#viewAllTasks, #viewUrgentTasks {
    font-size: 16px; /* Adjust font size */
    padding: 12px 20px; /* Adjust button size with padding */
    border-radius: 8px; /* Rounded corners */
    border: 2px solid #ccc; /* Border style */
    background-color: #f0f0f0; /* Light background */
    color: #333; /* Text color */
    cursor: pointer; /* Pointer on hover */
    margin: 10px 0; /* Spacing between buttons */
    transition: background-color 0.3s ease, transform 0.3s ease; /* Smooth transition */
}

#viewAllTasks:hover, #viewUrgentTasks:hover {
    background-color: #e0e0e0; /* Change background on hover */
    transform: scale(1.05); /* Slightly enlarge on hover */
}


  #clock {
    font-size: 24px;
    font-family: Arial, sans-serif;
    padding: 10px;
    border: 1px solid #ccc;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    background-color: #f9f9f9;
    width: 3in;
    position: absolute;
    top: 10;
    left: 0;
    right: 0;
    bottom: 10;
    display: flex;
    justify-content: center;
    align-items: center;
    margin: auto; /* Ensures it's centered within the parent container */
    cursor: grab;
}



#shareSelectedTasks {
    padding: 12px 24px;
    font-size: 18px;
    position: absolute; /* Enable manual positioning */
    left: 1000px;       /* Adjust this value to move left or right */
    top: 570px;         /* Adjust this value to move up or down */
}


#pasteTasks {
    padding: 12px 24px;
    font-size: 18px;
    position: absolute;    /* Enable manual positioning */
    left: 50px;           /* Adjust this value to move left or right */

}









  /* Style for the message board container */
  .message-board {
    display: flex;
    align-items: center;
    justify-content: flex-start;
    width: 70%;
    height: 40px;
    background-color: #FFF;
    color: #000;
    font-size: 18px;
    white-space: nowrap;
    overflow: hidden;
    border: 2px solid #ccc;
    border-radius: 5px;
    cursor: pointer;
    padding: 5px;
    position: relative;
  }

  /* Marquee effect */
  .message-board span {
    display: inline-block;
    padding-left: 100%;
    white-space: nowrap;
    animation: marquee linear infinite;
  }

  @keyframes marquee {
    0% { transform: translateX(0); }
    100% { transform: translateX(-100%); }
  }







#setReminder.move-down {
    top: 40px; /* Move down */
}

/* Hover effect */
#setReminder:hover {
    background-color: #0056b3;
    box-shadow: 0 0 10px rgba(0, 123, 255, 0.5);
}




/* Style the completion checkbox */
input[type="checkbox"] {
    width: 18px; /* Set the width */
    height: 18px; /* Set the height */
    cursor: pointer; /* Show pointer cursor on hover */
    appearance: none; /* Remove default checkbox style */
    background-color: #fff; /* Background color */
    border: 2px solid #ccc; /* Border style */
    border-radius: 5px; /* Optional: Rounded corners */
    transition: all 0.3s ease; /* Smooth hover effect */
}

/* Style the checkbox when checked */
input[type="checkbox"]:checked {
    background-color: #0071c5; /* Green background when checked */
    border-color: #4CAF50;
    box-shadow: 0 0 10px rgba(76, 175, 80, 0.6); /* Glow effect */
}

/* Hover effect */
input[type="checkbox"]:hover {
    border-color: #007bff; /* Border color on hover */
    box-shadow: 0 0 5px rgba(0, 123, 255, 0.5); /* Subtle glow */
}






/* Style the select element */
.priority-select {
    width: 70%; /* Make it take full width of the column */
    padding: 3px;
    font-size: 24px;
    border: 1px solid #ccc;
    border-radius: 30%; /* Makes the dropdown circular */
    background-color: #fff;
    transition: background-color 0.3s ease, border 0.3s ease;
    cursor: pointer;
}




/* Style the highlight selector to be circular */
.highlight-select {
    width: 60px;                      /* Set width */
    height: 60px;                     /* Set height */
    border: 2px solid #ccc;           /* Add border to make it visible */
    border-radius: 50%;               /* Make it circular */
    cursor: pointer;
    text-align: center;
    padding: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    font-size: 24px;                  /* Make the emojis bigger */
}

/* Style the dropdown options */
.highlight-select option {
    font-size: 24px;                  /* Larger font size for emojis */
    padding: 10px;
    text-align: center;               /* Center the emoji */
    height: auto;                     /* Let height adjust based on content */
    width: 100%;
    background-color: #fff;
    color: #333;
    border-radius: 5px;
    box-sizing: border-box;
    display: flex;
    justify-content: center;
    align-items: center;
}

/* Prevent hover effect on dropdown options */
.highlight-select option:hover {
    background-color: transparent !important;
    color: inherit !important;
}




/* Styling for the completed task list container */
#completedList {
    list-style-type: none;
    padding: 20px;
    margin: 0;
    background-color: #f2f2f2;
    border-radius: 10px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    max-width: 800px;
    margin: auto;
}

/* Task items styling */
#completedList .task {
    background-color: #ffffff;
    margin: 10px 0;
    padding: 15px;
    border-radius: 8px;
    font-family: 'Arial', sans-serif;
    font-size: 16px;
    line-height: 1.6;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
    transition: transform 0.3s ease, box-shadow 0.3s ease;
}

/* Hover effect for task items */
#completedList .task:hover {
    transform: translateY(-5px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}

/* Styling for urgent tasks */
#completedList .task.urgent {
    background-color: #ff6347;
    color: white;
    font-weight: bold;
}

/* Deadline and extra information styling */
#completedList .task span {
    font-size: 14px;
    color: #888;
    display: block;
    margin-top: 8px;
}

/* Horizontal line styling after each task */
#completedList hr {
    border: 0;
    border-top: 1px solid #ddd;
    margin: 10px 0;
}

/* Smooth animation for the list when items are added */
@keyframes fadeIn {
    from {
        opacity: 0;
    }
    to {
        opacity: 1;
    }
}

/* Apply the fadeIn effect */
#completedList .task {
    animation: fadeIn 0.5s ease-in-out;
}










/* Display Task */
.list-item {
    display: block;
    width: 100%;
    transition: all 0.3s ease-in-out; /* Smooth transition for hover effect */
}

/* The first row that contains only infoColumn */
.info-row {
    display: block; /* This ensures the infoColumn takes full width */
    margin-top: 40px; /* Adjust spacing between tasks here */
    width: 100%; /* Ensures it takes the full width of the list-item */
    padding: 10px;
    background-color: #f9f9f9; /* Subtle background color */
    border-bottom: 1px solid #ccc;
        border-radius: 8px; /* Rounded corners for a soft look */
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); /* Soft shadow */
    transition: all 0.3s ease; /* Smooth hover effect */
}

.info-row:hover {
    background-color: #e6e6e6; /* Slight color change on hover */
    transform: translateY(-5px); /* Slightly lift up the row on hover */
    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.15); /* Enhanced shadow on hover */
}

/* The second row for other columns (grid layout) */
.details-row {
    display: grid; /* Grid for the remaining columns */
    grid-template-columns: repeat(10, 1fr); /* Adjust based on the number of columns in the second row */
    gap: 0px;
  font-size: 16px; /* Set your desired font size */
    padding: 10px 0;
    width: 100%;
}

/* Optional: Style individual columns */
.column {
    display: flex;
    justify-content: center; /* Center the content horizontally */
    align-items: center; /* Center content vertically */
    transition: all 0.3s ease-in-out; /* Smooth hover effect */
    padding: 10px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); /* Subtle shadow */
}

.column:hover {
    background-color: #e0f7fa; /* Change background on hover */
    transform: scale(1.05); /* Slightly enlarge on hover */
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15); /* Enhance shadow */
}

/* Add cool hover effect for the entire list item */
.list-item:hover {
    background-color: #f0f0f0; /* Subtle background change */
    transform: translateY(-10px); /* Lift the entire list item */
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1); /* Enhanced shadow effect */
}

/* Add a pulse effect to make items stand out */
.list-item:active {
    animation: pulse 0.5s ease-in-out; /* Cool pulse effect on click */
}

@keyframes pulse {
    0% {
        transform: scale(1);
    }
    50% {
        transform: scale(1.05);
    }
    100% {
        transform: scale(1);
    }
}

/* Add a smooth fading effect when the item is added or removed */
.list-item {
    opacity: 0;
    animation: fadeIn 0.5s forwards; /* Fade-in effect */
}

@keyframes fadeIn {
    0% {
        opacity: 0;
    }
    100% {
        opacity: 1;
    }
}

/* Add a glowing effect for interactive items */
.column:active {
    box-shadow: 0 0 10px 5px rgba(0, 255, 255, 0.5); /* Glowing effect on click */
}



/* Style for the notebook icon */
.notebook-icon {
    cursor: pointer;
    font-size: 24px;
    margin-left: 10px;
    color: blue;
}

/* Style for the note popup */
.note-popup {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 40%;
    max-width: 90%; /* Ensures it fits on smaller screens */
    background: white;
    border: 1px solid #ccc;
    padding: 20px;
    z-index: 1000;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
}

/* Style for the close button (X) */
.close-button {
    position: absolute;
    top: 10px;
    right: 10px;
    font-size: 24px;
    cursor: pointer;
    color: red;
}

/* Style for the textarea inside the popup */
.note-popup textarea {
    width: 100%;
    height: 150px;
    margin-top: 20px;
}

/* Optional: Add some styling for the notes column */
.notes-column {
    display: flex;
    align-items: center;
}




#displayTasks {
        width: 120px; /* Adjust width */
        height: 120px; /* Adjust height */
        border-radius: 50%; /* Makes the button circular */
        background-color: #F0F0F0; /* Background color (adjust as needed) */
        color: black; /* Text color */
        border: none; /* Remove default border */
        font-size: 92px; /* Font size */
        font-weight: bold; /* Font weight */
        text-align: center; /* Center text horizontally */
        line-height: 60px; /* Center text vertically */
        cursor: pointer; /* Change cursor to pointer on hover */
        position: absolute; /* Allows positioning */
        z-index: 1000; /* Ensure it's above other elements */
        transition: background-color 0.3s, transform 0.3s; /* Smooth transition for hover effect */
    }


    /* Hover effect */
    #displayTasks:hover {
        background-color: #FFFFFF; /* Darker background color on hover */
        transform: scale(1.1); /* Slightly increase size on hover */
    }

    /* Position the button */
    /* You can change top, right, bottom, and left values to reposition the button */
    #displayTasks {
        top: 100px; /* Distance from the top of the viewport */
        right: -20px; /* Distance from the right of the viewport */
    }
   
    /* General modal styles */
    .modal {
        display: none; /* Hidden by default */
        position: fixed; /* Stay in place */
        z-index: 1; /* Sit on top */
        left: 0;
        top: 0;
        width: 40vw; /* Full viewport width */
        height: 10vh; /* Full viewport height */
        overflow: hidden; /* Prevent scrolling in the modal */
        background-color: rgba(0,0,0,0.4); /* Black background with opacity */
    }

    .modal-content {
        background-color: #fefefe;
        margin: 0 auto; /* Center horizontally */
        padding: 0;
        border: 1px solid #888;
        width: 90vw; /* 90% of viewport width */
        height: 68vh; /* 90% of viewport height */
        overflow: hidden; /* Hide overflow to avoid scrollbars on modal */
        display: flex; /* Flexbox for center alignment */
        align-items: center; /* Center content vertically */
        justify-content: center; /* Center content horizontally */
    }

    #tasksIframe {
        width: 150%;
        height: 100%;
        border: none;
        overflow: auto; /* Allow iframe content to be scrollable */
    }

    .close {
        color: white; /* White color for better contrast */
        font-size: 36px; /* Larger font size */
        font-weight: bold;
        cursor: pointer;
        padding: 10px;
        background-color: #F0F0F0; /* Dark background for visibility */
        border-radius: 50%; /* Circular button */
        position: absolute; /* Position it in the top-right corner */
        top: 10px;
        right: 10px;
        transition: background-color 0.3s, color 0.3s; /* Smooth transition effect */
    }

    .close:hover,
    .close:focus {
        color: #F0F0F0; /* Change color on hover for visibility */
        background-color: rgba(255,255,255,0.5); /* Lighter background on hover */
        text-decoration: none;
    }






/* Save Edited Category Button Hover Effect */
button#saveEditedCategory:hover {
    background-color: #000000; /* Darker blue on hover */
}

/* Save Edited Category Button Focus Effect */
button#saveEditedCategory:focus {
    outline: none; /* Remove default outline */
    box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.5); /* Outline effect for accessibility */
}

/* Save New Category Button Styles */
button#saveNewCategory {
    background-color: #000000; /* Green background color */
    color: white; /* White text color */
    border: none; /* Remove default border */
    border-radius: 4px; /* Rounded corners */
    padding: 10px 20px; /* Padding inside the button */
    font-size: 16px; /* Font size */
    cursor: pointer; /* Pointer cursor on hover */
    box-shadow: 0 2px 4px rgba(0,0,0,0.2); /* Subtle shadow */
    transition: background-color 0.3s, box-shadow 0.3s; /* Smooth transition */
}

/* Save New Category Button Hover Effect */
button#saveNewCategory:hover {
    background-color: #000000; /* Darker green on hover */
}

/* Save New Category Button Focus Effect */
button#saveNewCategory:focus {
    outline: none; /* Remove default outline */
    box-shadow: 0 0 0 3px rgba(40, 167, 69, 0.5); /* Outline effect for accessibility */
}


/* Confirm Paste Button Styles */
button#confirmPaste {
    background-color: #000000; /* Green background color */
    color: white; /* White text color */
    border: none; /* Remove default border */
    border-radius: 4px; /* Rounded corners */
    padding: 10px 20px; /* Padding inside the button */
    font-size: 16px; /* Font size */
    cursor: pointer; /* Pointer cursor on hover */
    box-shadow: 0 2px 4px rgba(0,0,0,0.2); /* Subtle shadow */
    transition: background-color 0.3s, box-shadow 0.3s; /* Smooth transition */
}

/* Confirm Paste Button Hover Effect */
button#confirmPaste:hover {
    background-color: #000000; /* Darker green on hover */
}

/* Confirm Paste Button Focus Effect */
button#confirmPaste:focus {
    outline: none; /* Remove default outline */
    box-shadow: 0 0 0 3px rgba(40, 167, 69, 0.5); /* Outline effect for accessibility */
}



/* Modal Window Styles */
.modal {
    display: none; /* Hidden by default */
    position: fixed; /* Stay in place */
    z-index: 1; /* Sit on top */
    left: 0;
    top: 0;
    width: 100%; /* Full width */
    height: 100%; /* Full height */
    overflow: auto; /* Enable scroll if needed */
    background-color: rgba(0,0,0,0.4); /* Black background with opacity */
}

/* Modal Content Styles */
.modal-content {
    background-color: #fefefe; /* White background */
    margin: 10% auto; /* 10% from the top and center horizontally */
    padding: 20px;
    border: 1px solid #888; /* Border color */
    width: 80%; /* Width of the modal */
    max-width: 600px; /* Maximum width */
    border-radius: 8px; /* Rounded corners */
    box-shadow: 0 4px 8px rgba(0,0,0,0.2); /* Shadow for depth */
}

/* Modal Title */
.modal-content h2 {
    margin-top: 0; /* Remove top margin */
    font-size: 24px; /* Title font size */
    color: #333; /* Dark gray color for text */
}

/* Textarea Styles */
textarea#pastedTasks {
    width: 100%; /* Full width */
    height: 150px; /* Height of the textarea */
    padding: 10px; /* Padding inside textarea */
    font-size: 16px; /* Font size */
    border: 1px solid #ccc; /* Border color */
    border-radius: 4px; /* Rounded corners */
    box-sizing: border-box; /* Include padding and border in width/height */
    resize: vertical; /* Allow vertical resizing only */
    margin-bottom: 20px; /* Space below textarea */
}

/* Button Styles inside Modal */
.modal-content button {
    width: 100%; /* Full width */
    max-width: 150px; /* Maximum width of the button */
    height: 45px; /* Height of the button */
    padding: 0 15px; /* Padding inside the button */
    font-size: 16px; /* Font size */
    border: 1px; /* Remove default border */
    border-radius: 4px; /* Rounded corners */
    background-color: #FFFFFF; /* Background color */
    color: black; /* Text color */
    cursor: pointer; /* Pointer cursor on hover */
    box-shadow: 0 2px 4px rgba(0,0,0,0.1); /* Subtle shadow */
    transition: background-color 0.3s, box-shadow 0.3s; /* Smooth transition */
    margin-top: 10px; /* Space above the button */
    text-align: center; /* Center text inside the button */
}

/* Button Hover Effects */
.modal-content button:hover {
    background-color: #FFFFFF; /* Darker background color on hover */
}

/* Close Button Styles */
.close {
    color: #FFFFFF; /* Light gray color */
    float: right; /* Float right */
    font-size: 28px; /* Font size */
    font-weight: bold; /* Bold text */
}

.close:hover,
.close:focus {
    color: black; /* Change color on hover/focus */
    text-decoration: none; /* Remove underline */
    cursor: pointer; /* Pointer cursor */
}



/* Modal Window Styles */
.modal {
    display: none; /* Hidden by default */
    position: fixed; /* Stay in place */
    z-index: 1; /* Sit on top */
    left: 0;
    top: 0;
    width: 100%; /* Full width */
    height: 100%; /* Full height */
    overflow: auto; /* Enable scroll if needed */
    background-color: rgba(0,0,0,0.4); /* Black background with opacity */
}

/* Modal Content Styles */
.modal-content {
    background-color: #FFFFFF; /* White background */
    margin: 15% auto; /* 15% from the top and center horizontally */
    padding: 20px;
    border: 1px solid #888; /* Border color */
    width: 80%; /* Width of the modal */
    max-width: 500px; /* Maximum width */
    border-radius: 8px; /* Rounded corners */
}

/* Button Styles inside Modal */
.modal-content button {
    width: 100%; /* Full width */
    max-width: 150px; /* Maximum width of the button */
    height: 45px; /* Height of the button */
    padding: 0 15px; /* Padding inside the button */
    font-size: 16px; /* Font size */
    border: 1px solid black; /* Remove default border */
    border-radius: 4px; /* Rounded corners */
    background-color: #FFFFFF; /* Background color */
    color: white; /* Text color */
    cursor: pointer; /* Pointer cursor on hover */
    box-shadow: #000000; /* Subtle shadow */
    transition: background-color 0.3s, box-shadow 0.3s; /* Smooth transition */
    margin: 5px 0; /* Space between buttons */
    text-align: center; /* Center text inside the button */
}

/* Button Background Colors */
#addCategory {
    background-color: #FFFFFF; /* Green for Add */
}

#editCategory {
    background-color: #FFFFFF; /* Yellow for Edit */
}

#deleteCategory {
    background-color: #FFFFFF; /* Red for Delete */
}

/* Button Hover Effects */
.modal-content button:hover {
    background-color: #FFFFFF; /* Darker background color on hover */
}

/* Close Button Styles */
.close {
    color: #aaa; /* Light gray color */
    float: right; /* Float right */
    font-size: 28px; /* Font size */
    font-weight: bold; /* Bold text */
}

.close:hover,
.close:focus {
    color: black; /* Change color on hover/focus */
    text-decoration: none; /* Remove underline */
    cursor: pointer; /* Pointer cursor */
}



/* Style for the main button */
#showModal {
    width: 100%; /* Adjust width to fit the container */
    max-width: 200px; /* Maximum width of the button */
    height: 45px; /* Height of the button */
    padding: 0 20px; /* Padding inside the button */
    font-size: 16px; /* Font size of the text inside the button */
    border: none; /* Remove default border */
    border-radius: 4px; /* Rounded corners */
    background-color: FFFFFF; /* Background color */
    color: black; /* Text color */
    cursor: pointer; /* Pointer cursor on hover */
    box-shadow: 0 2px 4px rgba(0,0,0,0.1); /* Subtle shadow */
    transition: background-color 0.3s, box-shadow 0.3s; /* Smooth transition for background color and shadow */
    margin-bottom: 10px; /* Space below the button */
    text-align: center; /* Center text inside the button */
}

/* Style for the button on hover */
#showModal:hover {
    background-color: FFFFFF; /* Darker background color on hover */
}

/* Style for the button on focus */
#showModal:focus {
    outline: none; /* Remove default outline */
    box-shadow: FFFFFF; /* Add custom focus ring */
}


/* Style for the sort select dropdown */
#sortSelect {
    width: 100%; /* Adjust width to fit the container */
    max-width: 400px; /* Maximum width of the dropdown */
    height: 40px; /* Height of the dropdown */
    padding: 0 10px; /* Padding inside the dropdown */
    font-size: 16px; /* Font size of the text inside the dropdown */
    border: 1px solid #ccc; /* Border color and style */
    border-radius: 4px; /* Rounded corners */
    box-shadow: 0 2px 4px rgba(0,0,0,0.1); /* Subtle shadow */
    transition: border-color 0.3s; /* Smooth transition for border color */
    margin-bottom: 10px; /* Space below the dropdown */
}

/* Style for the sort select dropdown on focus */
#sortSelect:focus {
    border-color: #007bff; /* Border color when focused */
    outline: none; /* Remove default outline */
}

/* Style for the label "Select All" */
label[for="selectAllTasks"] {
    display: inline-block;
    padding: 10px 10px;
    background-color: FFFFFF; /* Background color for the button appearance */
    color: black; /* Text color */
    font-size: 16px;
    border-radius: 2px;
    border: none; /* Remove default border */
    cursor: pointer; /* Change cursor to pointer to indicate clickable item */
    text-align: center; /* Center text inside the button */
    margin: 2px; /* Space around the button */
    user-select: none; /* Prevent text selection */
    transition: background-color 0.3s; /* Smooth transition for background color on hover */
}

/* Style for the label on hover */
label[for="selectAllTasks"]:hover {
    background-color: FFFFFF; /* Darker background color on hover */
}


/* Style for the "Add Task" button */
#addTask {
    width: 250px; /* Set width to a fixed size */
    height: 120px; /* Set height to the same size as width for a circular shape */
    padding: 0; /* Remove padding to keep the circle shape */
    margin: 10px 0; /* Space above and below the button */
    border-radius: 50%; /* Make the button circular */
    border: none; /* Black border */
    background-color: FFFFFF; /* Background color */
    color: black; /* Text color */
    font-size: 78px; /* Font size */
    cursor: pointer; /* Pointer cursor on hover */
    text-align: center; /* Center the text */
    line-height: 60px; /* Center text vertically */
    display: flex; /* Flexbox for centering text horizontally */
    align-items: center; /* Center text vertically with Flexbox */
    justify-content: center; /* Center text horizontally with Flexbox */
    font-weight: none; /* Optional: Make the text bold */
}

/* Change background color on hover for the "Add Task" button */
#addTask:hover {
    background-color: FFFFFF; /* Darker green on hover */
}

/* Style for the task entry container */
.task-entry {
    display: flex; /* Use flexbox for horizontal alignment */
    align-items: center; /* Center align items vertically */
    gap: 15px; /* Space between each element */
    margin: 10px 0; /* Space around the container */
}





/* Style for the new task input field */
#newTask {
    width: 100%; /* Adjust width to fit the container */
    max-width: 630px; /* Maximum width of the input field */
    height: 40px; /* Height of the input field */
    padding: 0 10px; /* Padding inside the input field */
    font-size: 16px; /* Font size of the text inside the input field */
    border: 1px solid #ccc; /* Border color and style */
    border-radius: 4px; /* Rounded corners */
    box-shadow: 0 2px 4px rgba(0,0,0,0.1); /* Subtle shadow */
    transition: border-color 0.3s; /* Smooth transition for border color */
    margin-bottom: -3px; /* Space below the input field */
}

/* Style for the new task input field on focus */
#newTask:focus {
    border-color: #007bff; /* Border color when focused */
    outline: none; /* Remove default outline */
}

/* Style for the category select dropdown */
#categorySelect {
    width: 100%; /* Adjust width to fit the container */
    max-width: 160px; /* Maximum width of the dropdown */
    height: 40px; /* Height of the dropdown */
    padding: 0 10px; /* Padding inside the dropdown */
    font-size: 16px; /* Font size of the text inside the dropdown */
    border: 1px solid #ccc; /* Border color and style */
    border-radius: 4px; /* Rounded corners */
    box-shadow: 0 2px 4px rgba(0,0,0,0.1); /* Subtle shadow */
    transition: border-color 0.3s; /* Smooth transition for border color */
}

/* Style for the category select dropdown on focus */
#categorySelect:focus {
    border-color: #007bff; /* Border color when focused */
    outline: none; /* Remove default outline */
}

/* Style for the search bar container */
.search-container {
    margin: 10px; /* Space around the search bar */
}

/* Style for the search input */
#searchBar {
    width: 100%; /* Adjust width to fit the container */
    max-width: 400px; /* Maximum width of the search bar */
    height: 40px; /* Height of the search bar */
    padding: 0 10px; /* Padding inside the search bar */
    font-size: 16px; /* Font size of the text inside the search bar */
    border: 1px solid #ccc; /* Border color and style */
    border-radius: 4px; /* Rounded corners */
    box-shadow: 0 2px 4px rgba(0,0,0,0.1); /* Subtle shadow */
    transition: border-color 0.3s; /* Smooth transition for border color */
}

/* Style for the search input on focus */
#searchBar:focus {
    border-color: #007bff; /* Border color when focused */
    outline: none; /* Remove default outline */
}

/* Optional: Style for the search button if you have one */
#searchButton {
    padding: 10px 20px;
    font-size: 16px;
    color: #fff;
    background-color: #007bff;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    margin-left: 10px;
    transition: background-color 0.3s;
}

#searchButton:hover {
    background-color: #0056b3;
}





.deadline-button {
    background-color: white;
    color: white;
    border: none;
    padding: 5px 10px;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    font-size: 14px;
}

.deadline-button .deadline-text {
    margin-right: 5px;
}

.deadline-button.expired::after {
    content: ' !';
    color: white;
    font-weight: bold;
}




/* Modal background */
.modal {
    display: none; /* Hidden by default */
    position: fixed; /* Fixed position to keep it in place relative to the viewport */
    top: 0;
    left: 0;
    width: 100%; /* Full width of the viewport */
    height: 100%; /* Full height of the viewport */
    background-color: rgba(0, 0, 0, 0.4); /* Background color with opacity */
    z-index: 1000; /* Ensure the modal is above other content */
    display: flex; /* Use flexbox to center the modal content */
    justify-content: center; /* Center horizontally */
    align-items: center; /* Center vertically */
}

/* Modal content (the actual box) */
.modal-content {
    background-color: white; /* White background for the modal */
    border: 1px solid #ccc; /* Border around the modal */
    padding: 20px; /* Padding inside the modal */
    border-radius: 4px; /* Rounded corners */
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1); /* Shadow for better visibility */
    width: 300px; /* Fixed width for the modal */
    max-width: 90%; /* Ensure modal does not exceed viewport width */
    box-sizing: border-box; /* Include padding and border in width calculation */
    position: relative; /* Ensure close button is positioned correctly */
}

/* Close button */
.close {
    position: absolute;
    top: 10px;
    right: 10px;
    cursor: pointer;
    font-size: 18px;
    font-weight: bold;
}

/* Button styling */
.modal-content button {
    padding: 10px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    background-color: #007bff;
    color: white;
    width: 100%; /* Full width buttons */
    margin-top: 5px; /* Space between buttons */
}

.modal-content button:hover {
    background-color: #0056b3;
}



/* Default background color and uniform styling for the information column */
.infoColumn {
    background-color: #f0f0f0; /* Light grey background by default */
    padding: 10px; /* Consistent padding for uniform spacing */
    border-radius: 4px; /* Rounded corners for a neat look */
    margin: 5px 0; /* Margin for spacing between list items */
    transition: background-color 0.3s ease; /* Smooth transition for background color changes */
    width: 100%; /* Ensure the column fills the width of its container */
    display: block; /* Ensure the element behaves like a block-level element */
}

/* Ensure the parent element (li) does not interfere with styling */
ul li {
    padding: 0; /* Remove default padding if any */
    margin: 0; /* Remove default margin if any */
}

/* Increased opacity for urgent tasks */
ul li.urgent .infoColumn {
    background-color: rgba(255, 0, 0, 0.2); /* Red background with increased opacity */
}

/* Ensure the entire background of the list item changes color */
ul li.urgent {
    background-color: rgba(255, 0, 0, 0.2); /* Red background for the entire list item */
}



/* Basic styling for tasks */
.task {
    padding: 50px;
    margin: 25px 0;
margin-bottom: 20px; /* Adds space between tasks */
    background-color: #f0f0f0;
    border: 1px solid #ccc;
    border-radius: 25px;
    cursor: pointer; /* Cursor style to indicate clickable/draggable */
}

/* Styling when hovering over a draggable item */
.task:hover {
    background-color: #e0e0e0;
}

/* Styling when dragging an item */
.task.dragging {
    opacity: 0.5; /* Reduced opacity to indicate dragging */
    border: 1px dashed #666; /* Dashed border while dragging */
}





/* Styling for horizontal line (hr) */
hr {
    margin: 10px 0; /* Add margin above and below the horizontal line */
    border: none;
    border-top: 1px solid #ccc; /* Solid line with light gray color */
}


body {
            font-size: 20px;
        }

        h1 {
            font-size: 30px;
        }



        ul li.urgent {
            color: black; /* Highlight urgent tasks in red */
        }

        ul li label {
            display: flex;
            align-items: center;
            color: black; /* Change label color to black */
        }

        ul li label.input {
            margin-right: 5px;
        }

        input[type="text"] {
            width: 70%;
            padding: 10px;
            font-size: 18px;
        }

        button {
            padding: 6px 12px; /* Smaller padding for buttons */
            font-size: 14px; /* Smaller font size for buttons */
            margin-right: 10px; /* Add margin to separate buttons */
        }

        .urgent-text {
            color: black; /* Change color of 'urgent' to black */
        }


        
        /* Style for modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 1;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.4);
        }

        .modal-content {
            background-color: #fefefe;
            margin: 15% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }

        .close:hover,
        .close:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }

        .task-entry {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }

.category-buttons {
    display: flex;
    flex-direction: column; /* Stack buttons vertically */
}

.category-buttons button {
    margin-bottom: 10px; /* Add margin between buttons */
}

#addCategory,
#deleteCategory,
#editCategory {
    font-size: 11px; /* Adjust the font size as needed */
}

/* Apply glassy effect to all buttons except edit and delete buttons */
button:not(.edit-button):not(.delete-button) {
    background-color: FFFFFF; /* Use rgba to specify a color with transparency */
    border: none;
    border-radius: 5px; /* Add rounded corners */
    padding: 6px 12px;
    font-size: 14px;
    margin-right: 10px;
    box-shadow: 0 2px 4px rgba(255, 255, 255, 1); /* Add a subtle shadow effect */
    color: #000000; /* Set the font color to white */
}







/* Style for the edit and delete buttons */
.edit-button,
.delete-button {
    padding: 4px 8px; /* Adjust padding for smaller size */
    font-size: 12px; /* Adjust font size for smaller size */
    cursor: pointer;
    border: none;
    outline: none;
    background-color: #ccc; /* Grey background */
    color: #000; /* Black color */
    border-radius: 4px; /* Add border-radius for rounded corners */
    transition: background-color 0.3s, color 0.3s; /* Smooth transition */
}

.edit-button:hover,
.delete-button:hover {
    background-color: #999; /* Darker grey background on hover */
    color: #000; /* Black color on hover */
}


.checkbox-wrapper {
    margin-left: 7.75in; /* Move the checkbox 5.7 inches to the left  */
   position: relative; /* Set position to relative */
    top: -0.2in; /* Move the checkbox 1.2cm upwards (negative value) */




/* Style for the container of input fields and dropdowns */
.input-container {
    margin: 10px; /* Space around the input fields and dropdowns */
}


/* CSS styles for the popup window */
.popup {
    display: none;
    position: fixed;
    z-index: 1;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow: auto;
    background-color: rgba(0, 0, 0, 0.4);
}

.popup-content {
    background-color: #fefefe;
    margin: 15% auto;
    padding: 20px;
    border: 1px solid #888;
    width: 50%;
}

.close {
    color: #aaa;
    float: right;
    font-size: 28px;
    font-weight: bold;
    cursor: pointer;
}

.close:hover,
.close:focus {
    color: black;
    text-decoration: none;
    cursor: pointer;
}





</style>



    


<!-- Center-aligned heading -->
<h3 style="text-align: center;"></h3>

<br />
<br />
<br />

<!-- Center-aligned div content -->
<div style="text-align: center;">
    

    <label for="sortSelect"></label>
    <select id="sortSelect">
        <option value="none" />&#9881;&#65039; Sorters 
        <option value="urgency" />Urgent Puller 
        <option value="category" />Categorizer 
        <option value="date-oldest" />Ascender &#65039;
        <option value="date-newest" />Descender 
        <option value="priority" />Prioritizer &#11093;&#65039;
<option value="deadline" />Deadliner &#65039;    
<option value="color" />Colorizer  <!-- New Color Sort Option -->
</select>        

<br/>
<br/>


 <button id="setReminder"> Set Reminder &#9201;&#65039;</button> <!-- Add Set Reminder button -->
</div>

   




    <div class="task-entry">
        <button id="addTask">    </button>
        <input type="text" id="newTask" placeholder="&#9999;&#65039;Add a New Task (Use Emojis for Vibrance &#10024;&#65039; )" />
        <select id="categorySelect"> <!-- Add select dropdown for categories -->
            <option value="" />Category 
            <!-- Categories will be dynamically populated here -->
        </select>



<!-- Main Button to trigger the modal -->
<button id="showModal">&#65039; Organize </button>








<!-- Modal Window -->
<div id="categoryModal" class="modal">
    <div class="modal-content">
        <button id="addCategory">&#10133; Add Category </button> <!-- Button for adding new category -->
        <button id="editCategory">&#65039; Rename Category </button> <!-- Button for editing category name -->
        <button id="deleteCategory">&#65039; Delete Category </button> <!-- Button for deleting category -->
        <span class="close">&times;</span> <!-- Close button for the modal -->
    </div>
</div>






</div>
<!-- Modal for editing category name -->
<div id="editCategoryModal" class="modal">
    <div class="modal-content">
        <span class="close">&times;</span>
        <h2>Edit Category</h2>
        <input type="text" id="editCategoryInput" placeholder="Enter new category" />
        <button id="saveEditedCategory">Save </button>
    </div>
</div>
    



  

<button id="viewAllTasks"> View All Tasks &#9874;&#65039;</button> <!-- Button for viewing all tasks -->
<input type="text" id="searchBar" placeholder=" Search tasks..." />



<button id="viewUrgentTasks">&#9200; View All Urgent Tasks &#8252;&#65039;&#8265;&#65039;</button> <!-- Button for viewing urgent tasks -->





 
<br/>
<br/>
<div class="message-board" id="messageBoard">
  <span id="messageText">IMPORTANT NOTICE: 100% Device Centric Storage! We do not store any user data in servers or have any access to it! All data is stored locally in YOUR device! All data is stored on your end and your security is your responsibility on the internet. Only when a reminder is set, the task is handed over to Google Calendar. Greetings  and a Warm Welcome from our team at Free Checklist App!You can Click/Tap to edit this message! This is your Whiteboard! Reminder: If you need to reset categories and completed tasks easily, simply download the default tasks via incognito mode and use that as a Clean Installation file.  Categories and completed tasks are user protected by nature and require multiple uploads to restore/update, and a Factory Reset to clear. WARNING: Since accessed via browser, clearing browser data will result in data loss. Please download and backup before browser reset. - Chief </span>
</div>

<span class="checkbox-wrapper">
    <label for="selectAllTasks"> Select All &#9989;</label> <!-- Label for the checkbox -->
    <input type="checkbox" id="selectAllTasks" /> <!-- Checkbox for selecting all tasks -->
</span>

<br/>
<div id="clock">Loading...</div>
     <button id="shareSelectedTasks"> Share Selected Tasks &#65039;</button> <!-- Button for sharing selected tasks -->
  


  <button id="pasteTasks">&#65039; Paste Tasks </button> <!-- Button for pasting tasks -->

<!-- Button to trigger the display of all tasks -->
<button id="displayTasks"></button>

<!-- Modal to display tasks in an iframe -->
<div id="tasksModal" class="modal">
    <div class="modal-content">
        <span class="close">&times;</span>
        <iframe id="tasksIframe"></iframe>
    </div>
</div>



<br/>
<br/>
<br/>


    <ul id="taskList">

        <!-- Existing tasks will be listed here -->
    </ul>
    <h2>Completed Tasks</h2>
    <ul id="completedList">
        <!-- Completed tasks will be listed here -->
    </ul>

<br/>





<button id="shareCompletedTasks"> Share Completed Tasks </button> <!-- Button for sharing completed tasks -->  

<button id="clearCompleted"> Clear Completed &#65039;</button>

  <!-- Modal for adding new category -->
    <div id="addCategoryModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>Add New Category</h2>
            <input type="text" id="newCategoryInput" placeholder="Enter new category" />
            <button id="saveNewCategory">Save </button>
        </div>
    </div>
    <!-- Modal for pasting tasks -->
    <div id="pasteModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>Paste Tasks</h2>
            <textarea id="pastedTasks" placeholder="Paste copied tasks here"></textarea>
            <button id="confirmPaste">Confirm</button>
        </div>
    </div>
    <script>
        if (typeof(Storage) !== "undefined") {
            let storedTasks = JSON.parse(localStorage.getItem('tasks')) || [];
            let completedTasks = JSON.parse(localStorage.getItem('completedTasks')) || [];
            



// Add event listener for the "Select All" checkbox
document.getElementById('selectAllTasks').addEventListener('change', function() {
    const selectAllCheckbox = this;
    const selectedCategory = document.getElementById('categorySelect').value;
    storedTasks.forEach(task => {
        if (task.category === selectedCategory || selectedCategory === '') {
            // Only select tasks that belong to the current category or all tasks if no category is selected
            task.select = selectAllCheckbox.checked;
        }
    });
    updateLocalStorage(); // Update local storage after selecting all tasks
    displayTasks(); // Refresh the displayed tasks
});


// Add event listener for category selection change
document.getElementById('categorySelect').addEventListener('change', function() {
    const selectAllCheckbox = document.getElementById('selectAllTasks');
    const selectedCategory = this.value;
    let tasksInSelectedCategory = storedTasks.filter(task => task.category === selectedCategory);
    // Check if there are any tasks selected in the new category
    const anyTasksSelected = tasksInSelectedCategory.some(task => task.select);
    if (!anyTasksSelected) {
        // If no tasks are selected in the new category, uncheck the "Select All" checkbox
        selectAllCheckbox.checked = false;
    }
    // Refresh the displayed tasks
    displayTasks();
});




let categories = JSON.parse(localStorage.getItem('categories')) || [ "Personal ", "Work ", "Study ", "Other "]; // Initialize with default categories

            const updateLocalStorage = () => {
                localStorage.setItem('tasks', JSON.stringify(storedTasks));
                localStorage.setItem('completedTasks', JSON.stringify(completedTasks));
                localStorage.setItem('categories', JSON.stringify(categories));
            };




 // Function to sort tasks by category
                const sortTasksByCategory = () => {
                    storedTasks.sort((a, b) => {
                        if (a.category < b.category) return -1;
                        if (a.category > b.category) return 1;
                        return 0;
                    });
// Save the sorted tasks back to localStorage
    updateLocalStorage();                       
displayTasks(); // Refresh the task display after sorting
                };

                // Function to sort tasks by urgency
                const sortTasksByUrgency = () => {
                    storedTasks.sort((a, b) => {
                        return b.urgent - a.urgent; // Sort so that urgent tasks come first
                    });
// Save the sorted tasks back to localStorage
    updateLocalStorage();                   
 displayTasks(); // Refresh the task display after sorting
                };

            
//Function to sort tasks by date
const sortTasksByDate = (order = 'newest') => {
    console.log("Sorting tasks by date");
    console.log("Before sorting:", storedTasks);

    // Function to convert locale date string to ISO string
    const parseDate = (dateString) => {
        // Example dateString: "20/08/2024, 16:27:54"
        const [datePart, timePart] = dateString.split(', ');
        const [day, month, year] = datePart.split('/').map(Number);
        const [hours, minutes, seconds] = timePart.split(':').map(Number);

        // Return the ISO string format
        return new Date(year, month - 1, day, hours, minutes, seconds).toISOString();
    };

    storedTasks.sort((a, b) => {
        // Convert locale strings to ISO strings
        const isoDateA = parseDate(a.timestamp);
        const isoDateB = parseDate(b.timestamp);

        // Compare ISO strings
        return order === 'newest' ? isoDateB.localeCompare(isoDateA) : isoDateA.localeCompare(isoDateB);
    });

// Save the sorted tasks back to localStorage
    updateLocalStorage();
    console.log("After sorting:", storedTasks);
    displayTasks();
};






// Function to sort tasks by priority
const sortTasksByPriority = () => {
    console.log("Sorting tasks by priority");
    console.log("Before sorting:", storedTasks);

    storedTasks.sort((a, b) => {
        // Assign default priority if not set
        const priorityA = a.priority !== undefined ? a.priority : 3;
        const priorityB = b.priority !== undefined ? b.priority : 3;

        return priorityB - priorityA; // Sort so that tasks with higher priority come first
    });

// Save the sorted tasks back to localStorage
    updateLocalStorage();
    console.log("After sorting:", storedTasks);
    displayTasks(); // Refresh the task display after sorting
};




// Function to sort tasks by deadline
const sortTasksByDeadline = () => {
    console.log("Sorting tasks by deadline");
    console.log("Before sorting:", storedTasks);
    storedTasks.sort((a, b) => {
        if (!a.deadline && !b.deadline) return 0; // If both tasks have no deadline
        if (!a.deadline) return 1; // If task 'a' has no deadline, move it down
        if (!b.deadline) return -1; // If task 'b' has no deadline, move it down
        const deadlineA = new Date(a.deadline);
        const deadlineB = new Date(b.deadline);
        return deadlineA - deadlineB; // Sort tasks so the earliest deadline comes first
    });
// Save the sorted tasks back to localStorage
    updateLocalStorage();
    console.log("After sorting:", storedTasks);
    displayTasks(); // Refresh the task display after sorting
};


// Function to sort tasks by highlight color
const sortTasksByColor = () => {
    console.log("Sorting tasks by color");
    console.log("Before sorting:", storedTasks);

    // Define the order of colors for sorting
    const colorOrder = [
        "#FFD700", // Golden Yellow
        "#A0C4FF", // Sky Blue
        "#98D98E", // Soft Green
        "#FFB07C", // Warm Peach
        "#C8A2C8", // Lilac
        "#66B2B2", // Teal
        "#E9747A", // Rose
        "#E0E0E0"  // Default (Gray, should be last)
    ];

    storedTasks.sort((a, b) => {
        const colorA = a.colorCode || "#E0E0E0"; // Default color if none is assigned
        const colorB = b.colorCode || "#E0E0E0";
        
        return colorOrder.indexOf(colorA) - colorOrder.indexOf(colorB);
    });

    // Save the sorted tasks back to localStorage
    updateLocalStorage();
    console.log("After sorting:", storedTasks);
    displayTasks(); // Refresh the task display after sorting
};



              // Add event listener for the sort dropdown
document.getElementById('sortSelect').addEventListener('change', function() {
    console.log("Sort option selected:", this.value);
localStorage.setItem('selectedSortType', this.value); // Save selected sort type
    
if (this.value === 'category') {
        sortTasksByCategory();
    } else if (this.value === 'urgency') {
        sortTasksByUrgency();
    } else if (this.value === 'date-newest') {
        sortTasksByDate('newest');
    } else if (this.value === 'date-oldest') {
        sortTasksByDate('oldest');
 } else if (this.value === 'priority') {
        sortTasksByPriority(); // Call the new sorting function
} else if (this.value === 'deadline') {
        sortTasksByDeadline(); // Call the new sorting function for deadlines
    } else if (this.value === 'color') {
        sortTasksByColor(); // New color sorting function
    } else {
        displayTasks(); // Reset to original display if "None" is selected
    }
});


// Function to sort tasks based on search input
const sortTasksBySearch = (searchTerm) => {
    console.log("Sorting tasks by search term:", searchTerm);
    console.log("Before sorting:", storedTasks);

    // Convert search term to lowercase for case-insensitive comparison
    const lowerCaseSearchTerm = searchTerm.toLowerCase();

    // Sort tasks so that those matching the search term come first
    storedTasks.sort((a, b) => {
        const aText = (a.text + ' ' + a.category).toLowerCase();
        const bText = (b.text + ' ' + b.category).toLowerCase();

        // Check if the search term is 'urgent'
        const isUrgentSearch = lowerCaseSearchTerm === 'urgent';

        // Determine if the task matches the search term
        const aMatches = aText.includes(lowerCaseSearchTerm) ? 1 : 0;
        const bMatches = bText.includes(lowerCaseSearchTerm) ? 1 : 0;

        // Prioritize tasks marked as urgent if the search term is 'urgent'
        if (isUrgentSearch) {
            return (b.urgent ? 1 : 0) - (a.urgent ? 1 : 0);
        }

        // Place tasks matching the search term at the top
        return bMatches - aMatches;
    });

    // Save the sorted tasks back to localStorage
    updateLocalStorage();
    console.log("After sorting:", storedTasks);

    // Refresh the task display after sorting
    displayTasks();
};

// Add event listener for the search bar
document.getElementById('searchBar').addEventListener('input', function() {
    const searchTerm = this.value;
    if (searchTerm.trim() === '') {
        // If the search term is empty, reset to original order or display all tasks
        displayTasks(); // Ensure you have a function to reset to the default display
    } else {
        sortTasksBySearch(searchTerm);
    }
});



           const addTask = () => {
    let newTaskText = document.getElementById('newTask').value;
    const category = document.getElementById('categorySelect').value; // Get selected category

    let isUrgent = false;

    // Check if the word 'urgent' is in the task text
    if (newTaskText.toLowerCase().includes('urgent')) {
        isUrgent = true;
        newTaskText = newTaskText.replace(/urgent/gi, '').trim(); // Remove the word 'urgent' from the task text
    }

    if (newTaskText.trim() !== '' && category.trim() !== '') {
        const newTask = {
            text: newTaskText,
            category: category, // Assign selected category to task
            completed: false,
            urgent: isUrgent, // Set the urgent flag based on the command
            select: false, // New property for selecting task
            timestamp: new Date().toLocaleString() // Add date and time of task entry
        };

        storedTasks.push(newTask);
        // Get the selected sort type from localStorage
        const selectedSortType = localStorage.getItem('selectedSortType');
        console.log("Auto-sorting by:", selectedSortType);

        // Auto-sort based on the selected sort type
        if (selectedSortType === 'category') {
            sortTasksByCategory();
        } else if (selectedSortType === 'urgency') {
            sortTasksByUrgency();
        } else if (selectedSortType === 'date-newest') {
            sortTasksByDate('newest');
        } else if (selectedSortType === 'date-oldest') {
            sortTasksByDate('oldest');
        } else if (selectedSortType === 'priority') {
            sortTasksByPriority();
        } else if (selectedSortType === 'deadline') {
            sortTasksByDeadline();
        }


        updateLocalStorage(); // Save to localStorage
        document.getElementById('newTask').value = '';
        displayTasks();
    } else {
        alert("Please enter both task and category.");
    }
};


     // Function to clear all completed tasks
const clearCompleted = () => {
    // Log the number of tasks before clearing
    console.log('Number of completed tasks before clearing:', completedTasks.length);
    
    // Log the completed tasks being cleared
    console.log('Completed tasks before clearing:', completedTasks.map(task => task.text));

    // Remove completed tasks from storedTasks
    storedTasks = storedTasks.filter(task => !task.completed);

    // Log the number of tasks after clearing
    console.log('Number of tasks in storedTasks after clearing completed:', storedTasks.length);

    // Clear the completedTasks array
    completedTasks = [];

    // Log the clearing of completedTasks array
    console.log('Completed tasks array has been cleared.');

    // Update localStorage with the new storedTasks
    updateLocalStorage();
    
    // Log localStorage update
    console.log('localStorage updated with new storedTasks.');

    // Refresh the display of completed tasks and all tasks
    displayCompletedTasks();
    displayTasks(); // Refresh all tasks to reflect changes

    // Log the refresh actions
    console.log('Completed tasks display and all tasks display refreshed.');
};







           
const displayTasks = () => {
    const taskList = document.getElementById('taskList');
    taskList.innerHTML = '';
    const selectedCategory = document.getElementById('categorySelect').value;

    const urlRegex = /(?:https?:\/\/(?:www\.)?[^\s]+)|(?:www\.[^\s]+)|(?:\b[A-Za-z0-9.-]+\.[A-Za-z]{2,}\b)/gi;


    for (let i = 0; i < storedTasks.length; i++) {
        const task = storedTasks[i];
        if (!task.completed && (selectedCategory === '' || task.category === selectedCategory)) {
            const listItem = document.createElement('li');
            listItem.classList.add('task');
            if (task.urgent) {
                listItem.classList.add('urgent');
            }



 // Checkbox for completion status
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.checked = task.completed;
            checkbox.addEventListener('change', () => {
                task.completed = checkbox.checked;
                updateLocalStorage();
                displayTasks();
                if (task.completed) {
task.completedTimestamp = new Date().toLocaleString(); // Log the current date and time as the completion timestamp
                    completedTasks.push(task);
                    updateLocalStorage();
                    displayCompletedTasks();
                }
            });
            listItem.appendChild(checkbox);

            // Information Column
            const infoColumn = document.createElement('div');
            infoColumn.classList.add('column');
            const taskTextWithLinks = task.text.replace(urlRegex, (match) => {
                const url = match.startsWith('www') ? `http://${match}` : match;
                return `<a href="${url}" target="_blank" style="color: blue;">${match}</a>`;
            });
            infoColumn.innerHTML = taskTextWithLinks;
            listItem.appendChild(infoColumn);

 

            // Notes Column
const notesColumn = document.createElement('div');
notesColumn.classList.add('column', 'notes-column'); // Apply notes column styles

// Create a notebook icon that opens the note editor
const notebookIcon = document.createElement('span');
notebookIcon.classList.add('notebook-icon');
notebookIcon.innerHTML = ''; // You can use an emoji or FontAwesome icon here

// Find the task text from the adjacent info column
const taskText = infoColumn.textContent.trim();

// Add an event listener to open the note editor for this task
notebookIcon.addEventListener('click', () => {
    openNoteEditor(taskText);
});

// Append the notebook icon to the notes column
notesColumn.appendChild(notebookIcon);

// Append the notes column to the list item
listItem.appendChild(notesColumn);

// Function to open the note editor
function openNoteEditor(taskText) {
    // Ensure no duplicate popups
    document.querySelectorAll('.note-popup').forEach(popup => popup.remove());

    const notePopup = document.createElement('div');
    notePopup.classList.add('note-popup');

    // Create the close button (X)
    const closeButton = document.createElement('span');
    closeButton.classList.add('close-button');
    closeButton.innerHTML = '&#215;'; // The "X" symbol
    closeButton.addEventListener('click', () => {
        notePopup.remove(); // Close the popup when clicked
    });

    // Create the textarea for note entry
    const noteTextArea = document.createElement('textarea');
    noteTextArea.placeholder = 'Write your notes here...';

    // Retrieve the task dataset from localStorage
    let storedTasks = JSON.parse(localStorage.getItem('tasks')) || [];
    let task = storedTasks.find(t => t.text === taskText);

    // Load existing note if available
    if (task && task.note) {
        noteTextArea.value = task.note;
    }

    // Auto-save notes when the user types
    noteTextArea.addEventListener('input', () => {
        saveTaskNote(taskText, noteTextArea.value);
    });

    // Append elements to the popup
    notePopup.appendChild(closeButton);
    notePopup.appendChild(noteTextArea);
    document.body.appendChild(notePopup);

    // Apply basic popup styles inline
    Object.assign(notePopup.style, {
        position: 'fixed',
        top: '50%',
        left: '50%',
        transform: 'translate(-50%, -50%)',
        width: '40%',
        maxWidth: '90%',
        background: 'white',
        border: '1px solid #ccc',
        padding: '20px',
        zIndex: '1000',
        boxShadow: '0 4px 8px rgba(0, 0, 0, 0.1)',
    });
}

// Function to save notes inside the existing task dataset
function saveTaskNote(taskText, note) {
    let storedTasks = JSON.parse(localStorage.getItem('tasks')) || [];

    const taskIndex = storedTasks.findIndex(t => t.text === taskText);
    if (taskIndex !== -1) {
        storedTasks[taskIndex].note = note;
        localStorage.setItem('tasks', JSON.stringify(storedTasks));
    }
}




// Highlights Column with Color Selector for Each Task
const highlightsColumn = document.createElement('div');
highlightsColumn.classList.add('column');

// Create a select element for background color selection
const highlightSelect = document.createElement('select');
highlightSelect.classList.add('highlight-select');

// Define highlight color options (with color emojis)
const highlightColors = [
    { name: "Default", value: "#E0E0E0", emoji: "" },
    { name: "Sky Blue", value: "#A0C4FF", emoji: "" },
    { name: "Soft Green", value: "#98D98E", emoji: "" },
    { name: "Golden Yellow", value: "#FFD700", emoji: "" },
    { name: "Warm Peach", value: "#FFB07C", emoji: "" },
    { name: "Lilac", value: "#C8A2C8", emoji: "" },
    { name: "Teal", value: "#66B2B2", emoji: "" },
    { name: "Rose", value: "#E9747A", emoji: "" }
];

// Function to retrieve saved highlight color from tasks dataset
function getTaskColor(taskText) {
    const tasks = JSON.parse(localStorage.getItem('tasks')) || [];
    const task = tasks.find(t => t.text === taskText);
    return task && task.colorCode ? task.colorCode : "#E0E0E0"; // Default to #E0E0E0 if no color is found
}

// Assign the saved color (if any) to the current task
const taskColor = getTaskColor(task.text); // Use Task Text as the unique identifier

// Add color options to the dropdown with color emojis
highlightColors.forEach(color => {
    const option = document.createElement('option');
    option.value = color.value;
    option.textContent = color.emoji;
    highlightSelect.appendChild(option);
});

// Set the current selected color based on the saved color for the task
highlightSelect.value = taskColor;

// Function to update the background color while respecting Urgent status
function updateTaskBackground() {
    if (task.urgent) {
        listItem.style.backgroundColor = "#FF4C4C"; // Urgent color always trumps
        highlightSelect.disabled = true; // Disable highlight selection for urgent tasks
    } else {
        listItem.style.backgroundColor = highlightSelect.value;
        highlightSelect.disabled = false; // Enable highlight selection for non-urgent tasks
    }
}

// Function to update task color in localStorage
function saveTaskColor(taskText, color) {
    let tasks = JSON.parse(localStorage.getItem('tasks')) || [];
    let taskIndex = tasks.findIndex(t => t.text === taskText);

    if (taskIndex !== -1) {
        if (color === "#E0E0E0") {
            delete tasks[taskIndex].colorCode; // Remove the property if default is selected
        } else {
            tasks[taskIndex].colorCode = color; // Assign new colorCode
        }
        localStorage.setItem('tasks', JSON.stringify(tasks));
    }
}

// Event listener for when a new highlight color is selected
highlightSelect.addEventListener('change', function () {
    const selectedColor = this.value;
    saveTaskColor(task.text, selectedColor); // Update the task object in localStorage
    updateTaskBackground(); // Apply the new color to the task
});

// Append the select element to the highlights column
highlightsColumn.appendChild(highlightSelect);
listItem.appendChild(highlightsColumn);

// Apply the background color update
updateTaskBackground();




// Priority Column with Dropdown
       // Create a container for the priority column
const priorityColumn = document.createElement('div');
priorityColumn.classList.add('column');

// Create a select element for priority levels
const prioritySelect = document.createElement('select');
prioritySelect.classList.add('priority-select');


// Add options to the select element for priorities 5 (highest) to 1 (lowest)
    [5, 4, 3, 2, 1].forEach(level => {
        const option = document.createElement('option');
        option.value = level;
        // Set the display text based on the priority level
        switch(level) {
            case 5:
                option.textContent = '';
                break;
            case 4:
                option.textContent = '';
                break;
            case 3:
                option.textContent = '';
                break;
            case 2:
                option.textContent = '';
                break;
            case 1:
                option.textContent = '';
                break;
        }
        // Set the selected option based on the task's current priority, default to 3 if not set
        if ((task.priority && task.priority == level) || (!task.priority && level == 3)) {
            option.selected = true;
        }
        prioritySelect.appendChild(option);
    });

// Add an event listener to update the task's priority when a new option is selected
prioritySelect.addEventListener('change', function() {
    task.priority = parseInt(this.value); // Update the task's priority, ensuring it's an integer
    
// Auto-sort by priority after changing the priority
        sortTasksByPriority();
updateLocalStorage(); // Save the updated tasks to local storage
    displayTasks(); // Refresh the displayed tasks
});

// Append the select element to the priority column
priorityColumn.appendChild(prioritySelect);

// Append the priority column to the list item
listItem.appendChild(priorityColumn);





 // Urgency Column
            const urgencyColumn = document.createElement('div');
            urgencyColumn.classList.add('column', 'urgency-column'); // Apply urgency column styles
            const urgentLabel = document.createElement('label');
            const urgentText = document.createElement('span');
            urgentText.innerText = 'Urgent';
            urgentText.classList.add('urgent-text');
            urgentLabel.appendChild(urgentText);
            const urgentCheckbox = document.createElement('input');
            urgentCheckbox.type = 'checkbox';
            urgentCheckbox.checked = task.urgent;
            urgentCheckbox.addEventListener('change', () => {
                task.urgent = urgentCheckbox.checked;
                sortTasksByUrgency();    
updateLocalStorage();
                displayTasks();
                if (task.urgent) {
                    listItem.classList.add('urgent');
                } else {
                    listItem.classList.remove('urgent');
                }
            });
            urgentLabel.appendChild(urgentCheckbox);
            urgencyColumn.appendChild(urgentLabel);
            listItem.appendChild(urgencyColumn);





// Deadline Column
// Add this to the code where the columns are created
const deadlineColumn = document.createElement('div');
deadlineColumn.classList.add('column');

const deadlineButton = document.createElement('button');
deadlineButton.innerHTML = '&#9200;';
deadlineButton.classList.add('deadline-button');

// Check if there's already a deadline set for the task
if (task.deadline) {
    deadlineButton.innerText = task.deadline;
    checkAndUpdateDeadline(task, deadlineButton); // Call the function to update the background color based on the deadline
}

// Event listener for setting the deadline
deadlineButton.addEventListener('click', () => {
    // Request notification permission
    if (Notification.permission === 'default') {
        Notification.requestPermission().then(permission => {
            if (permission === 'granted') {
                proceedWithDeadlineSetting();
            } else {
                alert('Notification permission is required to set deadlines.');
            }
        });
    } else if (Notification.permission === 'granted') {
        proceedWithDeadlineSetting();
    } else {
        alert('Notification permission is required to set deadlines.');
    }
});

deadlineColumn.appendChild(deadlineButton);
listItem.appendChild(deadlineColumn);

// Function to proceed with setting the deadline after notification permission is granted
function proceedWithDeadlineSetting() {
    const deadlineInput = prompt('Enter Deadline (yyyy-mm-dd hh:mm):', task.deadline || '');
    if (isValidDeadline(deadlineInput)) {
        const isAmending = task.deadline !== undefined;

        task.deadline = deadlineInput;
        updateLocalStorage();
        deadlineButton.innerText = task.deadline;
        checkAndUpdateDeadline(task, deadlineButton); // Update background color based on the deadline
        sortTasksByDeadline(); // Sort tasks by deadline after setting a new one

        // Cancel previous reminders before scheduling new ones
        cancelReminders(task);
        scheduleDeadlineReminders(task); // Schedule reminders for the deadline
        
        // Notify based on whether the deadline was set or amended
        notifyDeadlineChange(task, isAmending);
    } else {
        alert('Invalid deadline format. Please enter a valid date and time in the format yyyy-mm-dd hh:mm.');
    }
}

// Function to notify when the deadline is set or amended
function notifyDeadlineChange(task, isAmending) {
    if (!isAmending) {
        new Notification('Deadline Set', {
            body: `Deadline for task "${task.text}" has been set for ${task.deadline}.`,
            icon: 'https://freechecklistapp.com/freechecklistapplogo.jpg'
        });
    } else {
        new Notification('Deadline Amended', {
            body: `Deadline for task "${task.text}" has been amended to ${task.deadline}.`,
            icon: 'https://freechecklistapp.com/freechecklistapplogo.jpg'
        });
    }
}

// Function to check and update the background color and icon based on the deadline
function checkAndUpdateDeadline(task, buttonElement) {
    const deadline = new Date(task.deadline);
    const now = new Date();
    const timeDifference = deadline - now;
    const hoursDifference = timeDifference / (1000 * 60 * 60);

    if (deadline < now) {
        buttonElement.innerHTML = `${task.deadline} &#9888;&#65039;`; // Add red exclamation mark for expired deadline
        buttonElement.style.backgroundColor = 'red';
        buttonElement.style.color = 'white';
    } else if (hoursDifference <= 24) {
        buttonElement.innerHTML = `&#9200; ${task.deadline}`; // Keep the clock icon for upcoming deadlines within 24 hours
        buttonElement.style.backgroundColor = 'red';
        buttonElement.style.color = 'white';
    } else {
        buttonElement.innerHTML = `&#9200; ${task.deadline}`; // Keep the clock icon for deadlines more than 24 hours away
        buttonElement.style.backgroundColor = 'white';
        buttonElement.style.color = 'black';
    }
}

// Function to validate the deadline input
function isValidDeadline(deadlineInput) {
    const deadlineRegex = /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}$/;
    if (!deadlineInput || !deadlineRegex.test(deadlineInput)) {
        return false;
    }
    const date = new Date(deadlineInput);
    return date instanceof Date && !isNaN(date);
}

// Function to schedule reminders for the deadline
function scheduleDeadlineReminders(task) {
    const deadline = new Date(task.deadline);
    const now = new Date();

    // Clear previous reminders before scheduling new ones
    cancelReminders(task);

    const timeIntervals = [
        { label: '1 month', milliseconds: 30 * 24 * 60 * 60 * 1000 },
        { label: '2 weeks', milliseconds: 14 * 24 * 60 * 60 * 1000 },
        { label: '1 week', milliseconds: 7 * 24 * 60 * 60 * 1000 },
        { label: '5 days', milliseconds: 5 * 24 * 60 * 60 * 1000 },
        { label: '3 days', milliseconds: 3 * 24 * 60 * 60 * 1000 },
        { label: '1 day', milliseconds: 24 * 60 * 60 * 1000 },
        { label: '12 hours', milliseconds: 12 * 60 * 60 * 1000 },
        { label: '6 hours', milliseconds: 6 * 60 * 60 * 1000 },
        { label: '3 hours', milliseconds: 3 * 60 * 60 * 1000 },
        { label: '1 hour', milliseconds: 1 * 60 * 60 * 1000 },
    ];

    timeIntervals.forEach(interval => {
        const reminderTime = deadline - interval.milliseconds;
        if (reminderTime > now) {
            scheduleReminder(task, reminderTime, interval.label);
        }
    });
}

// Function to schedule a single reminder with double-check verification
function scheduleReminder(task, reminderTime, intervalLabel) {
    const now = new Date().getTime();
    const timeUntilReminder = reminderTime - now;

    // Only set a reminder if the time until the reminder is positive
    if (timeUntilReminder > 0) {
        const reminderId = setTimeout(() => {
            doubleCheckAndNotify(task, reminderTime, intervalLabel);
        }, timeUntilReminder);

        // Store the reminder ID in the task object for future reference
        if (!task.reminderIds) {
            task.reminderIds = [];
        }
        task.reminderIds.push(reminderId);
        updateLocalStorage();
    }
}

// Function to double-check and notify
function doubleCheckAndNotify(task, reminderTime, intervalLabel) {
    const checkInterval = 5000; // 5 seconds
    let checkCount = 0;
    const maxChecks = 3;

    const intervalId = setInterval(() => {
        const now = new Date().getTime();
        if (now >= reminderTime) {
            checkCount++;
            if (checkCount >= maxChecks) {
                clearInterval(intervalId);

                // Perform the final check before notifying
                if (!task.completed) {
                    new Notification('Deadline Reminder', {
                        body: `Task: ${task.text} is due in ${intervalLabel}!`,
                        icon: 'https://freechecklistapp.com/freechecklistapplogo.jpg', // Optional: Add an icon for the notification
                        tag: task.id // Use the task id to avoid duplicate notifications
                    });

                    // Update the task object and localStorage
                    updateLocalStorage();
                }
            }
        }
    }, checkInterval);
}

// Function to cancel all reminders for a task
function cancelReminders(task) {
    if (task.reminderIds) {
        task.reminderIds.forEach(id => clearTimeout(id));
        task.reminderIds = []; // Clear stored reminder IDs
        updateLocalStorage();
    }
}

// Example function to mark a task as completed and cancel its reminders
function markTaskAsCompleted(task) {
    task.completed = true;
    cancelReminders(task);
    updateLocalStorage();
    // Additional logic for marking the task as completed (e.g., updating the UI)
}



// Edit Column
const editColumn = document.createElement('div');
editColumn.classList.add('column');
const editButton = document.createElement('button');
editButton.innerText = 'Edit';
editButton.classList.add('edit-button');
editButton.addEventListener('click', () => {
    // Edit task info
    const editedTaskText = prompt('Edit Task:', task.text);
    if (editedTaskText !== null && editedTaskText.trim() !== '') {
        task.text = editedTaskText.trim();
        updateLocalStorage();
        displayTasks(); // Update task list

                // Create modal for editing category
const editCategoryModal = document.createElement('div');
editCategoryModal.classList.add('modal');
editCategoryModal.innerHTML = `
    <div class="modal-content">
               <p>Select a new category:</p>
<br/>
</br>
               <select id="editCategorySelect">
            ${categories.map(category => `<option value="${category}">${category}</option>`).join('')}
        </select>
         
<br/>
<br/>
      <button id="saveEditedCategoryBtn">Save </button>
                <button id="addNewCategoryBtn"> &#65039;Add New Category</button>


    </div>`;

        document.body.appendChild(editCategoryModal);
        editCategoryModal.style.display = "block";

        // Close modal when outside modal is clicked
        window.onclick = function (event) {
            if (event.target == editCategoryModal) {
                editCategoryModal.style.display = "none";
                document.body.removeChild(editCategoryModal);
            }
        };

        // Save edited category
        const saveEditedCategoryBtn = document.getElementById('saveEditedCategoryBtn');
        saveEditedCategoryBtn.onclick = () => {
            const selectedCategory = document.getElementById('editCategorySelect').value;
            if (selectedCategory !== '') {
                task.category = selectedCategory; // Update task's category
                updateLocalStorage(); // Update local storage with the edited category
                displayTasks(); // Update task list
                editCategoryModal.style.display = "none";
                document.body.removeChild(editCategoryModal);
            } else {
                alert("Please select a category.");
            }
        };

        // Add new category functionality
        const addNewCategoryBtn = document.getElementById('addNewCategoryBtn');
        addNewCategoryBtn.onclick = () => {
            const newCategoryName = prompt('Enter New Category:');
            if (newCategoryName !== null && newCategoryName.trim() !== '') {
                const newCategory = newCategoryName.trim();
                categories.push(newCategory);
                updateLocalStorage();
                populateCategories();
                task.category = newCategory; // Update task's category
                updateLocalStorage();
                displayTasks(); // Update task list
                editCategoryModal.style.display = "none";
                document.body.removeChild(editCategoryModal);
            }
        };
    }
});
editColumn.appendChild(editButton);
listItem.appendChild(editColumn);



            // Delete Column
const deleteColumn = document.createElement('div');
deleteColumn.classList.add('column');
const deleteButton = document.createElement('button');
deleteButton.innerText = 'Delete';
deleteButton.classList.add('delete-button');

deleteButton.addEventListener('click', () => {
    // Prompt user to confirm deletion
    const confirmDelete = confirm('Are you sure you want to delete this task?');
    if (confirmDelete) {
        // Log the confirmation
        console.log('User confirmed deletion.');

        // Delete task from storedTasks array
        const taskIndex = storedTasks.indexOf(task);
        if (taskIndex !== -1) {
            // Log the task being deleted
            console.log('Deleting task:', storedTasks[taskIndex].text);

            // Log the task before deletion
            logTaskDeletion(storedTasks[taskIndex].text);

            storedTasks.splice(taskIndex, 1);
            updateLocalStorage();
            displayTasks(); // Update task list

            // Log the successful deletion and update
            console.log('Task deleted and storedTasks updated.');
        } else {
            // Log if task is not found
            console.error('Task not found in storedTasks.');
        }
    } else {
        // Log if user canceled the deletion
        console.log('User canceled the deletion.');
    }
});

deleteColumn.appendChild(deleteButton);
listItem.appendChild(deleteColumn);


          
            // Select Column
            const selectColumn = document.createElement('div');
            selectColumn.classList.add('column');
            const selectCheckbox = document.createElement('input');
            selectCheckbox.type = 'checkbox';
            selectCheckbox.checked = task.select;
            selectCheckbox.addEventListener('change', () => {
                task.select = selectCheckbox.checked;
                updateLocalStorage();
            });
            const selectLabel = document.createElement('label');
            selectLabel.innerText = 'Select';
            selectLabel.appendChild(selectCheckbox);
            selectColumn.appendChild(selectLabel);
            listItem.appendChild(selectColumn);

            // Category Column
            const categoryColumn = document.createElement('div');
            categoryColumn.classList.add('column');
            categoryColumn.innerText = task.category;
            listItem.appendChild(categoryColumn);

            // Date and Time Column
            const timestampColumn = document.createElement('div');
            timestampColumn.classList.add('column');
            timestampColumn.innerText = task.timestamp;
            listItem.appendChild(timestampColumn);

            taskList.appendChild(listItem);

   

      
// Function to update local storage
const updatelocalStorage = () => {
    localStorage.setItem('tasks', JSON.stringify(storedTasks));
};

// Ensure the tasks are loaded and displayed on page load
document.addEventListener('DOMContentLoaded', () => {
    if (localStorage.getItem('tasks')) {
        storedTasks = JSON.parse(localStorage.getItem('tasks'));
    }
    displayTasks();
});



// Select all columns inside listItem
const columns = listItem.querySelectorAll('.column');

if (columns.length > 0) {
    // Create a wrapper for the infoColumn, which will be the first row
    const infoRow = document.createElement('div');
    infoRow.classList.add('info-row');

    // Move the first column (infoColumn) into infoRow
    infoRow.appendChild(columns[0]);
    
    // Insert the infoRow as the first row inside listItem
    listItem.prepend(infoRow);

    if (columns.length > 1) {
        // Create a wrapper for the other columns, which will be the second row
        const detailsRow = document.createElement('div');
        detailsRow.classList.add('details-row');

        // Move all columns except the first one into detailsRow
        for (let i = 1; i < columns.length; i++) {
            detailsRow.appendChild(columns[i]);
        }

        // Append the new row to listItem
        listItem.appendChild(detailsRow);
    }
}


  // Add horizontal line after each task
            taskList.appendChild(document.createElement('hr'));
        }
    }
};







const displayCompletedTasks = () => {
    const completedList = document.getElementById('completedList');
    completedList.innerHTML = '';
    for (let i = 0; i < completedTasks.length; i++) {
        const task = completedTasks[i];
        const listItem = document.createElement('li');
        listItem.classList.add('task');
        if (task.urgent) {
            listItem.classList.add('urgent');
        }
 
const deadlineText = task.deadline ? `Deadline: ${task.deadline}` : ''; 

const taskText = `${task.text} (Category: ${task.category}, Started: ${task.timestamp}${deadlineText ? `, ${deadlineText}` : ''}, Completed: ${task.completedTimestamp})`;

listItem.innerHTML = taskText;

listItem.addEventListener('click', () => {
    moveCompletedToTasks(task);
});

        completedList.appendChild(listItem);

        // Add horizontal line after each completed task
        completedList.appendChild(document.createElement('hr'));
    }
};


let currentTasks = JSON.parse(localStorage.getItem('tasks')) || []; // Initialize with current data from localStorage

const checkForUpdates = () => {
    console.log("Checking for updates...");

    // Retrieve the latest tasks from localStorage
    const updatedTasks = JSON.parse(localStorage.getItem('tasks')) || [];

    // Compare the length of currentTasks and updatedTasks to detect changes
    if (JSON.stringify(currentTasks) !== JSON.stringify(updatedTasks)) {
        console.log("Update detected. Updating tasks...");
        // Update the currentTasks to the latest state
        currentTasks = updatedTasks;

        // Update localStorage with the new data
        storedTasks = updatedTasks;
        updateLocalStorage();
        displayTasks(); // Call displayTasks to refresh the task display
    } else {
        console.log("No updates found.");
    }
};

// Check for updates every second
setInterval(checkForUpdates, 1000);




            const moveCompletedToTasks = (task) => {
                task.completed = false;
                task.timestamp = new Date().toLocaleString();
                const existingTaskIndex = storedTasks.findIndex(t => t.text === task.text && t.timestamp === task.timestamp);
                if (existingTaskIndex === -1) {
                    storedTasks.push(task);
                }
                completedTasks = completedTasks.filter((t) => t !== task);
                updateLocalStorage();
                displayTasks();
                displayCompletedTasks();
            };

const addCategory = () => {
    const modal = document.getElementById('addCategoryModal');
    const closeBtn = modal.getElementsByClassName('close')[0];
    modal.style.display = "block";
    closeBtn.onclick = function () {
        modal.style.display = "none";
        document.getElementById('newCategoryInput').value = ''; // Clear the input box when modal is closed
    };
    window.onclick = function (event) {
        if (event.target == modal) {
            modal.style.display = "none";
            document.getElementById('newCategoryInput').value = ''; // Clear the input box when modal is closed
        }
    };
    const saveBtn = document.getElementById('saveNewCategory');
    saveBtn.onclick = function () {
        const newCategory = document.getElementById('newCategoryInput').value.trim();
        if (newCategory !== '' && !categories.includes(newCategory)) {
            categories.push(newCategory);
            updateLocalStorage();
            populateCategories();
            document.getElementById('newCategoryInput').value = ''; // Clear the input box after successfully adding the category
            modal.style.display = "none";
        } else {
            alert("Category already exists or no category found.");
        }
    };
};

const editCategory = () => {
    const selectedCategory = document.getElementById('categorySelect').value;
    if (selectedCategory.trim() !== '') {
        const modal = document.getElementById('editCategoryModal');
        const closeBtn = modal.getElementsByClassName('close')[0];
        const editInput = document.getElementById('editCategoryInput');
        editInput.value = selectedCategory; // Pre-fill input with current category name
        modal.style.display = "block";
        closeBtn.onclick = function () {
            modal.style.display = "none";
        };
        window.onclick = function (event) {
            if (event.target == modal) {
                modal.style.display = "none";
            }
        };
        const saveBtn = document.getElementById('saveEditedCategory');
        saveBtn.onclick = function () {
            const editedCategoryName = editInput.value.trim();
            if (editedCategoryName !== '' && selectedCategory !== '') {
                categories = categories.map(category => category === selectedCategory ? editedCategoryName : category);
                storedTasks.forEach(task => {
                    if (task.category === selectedCategory) {
                        task.category = editedCategoryName;
                    }
                });
                updateLocalStorage();
                populateCategories();
                displayTasks();
                modal.style.display = "none";
            } else {
                alert("Please enter a new category.");
            }
        };
    } else {
        alert("Please select a category to rename.");
    }
};

document.getElementById('editCategory').addEventListener('click', editCategory);

            const deleteCategory = () => {
                const selectedCategory = document.getElementById('categorySelect').value;
                if (selectedCategory.trim() !== '') {
                    if (confirm(`Are you sure you want to delete the category "${selectedCategory}"? This action cannot be undone.`)) {
                        categories = categories.filter(cat => cat !== selectedCategory);
                        updateLocalStorage();
                        populateCategories();
                    }
                } else {
                    alert("Please select a category to delete.");
                }
            };

            const viewAllTasks = () => {
                document.getElementById('categorySelect').selectedIndex = 0;
                displayTasks();
            };

            const viewUrgentTasks = () => {
    document.getElementById('categorySelect').selectedIndex = 0;
    const urgentTasks = storedTasks.filter(task => task.urgent && !task.completed);
    const taskList = document.getElementById('taskList');
    taskList.innerHTML = '';
    urgentTasks.forEach(task => {
        const listItem = document.createElement('li');
        listItem.classList.add('task', 'urgent');
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = task.completed;
        checkbox.addEventListener('change', () => {
            task.completed = checkbox.checked;
            updateLocalStorage();
            displayTasks();
            if (task.completed) {
                completedTasks.push(task);
                updateLocalStorage();
                displayCompletedTasks();
            }
        });
        listItem.appendChild(checkbox);

        // Information Column
        const infoColumn = document.createElement('div');
        infoColumn.classList.add('column');
        infoColumn.innerText = task.text;
        listItem.appendChild(infoColumn);



// Notes Column
const notesColumn = document.createElement('div');
notesColumn.classList.add('column', 'notes-column'); // Apply notes column styles

// Create a notebook icon that opens the note editor
const notebookIcon = document.createElement('span');
notebookIcon.classList.add('notebook-icon');
notebookIcon.innerHTML = ''; // You can use an emoji or FontAwesome icon here

// Find the task text from the adjacent info column
const taskText = infoColumn.textContent.trim();

// Add an event listener to open the note editor for this task
notebookIcon.addEventListener('click', () => {
    openNoteEditor(taskText);
});

// Append the notebook icon to the notes column
notesColumn.appendChild(notebookIcon);

// Append the notes column to the list item
listItem.appendChild(notesColumn);

// Function to open the note editor
function openNoteEditor(taskText) {
    // Ensure no duplicate popups
    document.querySelectorAll('.note-popup').forEach(popup => popup.remove());

    const notePopup = document.createElement('div');
    notePopup.classList.add('note-popup');

    // Create the close button (X)
    const closeButton = document.createElement('span');
    closeButton.classList.add('close-button');
    closeButton.innerHTML = '&#215;'; // The "X" symbol
    closeButton.addEventListener('click', () => {
        notePopup.remove(); // Close the popup when clicked
    });

    // Create the textarea for note entry
    const noteTextArea = document.createElement('textarea');
    noteTextArea.placeholder = 'Write your notes here...';

    // Retrieve the task dataset from localStorage
    let storedTasks = JSON.parse(localStorage.getItem('tasks')) || [];
    let task = storedTasks.find(t => t.text === taskText);

    // Load existing note if available
    if (task && task.note) {
        noteTextArea.value = task.note;
    }

    // Auto-save notes when the user types
    noteTextArea.addEventListener('input', () => {
        saveTaskNote(taskText, noteTextArea.value);
    });

    // Append elements to the popup
    notePopup.appendChild(closeButton);
    notePopup.appendChild(noteTextArea);
    document.body.appendChild(notePopup);

    // Apply basic popup styles inline
    Object.assign(notePopup.style, {
        position: 'fixed',
        top: '50%',
        left: '50%',
        transform: 'translate(-50%, -50%)',
        width: '40%',
        maxWidth: '90%',
        background: 'white',
        border: '1px solid #ccc',
        padding: '20px',
        zIndex: '1000',
        boxShadow: '0 4px 8px rgba(0, 0, 0, 0.1)',
    });
}

// Function to save notes inside the existing task dataset
function saveTaskNote(taskText, note) {
    let storedTasks = JSON.parse(localStorage.getItem('tasks')) || [];

    const taskIndex = storedTasks.findIndex(t => t.text === taskText);
    if (taskIndex !== -1) {
        storedTasks[taskIndex].note = note;
        localStorage.setItem('tasks', JSON.stringify(storedTasks));
    }
}



// Highlights Column with Color Selector for Each Task
const highlightsColumn = document.createElement('div');
highlightsColumn.classList.add('column');

// Create a select element for background color selection
const highlightSelect = document.createElement('select');
highlightSelect.classList.add('highlight-select');

// Define highlight color options (with color emojis)
const highlightColors = [
    { name: "Default", value: "#E0E0E0", emoji: "" },
    { name: "Sky Blue", value: "#A0C4FF", emoji: "" },
    { name: "Soft Green", value: "#98D98E", emoji: "" },
    { name: "Golden Yellow", value: "#FFD700", emoji: "" },
    { name: "Warm Peach", value: "#FFB07C", emoji: "" },
    { name: "Lilac", value: "#C8A2C8", emoji: "" },
    { name: "Teal", value: "#66B2B2", emoji: "" },
    { name: "Rose", value: "#E9747A", emoji: "" }
];

// Function to retrieve saved highlight color from tasks dataset
function getTaskColor(taskText) {
    const tasks = JSON.parse(localStorage.getItem('tasks')) || [];
    const task = tasks.find(t => t.text === taskText);
    return task && task.colorCode ? task.colorCode : "#E0E0E0"; // Default to #E0E0E0 if no color is found
}

// Assign the saved color (if any) to the current task
const taskColor = getTaskColor(task.text); // Use Task Text as the unique identifier

// Add color options to the dropdown with color emojis
highlightColors.forEach(color => {
    const option = document.createElement('option');
    option.value = color.value;
    option.textContent = color.emoji;
    highlightSelect.appendChild(option);
});

// Set the current selected color based on the saved color for the task
highlightSelect.value = taskColor;

// Function to update the background color while respecting Urgent status
function updateTaskBackground() {
    if (task.urgent) {
        listItem.style.backgroundColor = "#FF4C4C"; // Urgent color always trumps
        highlightSelect.disabled = true; // Disable highlight selection for urgent tasks
    } else {
        listItem.style.backgroundColor = highlightSelect.value;
        highlightSelect.disabled = false; // Enable highlight selection for non-urgent tasks
    }
}

// Function to update task color in localStorage
function saveTaskColor(taskText, color) {
    let tasks = JSON.parse(localStorage.getItem('tasks')) || [];
    let taskIndex = tasks.findIndex(t => t.text === taskText);

    if (taskIndex !== -1) {
        if (color === "#E0E0E0") {
            delete tasks[taskIndex].colorCode; // Remove the property if default is selected
        } else {
            tasks[taskIndex].colorCode = color; // Assign new colorCode
        }
        localStorage.setItem('tasks', JSON.stringify(tasks));
    }
}

// Event listener for when a new highlight color is selected
highlightSelect.addEventListener('change', function () {
    const selectedColor = this.value;
    saveTaskColor(task.text, selectedColor); // Update the task object in localStorage
    updateTaskBackground(); // Apply the new color to the task
});

// Append the select element to the highlights column
highlightsColumn.appendChild(highlightSelect);
listItem.appendChild(highlightsColumn);

// Apply the background color update
updateTaskBackground();



// Priority Column with Dropdown
       // Create a container for the priority column
const priorityColumn = document.createElement('div');
priorityColumn.classList.add('column');

// Create a select element for priority levels
const prioritySelect = document.createElement('select');
prioritySelect.classList.add('priority-select');


// Add options to the select element for priorities 5 (highest) to 1 (lowest)
    [5, 4, 3, 2, 1].forEach(level => {
        const option = document.createElement('option');
        option.value = level;
        // Set the display text based on the priority level
        switch(level) {
            case 5:
                option.textContent = '';
                break;
            case 4:
                option.textContent = '';
                break;
            case 3:
                option.textContent = '';
                break;
            case 2:
                option.textContent = '';
                break;
            case 1:
                option.textContent = '';
                break;
        }
        // Set the selected option based on the task's current priority, default to 3 if not set
        if ((task.priority && task.priority == level) || (!task.priority && level == 3)) {
            option.selected = true;
        }
        prioritySelect.appendChild(option);
    });

// Add an event listener to update the task's priority when a new option is selected
prioritySelect.addEventListener('change', function() {
    task.priority = parseInt(this.value); // Update the task's priority, ensuring it's an integer
    // Auto-sort by priority after changing the priority
        sortTasksByPriority();
updateLocalStorage(); // Save the updated tasks to local storage
    displayTasks(); // Refresh the displayed tasks
viewUrgentTasks(); // Reload the urgent tasks view

});

// Append the select element to the priority column
priorityColumn.appendChild(prioritySelect);

// Append the priority column to the list item
listItem.appendChild(priorityColumn);



// Urgency Column
const urgencyColumn = document.createElement('div');
urgencyColumn.classList.add('column');

// Create a label for the urgent checkbox
const urgentLabel = document.createElement('label');
const urgentText = document.createElement('span');
urgentText.innerText = 'Urgent';
urgentText.classList.add('urgent-text');

// Create the urgent checkbox
const urgentCheckbox = document.createElement('input');
urgentCheckbox.type = 'checkbox';
urgentCheckbox.checked = task.urgent; // Set the checkbox state based on the task's urgency

// Event listener to handle urgency toggling
urgentCheckbox.addEventListener('change', () => {
    task.urgent = urgentCheckbox.checked; // Update the task's urgency state
    updateLocalStorage(); // Save the updated task state to localStorage
    displayTasks(); // Refresh the displayed tasks
    viewUrgentTasks(); // Reload the urgent tasks view

    // Optionally, you can add a visual cue in the listItem to indicate urgency
    if (task.urgent) {
        listItem.classList.add('urgent'); // Add a class if the task is urgent
    } else {
        listItem.classList.remove('urgent'); // Remove the class if the task is not urgent
    }
});

// Append the checkbox and text to the label
urgentLabel.appendChild(urgentText);
urgentLabel.appendChild(urgentCheckbox);

// Append the urgency label to the urgency column
urgencyColumn.appendChild(urgentLabel);

// Append the urgency column to the list item
listItem.appendChild(urgencyColumn);

// Append the list item to the task list
taskList.appendChild(listItem);




// Deadline Column
// Add this to the code where the columns are created
const deadlineColumn = document.createElement('div');
deadlineColumn.classList.add('column');

const deadlineButton = document.createElement('button');
deadlineButton.innerHTML = '&#9200;';
deadlineButton.classList.add('deadline-button');

// Check if there's already a deadline set for the task
if (task.deadline) {
    deadlineButton.innerText = task.deadline;
    checkAndUpdateDeadline(task, deadlineButton); // Call the function to update the background color based on the deadline
}

// Event listener for setting the deadline
deadlineButton.addEventListener('click', () => {
    // Request notification permission
    if (Notification.permission === 'default') {
        Notification.requestPermission().then(permission => {
            if (permission === 'granted') {
                proceedWithDeadlineSetting();
            } else {
                alert('Notification permission is required to set deadlines.');
            }
        });
    } else if (Notification.permission === 'granted') {
        proceedWithDeadlineSetting();
    } else {
        alert('Notification permission is required to set deadlines.');
    }
});

deadlineColumn.appendChild(deadlineButton);
listItem.appendChild(deadlineColumn);

// Function to proceed with setting the deadline after notification permission is granted
function proceedWithDeadlineSetting() {
    const deadlineInput = prompt('Enter Deadline (yyyy-mm-dd hh:mm):', task.deadline || '');
    if (isValidDeadline(deadlineInput)) {
        const isAmending = task.deadline !== undefined;

        task.deadline = deadlineInput;
        updateLocalStorage();
        deadlineButton.innerText = task.deadline;
        checkAndUpdateDeadline(task, deadlineButton); // Update background color based on the deadline
        sortTasksByDeadline(); // Sort tasks by deadline after setting a new one

        // Cancel previous reminders before scheduling new ones
        cancelReminders(task);
        scheduleDeadlineReminders(task); // Schedule reminders for the deadline
        
        // Notify based on whether the deadline was set or amended
        notifyDeadlineChange(task, isAmending);
    } else {
        alert('Invalid deadline format. Please enter a valid date and time in the format yyyy-mm-dd hh:mm.');
    }
}

// Function to notify when the deadline is set or amended
function notifyDeadlineChange(task, isAmending) {
    if (!isAmending) {
        new Notification('Deadline Set', {
            body: `Deadline for task "${task.text}" has been set for ${task.deadline}.`,
            icon: 'https://freechecklistapp.com/freechecklistapplogo.jpg'
        });
    } else {
        new Notification('Deadline Amended', {
            body: `Deadline for task "${task.text}" has been amended to ${task.deadline}.`,
            icon: 'https://freechecklistapp.com/freechecklistapplogo.jpg'
        });
    }
}

// Function to check and update the background color and icon based on the deadline
function checkAndUpdateDeadline(task, buttonElement) {
    const deadline = new Date(task.deadline);
    const now = new Date();
    const timeDifference = deadline - now;
    const hoursDifference = timeDifference / (1000 * 60 * 60);

    if (deadline < now) {
        buttonElement.innerHTML = `${task.deadline} &#9888;&#65039;`; // Add red exclamation mark for expired deadline
        buttonElement.style.backgroundColor = 'red';
        buttonElement.style.color = 'white';
    } else if (hoursDifference <= 24) {
        buttonElement.innerHTML = `&#9200; ${task.deadline}`; // Keep the clock icon for upcoming deadlines within 24 hours
        buttonElement.style.backgroundColor = 'red';
        buttonElement.style.color = 'white';
    } else {
        buttonElement.innerHTML = `&#9200; ${task.deadline}`; // Keep the clock icon for deadlines more than 24 hours away
        buttonElement.style.backgroundColor = 'white';
        buttonElement.style.color = 'black';
    }
}

// Function to validate the deadline input
function isValidDeadline(deadlineInput) {
    const deadlineRegex = /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}$/;
    if (!deadlineInput || !deadlineRegex.test(deadlineInput)) {
        return false;
    }
    const date = new Date(deadlineInput);
    return date instanceof Date && !isNaN(date);
}

// Function to schedule reminders for the deadline
function scheduleDeadlineReminders(task) {
    const deadline = new Date(task.deadline);
    const now = new Date();

    // Clear previous reminders before scheduling new ones
    cancelReminders(task);

    const timeIntervals = [
        { label: '1 month', milliseconds: 30 * 24 * 60 * 60 * 1000 },
        { label: '2 weeks', milliseconds: 14 * 24 * 60 * 60 * 1000 },
        { label: '1 week', milliseconds: 7 * 24 * 60 * 60 * 1000 },
        { label: '5 days', milliseconds: 5 * 24 * 60 * 60 * 1000 },
        { label: '3 days', milliseconds: 3 * 24 * 60 * 60 * 1000 },
        { label: '1 day', milliseconds: 24 * 60 * 60 * 1000 },
        { label: '12 hours', milliseconds: 12 * 60 * 60 * 1000 },
        { label: '6 hours', milliseconds: 6 * 60 * 60 * 1000 },
        { label: '3 hours', milliseconds: 3 * 60 * 60 * 1000 },
        { label: '1 hour', milliseconds: 1 * 60 * 60 * 1000 },
    ];

    timeIntervals.forEach(interval => {
        const reminderTime = deadline - interval.milliseconds;
        if (reminderTime > now) {
            scheduleReminder(task, reminderTime, interval.label);
        }
    });
}

// Function to schedule a single reminder with double-check verification
function scheduleReminder(task, reminderTime, intervalLabel) {
    const now = new Date().getTime();
    const timeUntilReminder = reminderTime - now;

    // Only set a reminder if the time until the reminder is positive
    if (timeUntilReminder > 0) {
        const reminderId = setTimeout(() => {
            doubleCheckAndNotify(task, reminderTime, intervalLabel);
        }, timeUntilReminder);

        // Store the reminder ID in the task object for future reference
        if (!task.reminderIds) {
            task.reminderIds = [];
        }
        task.reminderIds.push(reminderId);
        updateLocalStorage();
    }
}

// Function to double-check and notify
function doubleCheckAndNotify(task, reminderTime, intervalLabel) {
    const checkInterval = 5000; // 5 seconds
    let checkCount = 0;
    const maxChecks = 3;

    const intervalId = setInterval(() => {
        const now = new Date().getTime();
        if (now >= reminderTime) {
            checkCount++;
            if (checkCount >= maxChecks) {
                clearInterval(intervalId);

                // Perform the final check before notifying
                if (!task.completed) {
                    new Notification('Deadline Reminder', {
                        body: `Task: ${task.text} is due in ${intervalLabel}!`,
                        icon: 'https://freechecklistapp.com/freechecklistapplogo.jpg', // Optional: Add an icon for the notification
                        tag: task.id // Use the task id to avoid duplicate notifications
                    });

                    // Update the task object and localStorage
                    updateLocalStorage();
                }
            }
        }
    }, checkInterval);
}

// Function to cancel all reminders for a task
function cancelReminders(task) {
    if (task.reminderIds) {
        task.reminderIds.forEach(id => clearTimeout(id));
        task.reminderIds = []; // Clear stored reminder IDs
        updateLocalStorage();
    }
}

// Example function to mark a task as completed and cancel its reminders
function markTaskAsCompleted(task) {
    task.completed = true;
    cancelReminders(task);
    updateLocalStorage();
    // Additional logic for marking the task as completed (e.g., updating the UI)
}


        
 // Edit Column
const editColumn = document.createElement('div');
editColumn.classList.add('column');
const editButton = document.createElement('button');
editButton.innerText = 'Edit';
editButton.classList.add('edit-button');
editButton.addEventListener('click', () => {
    // Edit task info
    const editedTaskText = prompt('Edit Task:', task.text);
    if (editedTaskText !== null && editedTaskText.trim() !== '') {
        task.text = editedTaskText.trim();
        updateLocalStorage();
        displayTasks(); // Update task list

        // Create modal for editing category
        const editCategoryModal = document.createElement('div');
        editCategoryModal.classList.add('modal');
        editCategoryModal.innerHTML = `
            <div class="modal-content">
                
                <p>Select a new Category:</p>
                <select id="editCategorySelect">
                    ${categories.map(category => `<option value="${category}" />${category}`).join('')}
                </select>
<br/>
<br/>               
<button id="saveEditedCategoryBtn">Save </button>
                <button id="addNewCategoryBtn">&#65039;Add New Category</button>


            </div>`;
        document.body.appendChild(editCategoryModal);
        editCategoryModal.style.display = "block";

        // Close modal when outside modal is clicked
        window.onclick = function (event) {
            if (event.target == editCategoryModal) {
                editCategoryModal.style.display = "none";
                document.body.removeChild(editCategoryModal);
            }
        };

        // Save edited category
        const saveEditedCategoryBtn = document.getElementById('saveEditedCategoryBtn');
        saveEditedCategoryBtn.onclick = () => {
            const selectedCategory = document.getElementById('editCategorySelect').value;
            if (selectedCategory !== '') {
                task.category = selectedCategory; // Update task's category
                updateLocalStorage(); // Update local storage with the edited category
                displayTasks(); // Update task list
                editCategoryModal.style.display = "none";
                document.body.removeChild(editCategoryModal);
            } else {
                alert("Please select a category.");
            }
        };

        // Add new category functionality
        const addNewCategoryBtn = document.getElementById('addNewCategoryBtn');
        addNewCategoryBtn.onclick = () => {
            const newCategoryName = prompt('Enter New Category:');
            if (newCategoryName !== null && newCategoryName.trim() !== '') {
                const newCategory = newCategoryName.trim();
                categories.push(newCategory);
                updateLocalStorage();
                populateCategories();
                task.category = newCategory; // Update task's category
                updateLocalStorage();
                displayTasks(); // Update task list
                editCategoryModal.style.display = "none";
                document.body.removeChild(editCategoryModal);
            }
        };
    }
});
editColumn.appendChild(editButton);
listItem.appendChild(editColumn);

            // Delete Column
const deleteColumn = document.createElement('div');
deleteColumn.classList.add('column');
const deleteButton = document.createElement('button');
deleteButton.innerText = 'Delete';
deleteButton.classList.add('delete-button');
deleteButton.addEventListener('click', () => {
    // Prompt user to confirm deletion
    const confirmDelete = confirm('Are you sure you want to delete this task?');
    if (confirmDelete) {
        // Delete task from storedTasks array
        const taskIndex = storedTasks.indexOf(task);
        if (taskIndex !== -1) {
            storedTasks.splice(taskIndex, 1);
            updateLocalStorage();
            displayTasks(); // Update task list
        }
    }
});
deleteColumn.appendChild(deleteButton);
listItem.appendChild(deleteColumn);


// Select Column
        const selectColumn = document.createElement('div');
        selectColumn.classList.add('column');
        const selectCheckbox = document.createElement('input');
        selectCheckbox.type = 'checkbox';
        selectCheckbox.checked = task.select;
        selectCheckbox.addEventListener('change', () => {
            task.select = selectCheckbox.checked;
            updateLocalStorage();
        });
        const selectLabel = document.createElement('label');
        selectLabel.innerText = 'Select';
        selectLabel.appendChild(selectCheckbox);
        selectColumn.appendChild(selectLabel);
        listItem.appendChild(selectColumn);


        // Category Column
        const categoryColumn = document.createElement('div');
        categoryColumn.classList.add('column');
        categoryColumn.innerText = task.category;
        listItem.appendChild(categoryColumn);


// Date and Time Column
        const timestampColumn = document.createElement('div');
        timestampColumn.classList.add('column');
        timestampColumn.innerText = task.timestamp;
        listItem.appendChild(timestampColumn);




// Function to update local storage
const updatelocalStorage = () => {
    localStorage.setItem('tasks', JSON.stringify(storedTasks));
};

// Ensure the tasks are loaded and displayed on page load
document.addEventListener('DOMContentLoaded', () => {
    if (localStorage.getItem('tasks')) {
        storedTasks = JSON.parse(localStorage.getItem('tasks'));
    }
    displayTasks();
});



// Select all columns inside listItem
const columns = listItem.querySelectorAll('.column');

if (columns.length > 0) {
    // Create a wrapper for the infoColumn, which will be the first row
    const infoRow = document.createElement('div');
    infoRow.classList.add('info-row');

    // Move the first column (infoColumn) into infoRow
    infoRow.appendChild(columns[0]);
    
    // Insert the infoRow as the first row inside listItem
    listItem.prepend(infoRow);

    if (columns.length > 1) {
        // Create a wrapper for the other columns, which will be the second row
        const detailsRow = document.createElement('div');
        detailsRow.classList.add('details-row');

        // Move all columns except the first one into detailsRow
        for (let i = 1; i < columns.length; i++) {
            detailsRow.appendChild(columns[i]);
        }

        // Append the new row to listItem
        listItem.appendChild(detailsRow);
    }
}
      
        



        // Add horizontal line after each task
        taskList.appendChild(document.createElement('hr'));
    });
};

             const populateCategories = () => {
                const select = document.getElementById('categorySelect');
                select.innerHTML = '<option value="" />Category&#65039;'; // Reset dropdown
                categories.forEach(category => {
                    const option = document.createElement('option');
                    option.text = category;
                    option.value = category;
                    select.add(option);
                });
            };



            populateCategories(); // Populate category dropdown initially
            displayTasks();
            displayCompletedTasks();

            document.getElementById('addTask').addEventListener('click', addTask);
            document.getElementById('clearCompleted').addEventListener('click', clearCompleted);
            document.getElementById('addCategory').addEventListener('click', addCategory);
            document.getElementById('deleteCategory').addEventListener('click', deleteCategory);
            document.getElementById('viewAllTasks').addEventListener('click', viewAllTasks);
            document.getElementById('viewUrgentTasks').addEventListener('click', viewUrgentTasks);

            document.getElementById('newTask').addEventListener('keyup', function (event) {
                if (event.key === "Enter") {
                    addTask();
                }
            });

            document.getElementById('categorySelect').addEventListener('change', displayTasks); // Update tasks when category selection changes

            document.getElementById('shareSelectedTasks').addEventListener('click', shareSelectedTasks); // Share selected tasks button click event

            document.getElementById('pasteTasks').addEventListener('click', () => {
                const pasteModal = document.getElementById('pasteModal');
                const closeBtn = pasteModal.getElementsByClassName('close')[0];
                pasteModal.style.display = "block";
                closeBtn.onclick = function () {
                    pasteModal.style.display = "none";
                };
                window.onclick = function (event) {
                    if (event.target == pasteModal) {
                        pasteModal.style.display = "none";
                    }
                };
            });

            document.getElementById('confirmPaste').addEventListener('click', () => {
                const pastedTasks = document.getElementById('pastedTasks').value.trim();
                if (pastedTasks !== '') {
                    processPastedTasks(pastedTasks);
                    document.getElementById('pastedTasks').value = '';
                } else {
                    alert("Please paste tasks.");
                }
            });

            





 // Function to share selected tasks
function shareSelectedTasks() {
    const selectedTasks = storedTasks.filter(task => task.select && !task.completed); // Filter selected and active tasks
    let sharedList = 'Compiled Tasks:\n';
    
    selectedTasks.forEach(task => {
        const isUrgent = task.urgent ? 'Yes' : 'No'; // Check if task is urgent
        const deadline = task.deadline ? task.deadline : 'No deadline'; // Check if deadline is set
        const priority = task.priority ? task.priority : 'Not set';        
        
        // Fetch the corresponding note for the task from the 'note' dataset
        const taskNote = task.note ? task.note : 'No notes'; // Check if task has a note, otherwise display 'No notes'

        sharedList += `- ${task.text} (Category: ${task.category}, Urgent: ${isUrgent}, Deadline: ${deadline}, Priority: ${priority}, Notes: ${taskNote})\n`; // Include urgent, deadline, priority, and notes
    });

    sharedList += '\nwww.freechecklistapp.com'; // Add website link
    copyTextToClipboard(sharedList); // Copy generated list to clipboard
    alert("Selected tasks have been copied to clipboard."); // Inform user
    
    // Clear the selection of tasks and refresh checkboxes
    storedTasks.forEach(task => {
        task.select = false;
    });
    updateLocalStorage(); // Update local storage
    displayTasks(); // Refresh task display
    
    // Uncheck the "Select All" checkbox after sharing
    document.getElementById('selectAllTasks').checked = false;
}

document.getElementById('shareSelectedTasks').addEventListener('click', shareSelectedTasks); // Share selected tasks button click event

// Function to process pasted tasks
function processPastedTasks(pastedTasks) {
    const lines = pastedTasks.split('\n');
    const newTasks = [];
    const existingCategories = categories.slice(); // Create a copy of categories array
    const renamedCategories = {}; // Object to keep track of renamed categories
    const processedCategories = new Set(); // Set to store categories that have been processed

    lines.forEach(line => {
        const parts = line.split('(Category: ');
        if (parts.length === 2) {
            const taskText = parts[0].trim();
            let category = parts[1].split(',')[0].trim(); // Extract category name
            category = category.replace(/[^a-zA-Z0-9 ]/g, ''); // Remove non-alphanumeric characters
            category = category.trim(); // Trim any leading or trailing whitespace
            const urgent = parts[1].includes('Urgent: Yes');
            
            // Extract the deadline from the pasted text
            const deadlineMatch = parts[1].match(/Deadline: ([^,]+)/);
            const deadline = deadlineMatch && deadlineMatch[1].trim() !== 'No deadline' ? deadlineMatch[1].trim() : null;

            // Extract the priority from the pasted text
            const priorityMatch = parts[1].match(/Priority: (\d+)/);
            const priority = priorityMatch ? parseInt(priorityMatch[1].trim(), 10) : null;

            // Extract the note from the pasted text (if available)
            const noteMatch = parts[1].match(/Notes: ([^\n]+)/);
            const note = noteMatch ? noteMatch[1].trim() : '';

            if (taskText !== '' && category !== '') {
                if (!processedCategories.has(category)) {
                    const existingCategoryIndex = existingCategories.findIndex(cat => cat.replace(/[^a-zA-Z0-9]/g, '').toLowerCase() === category.replace(/[^a-zA-Z0-9]/g, '').toLowerCase());
                    if (existingCategoryIndex !== -1) {
                        const tasksUnderCategory = lines.filter(task => task.replace(/[^a-zA-Z0-9]/g, '').toLowerCase().includes(category.replace(/[^a-zA-Z0-9]/g, '').toLowerCase())).length > 0;
                        if (tasksUnderCategory) {
                            const addToExisting = confirm(`Category "${existingCategories[existingCategoryIndex]}" already exists. Do you want to paste tasks in category "${existingCategories[existingCategoryIndex]}"?`);
                            processedCategories.add(category);
                            if (addToExisting) {
                                lines.forEach(line => {
                                    const parts = line.split('(Category: ');
                                    if (parts.length === 2) {
                                        const taskText = parts[0].trim();
                                        const taskCategory = parts[1].split(',')[0].trim();
                                        const urgent = parts[1].includes('Urgent: Yes');
                                        const deadlineMatch = parts[1].match(/Deadline: ([^,]+)/);
                                        const deadline = deadlineMatch && deadlineMatch[1].trim() !== 'No deadline' ? deadlineMatch[1].trim() : null;
                                        const priorityMatch = parts[1].match(/Priority: (\d+)/);
                                        const priority = priorityMatch ? parseInt(priorityMatch[1].trim(), 10) : null;

                                        if (taskCategory.replace(/[^a-zA-Z0-9]/g, '').toLowerCase() === category.replace(/[^a-zA-Z0-9]/g, '').toLowerCase()) {
                                            const newTask = {
                                                text: taskText,
                                                category: existingCategories[existingCategoryIndex],
                                                completed: false,
                                                urgent: urgent,
                                                select: false,
                                                timestamp: new Date().toLocaleString(),
                                                note: note // Store the note from the pasted task
                                            };

                                            if (deadline) {
                                                newTask.deadline = deadline;
                                            }

                                            if (priority !== null) {
                                                newTask.priority = priority;
                                            }

                                            newTasks.push(newTask);
                                        }
                                    }
                                });
                            } else {
                                const newCategoryName = prompt(`Enter a new category for tasks under category "${existingCategories[existingCategoryIndex]}":`);
                                if (newCategoryName !== null && newCategoryName.trim() !== '') {
                                    const newCategory = newCategoryName.trim();
                                    lines.forEach(line => {
                                        const parts = line.split('(Category: ');
                                        if (parts.length === 2) {
                                            const taskText = parts[0].trim();
                                            const taskCategory = parts[1].split(',')[0].trim();
                                            const urgent = parts[1].includes('Urgent: Yes');
                                            const deadlineMatch = parts[1].match(/Deadline: ([^,]+)/);
                                            const deadline = deadlineMatch && deadlineMatch[1].trim() !== 'No deadline' ? deadlineMatch[1].trim() : null;
                                            const priorityMatch = parts[1].match(/Priority: (\d+)/);
                                            const priority = priorityMatch ? parseInt(priorityMatch[1].trim(), 10) : null;

                                            if (taskCategory.replace(/[^a-zA-Z0-9]/g, '').toLowerCase() === category.replace(/[^a-zA-Z0-9]/g, '').toLowerCase()) {
                                                const newTask = {
                                                    text: taskText,
                                                    category: newCategory,
                                                    completed: false,
                                                    urgent: urgent,
                                                    select: false,
                                                    timestamp: new Date().toLocaleString(),
                                                    note: note // Store the note from the pasted task
                                                };

                                                if (deadline) {
                                                    newTask.deadline = deadline;
                                                }

                                                if (priority !== null) {
                                                    newTask.priority = priority;
                                                }

                                                newTasks.push(newTask);
                                            }
                                        }
                                    });
                                    existingCategories.push(newCategory);
                                    renamedCategories[category] = newCategory;
                                }
                            }
                        }
                    } else {
                        lines.forEach(line => {
                            const parts = line.split('(Category: ');
                            if (parts.length === 2) {
                                const taskText = parts[0].trim();
                                const taskCategory = parts[1].split(',')[0].trim();
                                const urgent = parts[1].includes('Urgent: Yes');
                                const deadlineMatch = parts[1].match(/Deadline: ([^,]+)/);
                                const deadline = deadlineMatch && deadlineMatch[1].trim() !== 'No deadline' ? deadlineMatch[1].trim() : null;
                                const priorityMatch = parts[1].match(/Priority: (\d+)/);
                                const priority = priorityMatch ? parseInt(priorityMatch[1].trim(), 10) : null;

                                if (taskCategory.replace(/[^a-zA-Z0-9]/g, '').toLowerCase() === category.replace(/[^a-zA-Z0-9]/g, '').toLowerCase()) {
                                    const newTask = {
                                        text: taskText,
                                        category: category,
                                        completed: false,
                                        urgent: urgent,
                                        select: false,
                                        timestamp: new Date().toLocaleString(),
                                        note: note // Store the note from the pasted task
                                    };

                                    if (deadline) {
                                        newTask.deadline = deadline;
                                    }

                                    if (priority !== null) {
                                        newTask.priority = priority;
                                    }

                                    newTasks.push(newTask);
                                }
                            }
                        });
                        existingCategories.push(category);
                    }
                    processedCategories.add(category);
                }
            }
        }
    });

    // Adjust category names for tasks with renamed categories
    newTasks.forEach(task => {
        if (task.category in renamedCategories) {
            task.category = renamedCategories[task.category];
        }
    });

    storedTasks = storedTasks.concat(newTasks);
    updateLocalStorage();
    categories = existingCategories; // Update categories array
    populateCategories(); // Update the category dropdown
    displayTasks();

    // Close the paste modal after processing the tasks
    const pasteModal = document.getElementById('pasteModal');
    pasteModal.style.display = "none";
}




  

// Function to share completed tasks
const shareCompletedTasks = () => {
    let completedTasksText = "Completed Tasks:\n";
    completedTasks.forEach(task => {
        let taskText = `- ${task.text} (Category: ${task.category}, Started: ${task.timestamp})`;
        if (task.urgent) {
            taskText += " (Was Urgent)";
        }
        completedTasksText += taskText + "\n";
    });
    
completedTasksText += '\nwww.freechecklistapp.com'; // Add website link

copyTextToClipboard(completedTasksText);
    alert("Completed tasks have been copied to clipboard.");
};

// Add event listener for the "Share Completed Tasks" button
    document.getElementById('shareCompletedTasks').addEventListener('click', shareCompletedTasks);


            // Function to copy text to clipboard
            function copyTextToClipboard(text) {
                const textArea = document.createElement("textarea"); // Create a textarea element
                textArea.value = text; // Set its value to the text to be copied
                document.body.appendChild(textArea); // Append textarea to document body
                textArea.select(); // Select the text
                document.execCommand("copy"); // Execute copy command
                document.body.removeChild(textArea); // Remove textarea
            }
        } else {
            alert("Sorry, your browser does not support local storage.");
        }




// Get elements
const modal = document.getElementById('categoryModal');
const showModalButton = document.getElementById('showModal');
const closeButton = document.querySelector('.close');
const addCategoryButton = document.getElementById('addCategory');
const editCategoryButton = document.getElementById('editCategory');
const deleteCategoryButton = document.getElementById('deleteCategory');

// Function to close the modal
function closeModal() {
    modal.style.display = 'none';
}

// Show the modal
showModalButton.addEventListener('click', () => {
    modal.style.display = 'block';
});

// Hide the modal
closeButton.addEventListener('click', closeModal);

// Hide the modal when clicking outside of it
window.addEventListener('click', (event) => {
    if (event.target === modal) {
        closeModal();
    }
});

// Add event listeners to the action buttons
addCategoryButton.addEventListener('click', () => {
    // Your code to add a category here
    // After action is completed
    closeModal();
});

editCategoryButton.addEventListener('click', () => {
    // Your code to edit a category here
    // After action is completed
    closeModal();
});

deleteCategoryButton.addEventListener('click', () => {
    // Your code to delete a category here
    // After action is completed
    closeModal();
});




// Function to check and update deadline status
const updateDeadlineStatus = (button, deadline) => {
    if (deadline) {
        const now = new Date();
        const deadlineDate = new Date(deadline);
        if (now > deadlineDate) {
            button.classList.add('expired');
        } else {
            button.classList.remove('expired');
        }
    } else {
        button.classList.remove('expired');
    }
};

// Example of how you might call this function
const updateDeadlineDisplay = () => {
    const deadlineButtons = document.querySelectorAll('.deadline-button');
    deadlineButtons.forEach(button => {
        const deadline = button.getAttribute('data-deadline'); // Example attribute where deadline is stored
        updateDeadlineStatus(button, deadline);
    });
};

// Call this function whenever you need to check and update deadline statuses
updateDeadlineDisplay();


// Function to log deleted task text
function logTaskDeletion(taskText) {
    let deletionLog = JSON.parse(localStorage.getItem('deletion-log')) || [];
    deletionLog.push(taskText);
    localStorage.setItem('deletion-log', JSON.stringify(deletionLog));
    console.log('Task text logged:', taskText);
}


// Function to clear the deletion log
function clearDeletionLog() {
    localStorage.removeItem('deletion-log'); // Clear the log
    console.log('Deletion log has been cleared.');
}

// Function to update the last cleared date
function updateLastClearedDate() {
    const currentDate = new Date().toISOString(); // Get current date in ISO format
    localStorage.setItem('last-cleared-date', currentDate);
}

// Function to check and clear the log if a month has passed
function checkAndClearLogMonthly() {
    const lastClearedDate = localStorage.getItem('last-cleared-date');
    const currentDate = new Date();
    
    if (lastClearedDate) {
        const lastDate = new Date(lastClearedDate);
        const timeDifference = currentDate - lastDate; // Difference in milliseconds
        const oneMonthInMilliseconds = 30 * 24 * 60 * 60 * 1000; // Approximate milliseconds in a month
        
        if (timeDifference >= oneMonthInMilliseconds) {
            clearDeletionLog();
            updateLastClearedDate(); // Update last cleared date after clearing
        }
    } else {
        // If there's no record of last cleared date, clear the log and set the date
        clearDeletionLog();
        updateLastClearedDate();
    }
}

document.addEventListener('DOMContentLoaded', function () {
    checkAndClearLogMonthly(); // Check and clear the log when the page loads
});

// Optionally, run this check daily
setInterval(checkAndClearLogMonthly, 24 * 60 * 60 * 1000); // Check once a day


// Function to periodically check for updates in categories
function checkAndUpdateCategories() {
    const checkInterval = 1000; // Interval in milliseconds (1 second)

    setInterval(() => {
        // Retrieve categories from localStorage
        const storedCategoriesString = localStorage.getItem('categories');
        const storedCategories = storedCategoriesString ? JSON.parse(storedCategoriesString) : [];

        // Retrieve categories currently populated in the menu
        const existingCategories = Array.from(document.querySelectorAll('#categoriesMenu option')).map(option => option.textContent.trim());

        // Log the retrieved and existing categories for debugging
        console.log('Stored Categories:', storedCategories);
        console.log('Existing Categories in Menu:', existingCategories);

        // Find new categories that are in localStorage but not in the menu
        const newCategories = storedCategories.filter(category => !existingCategories.includes(category));

        // Log the new categories for debugging
        console.log('New Categories Found:', newCategories);

        if (newCategories.length > 0) {
            // If new categories are found, update the categories and refresh the menu
            console.log('Updating categories...');
            populateCategories(); // Call function to update categories menu
            storedTasks.forEach(task => {
                if (newCategories.includes(task.category)) {
                    task.category = task.category; // Update task's category if necessary
                }
            });
            updateLocalStorage(); // Save updated task categories to localStorage
            displayTasks(); // Refresh task display
        }
    }, checkInterval);
}

// Call the function to start periodically checking for category updates
checkAndUpdateCategories();



 document.addEventListener('DOMContentLoaded', function () {
    // Function to create HTML content from tasks
    function generateTasksHTML(tasks) {
        let htmlContent = '<html><head><style>';
        htmlContent += 'body { font-family: Arial, sans-serif; margin: 0; padding: 0; }';
        htmlContent += '.task { border-bottom: 1px solid #ddd; padding: 10px; }';
        htmlContent += '.task-title { font-size: 18px; font-weight: bold; margin-bottom: 5px; }';
        htmlContent += '.task-details { font-size: 14px; margin-bottom: 5px; }';
        htmlContent += '.urgent { color: red; font-weight: bold; }';
        htmlContent += '.completed { text-decoration: line-through; color: gray; }';
        htmlContent += '</style></head><body>';
        tasks.forEach(task => {
            htmlContent += `<div class="task ${task.completed ? 'completed' : ''}">`;
            htmlContent += `<div class="task-title">${task.text || 'Untitled Task'}</div>`;
            if (task.urgent) {
                htmlContent += `<div class="task-details urgent">Urgent</div>`;
            }
            if (task.deadline) {
                htmlContent += `<div class="task-details">Deadline: ${task.deadline}</div>`;
            }
            if (task.category) {
                htmlContent += `<div class="task-details">Category: ${task.category}</div>`;
            }
            htmlContent += `<div class="task-details">Priority: ${getPriorityText(task.priority)}</div>`;
            htmlContent += '</div>';
        });
        htmlContent += '</body></html>';
        return htmlContent;
    }

    // Function to map priority level to text
    function getPriorityText(level) {
        switch(level) {
            case 5:
                return '';
            case 4:
                return '';
            case 3:
                return '';
            case 2:
                return '';
            case 1:
                return '';
            default:
                return ''; // Default to priority 3 if not set
        }
    }

    // Function to display tasks in the iframe
    function displayTasksInIframe() {
        const tasks = JSON.parse(localStorage.getItem('tasks')) || [];
        const iframe = document.getElementById('tasksIframe');
        const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
        iframeDoc.open();
        iframeDoc.write(generateTasksHTML(tasks));
        iframeDoc.close();
    }

    // Event listener for the "Show All Tasks" button
    document.getElementById('displayTasks').addEventListener('click', function () {
        displayTasksInIframe();
        document.getElementById('tasksModal').style.display = 'block';
        startAutoUpdate(); // Start auto-updating the iframe when modal is opened
    });

    // Event listener for closing the modal
    document.querySelector('#tasksModal .close').addEventListener('click', function () {
        document.getElementById('tasksModal').style.display = 'none';
        stopAutoUpdate(); // Stop auto-updating the iframe when modal is closed
    });

    // Interval ID for auto-updating
    let updateIntervalId;

    // Function to start auto-updating the iframe
    function startAutoUpdate() {
        updateIntervalId = setInterval(displayTasksInIframe, 5000); // Update every 5 seconds
    }

    // Function to stop auto-updating the iframe
    function stopAutoUpdate() {
        clearInterval(updateIntervalId);
    }
});




const defaultTasks = [
    {
        id: 'task1',
        text: 'Greetings! Get Started with Free Checklist App&#8482;&#65039;!&#9854;&#65039;',
        category: 'Welcome',
        completed: false,
        timestamp: '2021-12-07 16:20',
        reminderIds: []
    },

    {
        id: 'task2',
        text: '&#65039;Organize, Prioritize, Set Reminders, Collaborate and Stay Productive!',
        category: 'Welcome',
        completed: false,
        timestamp: '2021-12-07 16:20',
        reminderIds: []
    },

    {
        id: 'task3',
        text: 'Explore all the features and functionality&#65039;! We Support 98 Different Languages!',
        category: 'Welcome',
        completed: false,
        timestamp: '2021-12-07 16:20',
        reminderIds: []
    },

    // Add more default tasks as needed
];
function initializeDefaultTasks() {
    const storedTasks = JSON.parse(localStorage.getItem('tasks')) || [];
    if (storedTasks.length === 0) {
        defaultTasks.forEach(task => {
            storedTasks.push(task);
        });
        localStorage.setItem('tasks', JSON.stringify(storedTasks));
    }
}

function loadTasks() {
    const storedTasks = JSON.parse(localStorage.getItem('tasks')) || [];
    storedTasks.forEach(task => {
        displayTask(task);
    });
}

function displayTask(task) {
    const listItem = document.createElement('div');
    listItem.classList.add('task-item');

    const taskText = document.createElement('div');
    taskText.textContent = task.text;
    listItem.appendChild(taskText);

    const taskCategory = document.createElement('div');
    taskCategory.textContent = task.category;
    listItem.appendChild(taskCategory);

    const taskTimestamp = document.createElement('div');
    taskTimestamp.textContent = task.timestamp;
    listItem.appendChild(taskTimestamp);

    document.getElementById('taskListContainer').appendChild(listItem);
}

document.addEventListener('DOMContentLoaded', () => {
    initializeDefaultTasks();
    loadTasks();
    // Other initialization code
});




// Set Reminder Function with Google Calendar Integration for Multiple Tasks
document.addEventListener('DOMContentLoaded', function () {
    document.getElementById('setReminder').addEventListener('click', function () {
        const storedTasks = JSON.parse(localStorage.getItem('tasks')) || [];
        const selectedTasks = storedTasks.filter(task => task.select && !task.completed);

        if (selectedTasks.length === 0) {
            alert('Please select at least one task to set a reminder.');
            return;
        }

        // Prompt user for reminder date and time
        const reminderDateTime = prompt('Enter the date and time for the reminder (YYYY-MM-DD HH:MM format):');
        if (!reminderDateTime) return;

        const reminderTimestamp = Date.parse(reminderDateTime);
        if (isNaN(reminderTimestamp)) {
            alert('Invalid date/time format. Please enter in YYYY-MM-DD HH:MM format.');
            return;
        }

        // Compile selected tasks into a formatted list
        let taskDetails = 'Tasks for Reminder:\n';
        selectedTasks.forEach((task, index) => {
            const isUrgent = task.urgent ? 'Yes' : 'No';
            const deadline = task.deadline ? task.deadline : 'No deadline';
            const priority = task.priority ? task.priority : 'Not set';
            taskDetails += `${index + 1}. ${task.text} (Category: ${task.category}, Urgent: ${isUrgent}, Deadline: ${deadline}, Priority: ${priority})\n`;
        });

        // Generate Google Calendar event link
        const formattedDate = new Date(reminderTimestamp).toISOString().replace(/-|:|\.\d+/g, '');
        const googleCalendarURL = `https://calendar.google.com/calendar/u/0/r/eventedit?dates=${formattedDate}/${formattedDate}&details=${encodeURIComponent(taskDetails)}&text=Task Reminder`;

        // Display task details and Google Calendar link
        alert(`Reminder Information:\n${taskDetails}\n\nClick OK to add this to Google Calendar.`);
        window.open(googleCalendarURL, '_blank');

        // Uncheck the "Select All" checkbox after sharing the reminder
        document.getElementById('selectAllTasks').checked = false;

        // Deselect all tasks that were selected
        storedTasks.forEach(task => {
            task.select = false;  // Deselect tasks
        });
        
        // Save the updated tasks to localStorage
        localStorage.setItem('tasks', JSON.stringify(storedTasks));
    });
});




  const messageBoard = document.getElementById('messageBoard');
  const messageText = document.getElementById('messageText');
  const defaultMessage = "IMPORTANT NOTICE: 100% Device Centric Storage! We do not store any user data in servers or have any access to it! All data is stored locally in YOUR device! All data is stored on your end and your security is your responsibility on the internet. Only when a reminder is set, the task is handed over to Google Calendar. Greetings  and a Warm Welcome from our team at Free Checklist App!You can Click/Tap to edit this message! This is your Whiteboard! Reminder: If you need to reset categories and completed tasks easily, simply download the default tasks via incognito mode and use that as a Clean Installation file.  Categories and completed tasks are user protected by nature and require multiple uploads to restore/update, and a Factory Reset to clear. WARNING: Since accessed via browser, clearing browser data will result in data loss. Please download and backup before browser reset. - Chief ";

  // Load saved message or use default
  function loadMessage() {
    const savedMessage = localStorage.getItem('chalkboardMessage') || defaultMessage;
    messageText.textContent = savedMessage;
    setMarqueeSpeed();
  }

  // Set the animation speed based on message width
  function setMarqueeSpeed() {
    const messageWidth = messageText.scrollWidth;
    const speed = 50; // Speed in pixels per second
    const duration = messageWidth / speed;

    messageText.style.animationDuration = `${duration}s`;
  }

  // Handle click to edit message
  messageBoard.addEventListener('click', () => {
    const currentMessage = localStorage.getItem('chalkboardMessage') || messageText.textContent;
    const newMessage = prompt('Enter your new message:', currentMessage);

    if (newMessage !== null) {
      if (newMessage.trim() === '') {
        localStorage.setItem('chalkboardMessage', defaultMessage);
        messageText.textContent = defaultMessage;
      } else {
        localStorage.setItem('chalkboardMessage', newMessage);
        messageText.textContent = newMessage;
      }
      setMarqueeSpeed(); // Update speed after message change
    }
  });

  // Initialize
  loadMessage();



function updateClock() {
        const clockElement = document.getElementById('clock');
        const now = new Date();
        clockElement.innerText = now.toLocaleTimeString();
    }

    setInterval(updateClock, 1000);
    updateClock();



</script>








    

</!doctype>
</div>
<div class='clear'></div>
</div></div>
<div class='tabs section' id='crosscol-overflow' name='Cross-Column 2'><div class='widget HTML' data-version='1' id='HTML2'>
<div class='widget-content'>
<!doctype html>


  
  
  
  <style>


#linkContainer {
    text-align: center;
    padding: 10px;
}

#linkContainer a {
    font-size: 1rem;
    color: #007bff;
    text-decoration: none;
    font-family: 'Arial', sans-serif;
    padding: 10px 20px;
    border: 2px solid #007bff;
    border-radius: 8px;
    transition: all 0.3s ease;
}

#linkContainer a:hover {
    background-color: #007bff;
    color: #fff;
    cursor: pointer;
}



/* Style for the main heading */
h1 {
    font-size: 2.5rem;
    font-family: 'Georgia', sans-serif;
    text-align: center;
    color: #333; /* Dark grey */
    padding: 10px;
    display: inline-block;
}

/* Style for the subheading */
h3 {
    font-size: 1.8rem;
    font-family: 'Georgia', sans-serif;
    text-align: center;
    color: #333; /* Dark grey */
    padding: 8px;
    display: inline-block;
}



/* General button styling */
#forceSync, #copyPeerId, #resetPeerId, #addPeer, #disconnectAllPeers, #connectAllPeers {
    font-size: 16px; /* Adjust font size */
    padding: 12px 20px; /* Adjust button size with padding */
    border-radius: 8px; /* Rounded corners */
    border: 2px solid #ccc; /* Border style */
    background-color: #f0f0f0; /* Light background */
    color: #333; /* Text color */
    cursor: pointer; /* Pointer on hover */
    margin: 10px 5px; /* Spacing around buttons */
    transition: background-color 0.3s ease, transform 0.3s ease; /* Smooth transition */
}

/* Hover effect */
#forceSync:hover, #copyPeerId:hover, #resetPeerId:hover, #addPeer:hover, #disconnectAllPeers:hover, #connectAllPeers:hover {
    background-color: #e0e0e0; /* Change background on hover */
    transform: scale(1.05); /* Slightly enlarge on hover */
}

/* Disabled button styling */
#disconnectAllPeers:disabled, #connectAllPeers:disabled {
    background-color: #ddd; /* Grey out disabled buttons */
    color: #888;
    cursor: not-allowed;
    transform: none;
}

/* Peer ID display */
#peerId {
    font-weight: bold;
    font-size: 18px;
    color: #444;
}

/* Input field styling */
#remotePeerId {
    font-size: 16px;
    padding: 10px;
    border: 2px solid #ccc;
    border-radius: 8px;
    width: 300px;
    margin: 10px 5px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    outline: none;
}

#remotePeerId:focus {
    border-color: #007bff;
    box-shadow: 0 0 8px rgba(0, 123, 255, 0.3);
}




    #peerListContainer {
      margin-top: 20px;
    }

    #peerList {
      list-style-type: none;
      padding: 0;
    }

    #peerList li {
      margin-bottom: 10px;
    }

    #peerList button {
      margin-left: 10px;
    }

    .disconnected {
      color: red;
    }

    .connected {
      color: green;
    }

    .peer-id-container {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .peer-id-container button {
      margin: 0;
    }


  </style>


  <h1>&#8205; Peer Sync (beta&#10160;)</h1>

<div id="linkContainer">
    <a href="https://www.freechecklistapp.com/p/learn-to-setup-and-use-peer-sync.html" target="_blank"> Learn to Setup and Use </a>
</div>


  <p id="status">Initializing...</p>

  <div class="peer-id-container">
<button id="forceSync">Force Sync</button>
   
<span>Your Peer ID: <span id="peerId">N/A</span></span>
    <button id="copyPeerId">&#10175;Copy Peer ID</button>
    <button id="resetPeerId">&#9851;&#65039;Reset Peer ID</button>
  </div>
  <input type="text" id="remotePeerId" placeholder="&#10133;Enter Remote Peer ID&#8205;" />
  <button id="addPeer">&#10133;Add Peer&#8205;</button>

  <div id="peerListContainer">
    <h3>Connected Peers</h3>
    <ul id="peerList"></ul>
    <button id="disconnectAllPeers" disabled>Refresh All Peers&#8205;</button>
    <button id="connectAllPeers" disabled>Connect All Peers</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/peerjs@1.3.2/dist/peerjs.min.js"></script>
  <script>
   let peer;
let connections = {}; // Store multiple connections
let storedPeerId = localStorage.getItem('peerId');
let storedPeers = JSON.parse(localStorage.getItem('peerList')) || {};
let lastLocalStorageState = JSON.stringify(localStorage);

// Heartbeat function to keep TURN server alive
let heartbeatIntervals = {};

function startHeartbeat(connection) {
  const peerId = connection.peer;
  
  if (heartbeatIntervals[peerId]) {
    clearInterval(heartbeatIntervals[peerId]);
  }

  heartbeatIntervals[peerId] = setInterval(() => {
    if (connection && connection.open) {
      connection.send(JSON.stringify({ type: 'heartbeat' }));
      console.log(`Heartbeat sent to peer ${peerId}`);
    }
  }, 1);
}

function stopHeartbeat(peerId) {
  clearInterval(heartbeatIntervals[peerId]);
  delete heartbeatIntervals[peerId];
}

function initializePeer() {
  peer = new Peer(storedPeerId, {
    debug: 2,
    config: {
      iceServers: [
        { 
          urls: 'turn:openrelay.metered.ca:80',
          username: 'openrelayproject',
          credential: 'openrelayproject'
        }
      ]
    }
  });

  peer.on('open', (id) => {
    if (!storedPeerId) {
      localStorage.setItem('peerId', id);
      storedPeerId = id;
    }
    console.log(`Peer connection opened. ID: ${id}`);
    document.getElementById('status').textContent = 'Ready to connect';
    document.getElementById('peerId').textContent = id;
    updatePeerList();
  });

  peer.on('error', (error) => {
    console.error('PeerJS error:', error);
    document.getElementById('status').textContent = 'Error: ' + error.type;
  });

  peer.on('connection', (connection) => {
    console.log('Incoming connection from peer:', connection.peer);
    handleIncomingConnection(connection);
  });
}

function handleIncomingConnection(connection) {
  const existingLabel = Object.keys(storedPeers).find(label => storedPeers[label].id === connection.peer);

  connection.on('open', () => {
    startHeartbeat(connection);
  });

  connection.on('close', () => {
    console.log(`Connection with ${connection.peer} closed.`);
    stopHeartbeat(connection.peer);
  });

  connection.on('data', (data) => {
    try {
      const message = JSON.parse(data);
      if (message.type === 'heartbeat') {
        console.log(`Heartbeat received from peer ${connection.peer}`);
      }
    } catch (error) {
      console.error('Failed to parse incoming message:', error);
    }
  });

if (existingLabel) {
    addConnection(connection, existingLabel);
  } else {
    const nameLabel = prompt("Enter a label for this peer connection:");

    if (nameLabel) {
      storedPeers[nameLabel] = { connected: true, id: connection.peer };
      localStorage.setItem('peerList', JSON.stringify(storedPeers));
      addConnection(connection, nameLabel);
      connection.send(JSON.stringify({ type: 'nameLabel', label: nameLabel }));
    } else {
      alert('Please enter a valid label');
      connection.close();
    }
  }
}







    function addConnection(connection, name) {
  connections[name] = connection;

  connection.on('open', () => {
    console.log(`Connected to peer: ${name}`);
    storedPeers[name] = { connected: true, id: connection.peer };
    localStorage.setItem('peerList', JSON.stringify(storedPeers));
    updatePeerList();
    syncLocalStorage(connection);
  });

  connection.on('data', (data) => {
    if (data.type === 'sync') {
      updateLocalStorage(data.storage);
    } else if (data.type === 'nameLabel') {
      storedPeers[data.label] = storedPeers[data.label] || { connected: false };
      storedPeers[data.label].connected = true;
      localStorage.setItem('peerList', JSON.stringify(storedPeers));
      updatePeerList();
    }
  });

  connection.on('close', () => {
    console.log(`Connection with peer ${name} closed`);
    storedPeers[name].connected = false; // Mark as disconnected
    localStorage.setItem('peerList', JSON.stringify(storedPeers));
    updatePeerList();
  });

  connection.on('error', (error) => {
    console.error(`Connection error with peer ${name}:`, error);
  });
}







       function syncLocalStorage(connection) {
  const storage = {};
  for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i);
    if (key !== 'peerId') {
      storage[key] = encodeURIComponent(localStorage.getItem(key)); // Ensure safe encoding
    }
  }
  console.log('Sending localStorage data:', storage);
  connection.send({ type: 'sync', storage: storage });
  updateSyncStatus('Sync completed');
}

function updateLocalStorage(incomingStorage) {
  let updated = false;

  Object.keys(incomingStorage).forEach((key) => {
    const incomingData = decodeURIComponent(incomingStorage[key]); // Decode received data
    localStorage.setItem(key, incomingData);
    updated = true;
  });

  if (updated) {
    updateSyncStatus('Local storage updated');
    signalUpdateToChecklistApp();
  }
}


    function mergeTasks(existingTasks, incomingTasks) {
      const mergedTasks = existingTasks.map((task) => {
        const matchingTask = incomingTasks.find(
          (incomingTask) =>
            incomingTask.text === task.text && incomingTask.category === task.category
        );

        if (matchingTask) {
          return {
            ...task,
            ...matchingTask, // Merge all fields from the matching task
          };
        }
        return task;
      });

      incomingTasks.forEach((incomingTask) => {
        const exists = mergedTasks.some(
          (task) =>
            task.text === incomingTask.text && task.category === incomingTask.category
        );

        if (!exists) {
          mergedTasks.push(incomingTask);
        }
      });

      return mergedTasks;
    }

    function updateSyncStatus(status) {
      console.log(status);
      document.getElementById('status').textContent = status;
    }

    function updatePeerList() {
      const peerList = document.getElementById('peerList');
      peerList.innerHTML = ''; // Clear the list
      const disconnectAllBtn = document.getElementById('disconnectAllPeers');
      const connectAllBtn = document.getElementById('connectAllPeers');
      
      Object.keys(storedPeers).forEach((name) => {
        const li = document.createElement('li');
        const status = storedPeers[name].connected ? 'Connected' : 'Disconnected';
        const statusClass = storedPeers[name].connected ? 'connected' : 'disconnected';

        li.innerHTML = `Peer: ${name} <span class="${statusClass}">${status}</span>`;

        if (storedPeers[name].connected) {
          const disconnectBtn = document.createElement('button');
          disconnectBtn.textContent = 'Disconnect';
          disconnectBtn.onclick = () => disconnectPeer(name);
          li.appendChild(disconnectBtn);

          const connectBtn = document.createElement('button');
          connectBtn.textContent = 'Connect';
          connectBtn.onclick = () => connectPeer(storedPeers[name].id);
          li.appendChild(connectBtn);
        } else {
          const connectBtn = document.createElement('button');
          connectBtn.textContent = 'Connect';
          connectBtn.onclick = () => connectPeer(storedPeers[name].id);
          li.appendChild(connectBtn);
        }

        const removeBtn = document.createElement('button');
        removeBtn.textContent = 'Remove Peer';
        removeBtn.onclick = () => removePeer(name);
        li.appendChild(removeBtn);

        peerList.appendChild(li);
      });

      disconnectAllBtn.disabled = Object.keys(connections).length === 0;
      connectAllBtn.disabled = Object.keys(storedPeers).length === 0 || Object.values(storedPeers).every(peer => peer.connected);
    }

    function connectPeer(id) {
      if (!connections[id]) {
        // Connect using Peer ID stored in localStorage
        const connection = peer.connect(id);
        addConnection(connection, Object.keys(storedPeers).find(label => storedPeers[label].id === id));
      }
    }

    function connectAllPeers() {
      Object.keys(storedPeers).forEach(name => {
        if (!storedPeers[name].connected) {
          connectPeer(storedPeers[name].id);
        }
      });
    }

    function disconnectPeer(name) {
      if (connections[name]) {
        connections[name].close();
        delete connections[name];
        storedPeers[name].connected = false;
        localStorage.setItem('peerList', JSON.stringify(storedPeers));
        updatePeerList();
      }
    }

    function disconnectAllPeers() {
      Object.keys(connections).forEach(name => {
        disconnectPeer(name);
      });
    }

    function removePeer(name) {
      if (confirm(`Are you sure you want to remove the peer ${name}?`)) {
        disconnectPeer(name);
        delete storedPeers[name];
        localStorage.setItem('peerList', JSON.stringify(storedPeers));
        updatePeerList();
      }
    }

    function autoSync() {
      const currentLocalStorageState = JSON.stringify(localStorage);

      if (currentLocalStorageState !== lastLocalStorageState) {
        lastLocalStorageState = currentLocalStorageState;

        Object.values(connections).forEach(connection => {
          if (connection.open) {
            syncLocalStorage(connection);
          }
        });
      }
    }

    setInterval(autoSync, 2000);

    function handlePeerIdInput() {
      const peerIdInput = document.getElementById('remotePeerId').value.trim();
      if (peerIdInput && !Object.values(storedPeers).some(peer => peer.id === peerIdInput)) {
        const nameLabel = prompt("Enter a label for this peer connection:");
        if (nameLabel) {
          storedPeers[nameLabel] = { connected: false, id: peerIdInput };
          localStorage.setItem('peerList', JSON.stringify(storedPeers));
          const connection = peer.connect(peerIdInput);
          addConnection(connection, nameLabel);
        } else {
          alert('Please enter a valid label');
        }
      } else {
        alert('Please enter a valid Peer ID');
      }
    }





function syncLocalStorageWithDeletionCheck(connection) {
  const storedData = localStorage.getItem('taskList');
  const localDeletionLog = JSON.parse(localStorage.getItem('deletion-log')) || [];

  if (storedData) {
    const parsedData = JSON.parse(storedData);

    const filteredData = parsedData.filter(task => 
      !localDeletionLog.includes(task.id)
    );

    connection.send(JSON.stringify({ 
      type: 'sync', 
      storage: filteredData, 
      deletionLog: localDeletionLog 
    }));

    console.log('Synced data after checking local deletion-log:', filteredData);
  }
}

// When receiving data, propagate deletions globally
function updateLocalStorageWithDeletionCheck(incomingData, incomingDeletionLog) {
  const localDeletionLog = JSON.parse(localStorage.getItem('deletion-log')) || [];

  // Merge incoming and local deletion logs
  const mergedDeletionLog = [...new Set([...localDeletionLog, ...incomingDeletionLog])];
  localStorage.setItem('deletion-log', JSON.stringify(mergedDeletionLog));

  const filteredData = incomingData.filter(task => 
    !mergedDeletionLog.includes(task.id)
  );

  localStorage.setItem('taskList', JSON.stringify(filteredData));
  console.log('Updated localStorage, skipping globally deleted tasks:', filteredData);
}

// Periodically scan and clean up localStorage
setInterval(() => {
  const storedData = JSON.parse(localStorage.getItem('taskList')) || [];
  const deletionLog = JSON.parse(localStorage.getItem('deletion-log')) || [];

  const cleanedData = storedData.filter(task => !deletionLog.includes(task.id));

  localStorage.setItem('taskList', JSON.stringify(cleanedData));
  console.log('Periodic cleanup: Removed tasks in deletion-log from taskList');
}, 1000); // Runs every 5 seconds










function forceSync() {
  Object.values(connections).forEach(connection => {
    if (connection.open) {
      syncLocalStorage(connection);
    }
  });
  updateSyncStatus('Force Sync initiated');
}





document.getElementById('forceSync').addEventListener('click', forceSync);
    

document.getElementById('addPeer').addEventListener('click', handlePeerIdInput);
    document.getElementById('disconnectAllPeers').addEventListener('click', disconnectAllPeers);
    document.getElementById('connectAllPeers').addEventListener('click', connectAllPeers);
    document.getElementById('copyPeerId').addEventListener('click', () => {
      const peerId = document.getElementById('peerId').textContent;
      navigator.clipboard.writeText(peerId).then(() => {
        alert('Peer ID copied to clipboard');
      });
    });

    document.getElementById('resetPeerId').addEventListener('click', () => {
      const newPeerId = prompt('Type: CONFIRM - Press Ok. Refresh to Unlock');
      if (newPeerId) {
        localStorage.removeItem('peerId');
        localStorage.removeItem('peerList');
        peer.destroy();
        initializePeer();
      }
    });








window.addEventListener("storage", function (event) {
    if (event.key) {
        document.getElementById("forceSync").click();
    }
});



// Function to detect category changes and trigger a page refresh
function checkForCategoryChanges() {
  const localStorageCategories = JSON.parse(localStorage.getItem('categories') || '[]');
  const syncedCategories = JSON.parse(sessionStorage.getItem('syncedCategories') || '[]');

  // Check if there's a difference between localStorage and synced categories
  const hasNewCategories = !arraysEqual(localStorageCategories, syncedCategories);

  if (hasNewCategories) {
    // Update sessionStorage with the latest categories
    sessionStorage.setItem('syncedCategories', JSON.stringify(localStorageCategories));

    // Trigger a page refresh
    window.location.reload();
  }
}

// Helper function to compare two arrays
function arraysEqual(a, b) {
  if (a.length !== b.length) return false;
  return a.every((value, index) => value === b[index]);
}

// Set an interval to check for category changes every second
setInterval(checkForCategoryChanges, 3000);

// Example function to be called when categories are synced
function onCategoriesSynced(newCategories) {
  localStorage.setItem('categories', JSON.stringify(newCategories));
  // Trigger immediate check for category changes
  checkForCategoryChanges();
}



document.getElementById('forceSync').addEventListener('click', () => {
  if (Object.keys(connections).length === 0) {
    updateSyncStatus('No connected peers to sync with.');
    return;
  }

  Object.values(connections).forEach(connection => {
    if (connection.open) {
      syncLocalStorage(connection); // Use your existing sync function
    }
  });

  updateSyncStatus('Manual sync initiated.');
});




function handleNetworkStatus() {
  window.addEventListener('Error: Network', () => {
    console.warn('Network connection lost. Refreshing page...');
    setTimeout(() => {
      location.reload();
    }, 3000); // Refresh after 3 seconds
  });

  window.addEventListener('online', () => {
    console.log('Network connection restored.');
  });
}

// Call the function on page load
handleNetworkStatus();










function ensureCompletedStatus(key, incomingData) {
  try {
    const existingData = localStorage.getItem(key) 
      ? JSON.parse(decodeURIComponent(localStorage.getItem(key))) 
      : null;

    if (existingData && existingData.completed !== true && incomingData.completed === true) {
      // Update localStorage if incoming task is marked as completed
      existingData.completed = true;
      localStorage.setItem(key, encodeURIComponent(JSON.stringify(existingData)));
      updateSyncStatus(`Task "${existingData.text}" marked as completed via sync.`);
      signalUpdateToChecklistApp();
    }
  } catch (e) {
    console.error(`Error ensuring completed status for key ${key}:`, e);
  }
}



// Track connected peers
function hasConnectedPeers() {
  console.log('Checking connected peers...');
  console.log('Connections:', connections);
  return Object.values(connections).some(connection => connection.open);
}

// Handle visibility change
document.addEventListener('visibilitychange', () => {
  console.log('Visibility changed:', document.visibilityState);
  if (document.visibilityState === 'visible') {
    if (hasConnectedPeers()) {
      console.log('App is back in foreground with connected peers &#8212; refreshing page.');
      location.reload();
    } else {
      console.log('App is back in foreground &#8212; no connected peers, skipping refresh.');
    }
  }
});



window.addEventListener("load", function () {
    document.getElementById("connectAllPeers").click();
});



window.addEventListener("beforeunload", function () {
    document.getElementById("disconnectAllPeers").click();
});



setInterval(() => {
  const connectButton = document.getElementById("connectAllPeers");
  
  if (connectButton) {
    connectButton.click();
    console.log("Connect All Peers button clicked.");
  } else {
    console.log("Connect All Peers button not found.");
  }
}, 1000); // Clicks every 1 second













   initializePeer();




 </script>

</!doctype>
</div>
<div class='clear'></div>
</div><div class='widget HTML' data-version='1' id='HTML3'>
<div class='widget-content'>
<div>
  <h3>Peer Sync Setup</h3>
  <button onclick="setupServer()">Setup Peer Sync via GitHub</button>

  <select id="repoSelect" style="display:none; margin-left: 10px;"></select>
  <button id="accessBtn" style="display:none;" onclick="accessServer()">Access Peer Sync</button>
  <button id="deleteBtn" style="display:none; margin-left: 10px;" onclick="deleteSelectedRepo()">Delete Repo</button>
</div>

<!-- Fullscreen Popup -->
<div id="popup" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:#fff;z-index:9999;">
  <button onclick="closePopup()" style="position:absolute;top:10px;right:10px;z-index:10000;font-size:18px;">&#10006; Close</button>
  <iframe id="iframe" style="width:100%;height:100%;border:none;"></iframe>
</div>

<script>
  const LS_KEY = "peerSyncRepos";

  window.onload = function () {
    loadRepoDropdown();
  };

  function loadRepoDropdown() {
    const repoList = JSON.parse(localStorage.getItem(LS_KEY) || "[]");
    const repoSelect = document.getElementById("repoSelect");
    const accessBtn = document.getElementById("accessBtn");
    const deleteBtn = document.getElementById("deleteBtn");

    if (repoList.length === 0) {
      repoSelect.style.display = "none";
      accessBtn.style.display = "none";
      deleteBtn.style.display = "none";
      return;
    }

    repoSelect.innerHTML = ""; // Clear previous options
    repoList.forEach((entry, i) => {
      const option = document.createElement("option");
      option.value = i;
      option.textContent = `${entry.username}/${entry.repo}`;
      repoSelect.appendChild(option);
    });

    repoSelect.style.display = "inline-block";
    accessBtn.style.display = "inline-block";
    deleteBtn.style.display = "inline-block";

    // Set URL on first option or current selected option
    const selectedIndex = repoSelect.selectedIndex >= 0 ? repoSelect.selectedIndex : 0;
    const selectedRepo = repoList[selectedIndex];
    accessBtn.dataset.url = `https://${selectedRepo.username}.github.io/${selectedRepo.repo}`;

    repoSelect.onchange = () => {
      const selected = repoList[repoSelect.value];
      accessBtn.dataset.url = `https://${selected.username}.github.io/${selected.repo}`;
    };
  }

  function setupServer() {
    const repoUrl = prompt("Enter GitHub Repo URL (e.g. https://github.com/username/repo)");
    const token = prompt("Enter your GitHub Personal Access Token");

    if (!repoUrl || !token) {
      alert("Missing repo URL or token.");
      return;
    }

    const parts = repoUrl.replace("https://github.com/", "").split("/");
    const username = parts[0];
    const repo = parts[1];
    const apiBase = `https://api.github.com/repos/${username}/${repo}/contents/`;
    const headers = {
      "Authorization": "token " + token,
      "Content-Type": "application/json"
    };

    fetch("https://testtesting10101010.blogspot.com/")
      .then(response => {
        if (!response.ok) throw new Error("Failed to fetch Blogger HTML");
        return response.text();
      })
      .then(bloggerHTML => {
        const fileUrl = apiBase + "index.html";

        return fetch(fileUrl, { method: "GET", headers: headers })
          .then(res => (res.status === 200 ? res.json() : null))
          .then(existing => {
            const body = {
              message: "Upload index.html",
              content: btoa(unescape(encodeURIComponent(bloggerHTML)))
            };
            if (existing && existing.sha) body.sha = existing.sha;

            return fetch(fileUrl, {
              method: "PUT",
              headers: headers,
              body: JSON.stringify(body)
            });
          });
      })
      .then(() => {
        alert("Website uploaded successfully!");

        const repoList = JSON.parse(localStorage.getItem(LS_KEY) || "[]");

        // Avoid duplicate entries
        const exists = repoList.some(item => item.username === username && item.repo === repo);
        if (!exists) {
          repoList.push({ username, repo, token });
          localStorage.setItem(LS_KEY, JSON.stringify(repoList));
        }

        loadRepoDropdown();
      })
      .catch(err => {
        console.error("Setup error:", err);
        alert("Setup failed: " + (err.message || JSON.stringify(err)));
      });
  }

  function accessServer() {
    const url = document.getElementById("accessBtn").dataset.url + "/index.html";
    const iframe = document.getElementById("iframe");
    const popup = document.getElementById("popup");

    iframe.src = url;
    popup.style.display = "block";
  }

  function closePopup() {
    const popup = document.getElementById("popup");
    const iframe = document.getElementById("iframe");
    iframe.src = "";
    popup.style.display = "none";
  }

  function deleteSelectedRepo() {
    const repoSelect = document.getElementById("repoSelect");
    const repoList = JSON.parse(localStorage.getItem(LS_KEY) || "[]");

    if (repoList.length === 0) return alert("No repos to delete.");

    const selectedIndex = repoSelect.selectedIndex;
    if (selectedIndex < 0) return alert("Please select a repo to delete.");

    const confirmDelete = confirm(`Are you sure you want to delete ${repoList[selectedIndex].username}/${repoList[selectedIndex].repo}?`);
    if (!confirmDelete) return;

    repoList.splice(selectedIndex, 1);
    localStorage.setItem(LS_KEY, JSON.stringify(repoList));

    alert("Repo deleted.");
    loadRepoDropdown();
  }
</script>
</div>
<div class='clear'></div>
</div></div>
</div>
</div>
<div class='tabs-cap-bottom cap-bottom'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
</div>
<div class='main-outer'>
<div class='main-cap-top cap-top'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
<div class='fauxborder-left main-fauxborder-left'>
<div class='fauxborder-right main-fauxborder-right'></div>
<div class='region-inner main-inner'>
<div class='columns fauxcolumns'>
<div class='fauxcolumn-outer fauxcolumn-center-outer'>
<div class='cap-top'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
<div class='fauxborder-left'>
<div class='fauxborder-right'></div>
<div class='fauxcolumn-inner'>
</div>
</div>
<div class='cap-bottom'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
</div>
<div class='fauxcolumn-outer fauxcolumn-left-outer'>
<div class='cap-top'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
<div class='fauxborder-left'>
<div class='fauxborder-right'></div>
<div class='fauxcolumn-inner'>
</div>
</div>
<div class='cap-bottom'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
</div>
<div class='fauxcolumn-outer fauxcolumn-right-outer'>
<div class='cap-top'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
<div class='fauxborder-left'>
<div class='fauxborder-right'></div>
<div class='fauxcolumn-inner'>
</div>
</div>
<div class='cap-bottom'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
</div>
<!-- corrects IE6 width calculation -->
<div class='columns-inner'>
<div class='column-center-outer'>
<div class='column-center-inner'>
<div class='main section' id='main' name='Main'><div class='widget Blog' data-version='1' id='Blog1'>
<div class='blog-posts hfeed'>
<div class='status-msg-wrap'>
<div class='status-msg-body'>
No posts.
</div>
<div class='status-msg-border'>
<div class='status-msg-bg'>
<div class='status-msg-hidden'>No posts.</div>
</div>
</div>
</div>
<div style='clear: both;'></div>
</div>
<div class='blog-pager' id='blog-pager'>
<a class='home-link' href='https://testtesting10101010.blogspot.com/'>Home</a>
</div>
<div class='clear'></div>
<div class='blog-feeds'>
<div class='feed-links'>
Subscribe to:
<a class='feed-link' href='https://testtesting10101010.blogspot.com/feeds/posts/default' target='_blank' type='application/atom+xml'>Posts (Atom)</a>
</div>
</div>
</div>
<div class='widget PopularPosts' data-version='1' id='PopularPosts1'>
<div class='widget-content popular-posts'>
<ul>
</ul>
<div class='clear'></div>
</div>
</div></div>
</div>
</div>
<div class='column-left-outer'>
<div class='column-left-inner'>
<aside>
</aside>
</div>
</div>
<div class='column-right-outer'>
<div class='column-right-inner'>
<aside>
<div class='sidebar section' id='sidebar-right-1'><div class='widget HTML' data-version='1' id='HTML4'>
<div class='widget-content'>
<!doctype html>

<style>

/* Container to hold all buttons in a single row */
.button-container {
    display: flex;
    justify-content: space-evenly; /* Even spacing between buttons */
    align-items: center;
    flex-wrap: wrap; /* Wrap buttons if the screen is too narrow */
    padding: 20px;
width: 100%
    gap: 20px; /* Adds a gap if wrap happens */
}

/* Style for all buttons */
#backupBtn, #restoreBtn, #updateBtn, #resetBtn {
    font-size: 16px;
    padding: 12px 20px;
    border-radius: 8px;
    border: 2px solid #ccc;
    background-color: #f0f0f0;
    color: #333;
    cursor: pointer;
    transition: background-color 0.3s ease, transform 0.3s ease;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    width: 200px; /* Fixed width for consistent size */
    text-align: center;
}

/* Hover effect */
#backupBtn:hover, #restoreBtn:hover, #updateBtn:hover, #resetBtn:hover {
    background-color: #e0e0e0;
    transform: scale(1.05);
}




</style>
    
    
    


    <h1></h1>

    

    <!-- Backup Button -->
    <button id="backupBtn">Download</button>

    <!-- Restore Input -->
    <input type="file" id="restoreInput" accept=".json" style="display: none;" />

    <!-- Restore Button -->
    <button id="restoreBtn">Restore</button>



    <!-- Update Data Button -->
    <button id="updateBtn" style="position: absolute; top: 20px; right: 95px;">Update&#10548;&#65039;</button>



 <!-- Reset Data Button -->
    <button id="resetBtn" style="position: absolute; top: 20px; left: 120px;">&#9851;&#65039;Reset&#65039;</button>


    <!-- Update Input -->
    <input type="file" id="updateInput" accept=".json" style="display: none;" />

    <script>
        // Ensure this function is called whenever a new category is created
        function saveCategory(category) {
            let categories = JSON.parse(localStorage.getItem("categories")) || [];
            if (!categories.includes(category)) {
                categories.push(category);
                localStorage.setItem("categories", JSON.stringify(categories));
            }
        }

        // Function to backup data
function backupData() {
    const customFilename = prompt("Enter filename for backup:", "backup_data");

    if (customFilename !== null && customFilename.trim() !== "") {
        const includePeerSync = confirm("Do you want to include Peer Sync Links?");
        const floatingEarthData = {
            "universeNo": localStorage.getItem("universeNo") || 0,
            "nodeCount": localStorage.getItem("nodeCount") || 0
        };

        const checklistData = {
            "storedTasks": JSON.parse(localStorage.getItem("tasks")) || [],
            "completedTasks": JSON.parse(localStorage.getItem("completedTasks")) || [],
            "categories": JSON.parse(localStorage.getItem("categories")) || []
        };

        // Backup notes for each task
        const taskNotes = {};
        checklistData.storedTasks.forEach(task => {
            const note = localStorage.getItem(`task_${task.id}_note`);
            if (note) taskNotes[task.id] = note;
        });

        const backupData = {
            "floatingEarthData": floatingEarthData,
            "checklistData": checklistData,
            "taskNotes": taskNotes // Save notes here
        };

        if (includePeerSync) {
            const peerSyncData = {
                "peerList": JSON.parse(localStorage.getItem("peerList")) || [],
                "peerId": localStorage.getItem("peerId") || ""
            };
            backupData["peerSyncData"] = peerSyncData;
        }

        const backupJSON = JSON.stringify(backupData);
        const backupBlob = new Blob([backupJSON], { type: "application/json" });

        const downloadLink = document.createElement("a");
        downloadLink.href = URL.createObjectURL(backupBlob);
        downloadLink.download = customFilename + ".json";
        downloadLink.click();
    } else {
        alert("Please enter a valid filename for backup.");
    }
}


// Function to restore data
function restoreData(event) {
    const file = event.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = function(e) {
            const restoredData = JSON.parse(e.target.result);
            const restorePeerSync = confirm("Do you want to restore Peer Sync Links?");

            // Restore data for Floating Earth
            localStorage.setItem("universeNo", restoredData.floatingEarthData.universeNo);
            localStorage.setItem("nodeCount", restoredData.floatingEarthData.nodeCount);

            // Restore data for Checklist App
            localStorage.setItem("tasks", JSON.stringify(restoredData.checklistData.storedTasks));
            localStorage.setItem("completedTasks", JSON.stringify(restoredData.checklistData.completedTasks));
            localStorage.setItem("categories", JSON.stringify(restoredData.checklistData.categories));

            // Restore task notes
            const taskNotes = restoredData.taskNotes || {};
            for (const taskId in taskNotes) {
                localStorage.setItem(`task_${taskId}_note`, taskNotes[taskId]);
            }

            if (restorePeerSync) {
                if (restoredData.peerSyncData) {
                    localStorage.setItem("peerList", JSON.stringify(restoredData.peerSyncData.peerList));
                    localStorage.setItem("peerId", restoredData.peerSyncData.peerId);
                } else {
                    alert("No Peer Sync Links found.");
                }
            }

            alert("Run Restore Twice to Load Categories & Completed Tasks");
            window.location.reload();
        };
        reader.readAsText(file);
    }
}


// Function to update data
function updateData(event) {
    const file = event.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = function(e) {
            const updatedData = JSON.parse(e.target.result);

            const updateOption = prompt("Select update option:\n1. Update Checklist Information\n2. Update Node Information\n3. Update Both");
            const updatePeerSync = confirm("Do you want to update Peer Sync Links?");

            if (updateOption !== null && updateOption.trim() !== "") {
                if (updateOption === "1" || updateOption === "3") {
                    // Update Checklist Information
                    const existingTasks = JSON.parse(localStorage.getItem("tasks")) || [];
                    const existingCompletedTasks = JSON.parse(localStorage.getItem("completedTasks")) || [];
                    const existingCategories = JSON.parse(localStorage.getItem("categories")) || [];

                    const newTasks = updatedData.checklistData.storedTasks.filter(task => !existingTasks.some(existingTask => existingTask.text === task.text));
                    const newCompletedTasks = updatedData.checklistData.completedTasks.filter(task => !existingCompletedTasks.some(existingTask => existingTask.text === task.text));
                    const newCategories = updatedData.checklistData.categories.filter(category => !existingCategories.includes(category));

                    const updatedTasks = existingTasks.concat(newTasks);
                    const updatedCompletedTasks = existingCompletedTasks.concat(newCompletedTasks);
                    const updatedCategories = [...new Set(existingCategories.concat(newCategories))];

                    localStorage.setItem("tasks", JSON.stringify(updatedTasks));
                    localStorage.setItem("completedTasks", JSON.stringify(updatedCompletedTasks));
                    localStorage.setItem("categories", JSON.stringify(updatedCategories));

                    // Update notes for tasks
                    const updatedNotes = updatedData.taskNotes || {};
                    for (const taskId in updatedNotes) {
                        localStorage.setItem(`task_${taskId}_note`, updatedNotes[taskId]);
                    }

                    if (updateOption === "1") {
                        alert("Checklist information updated successfully!");
                    }
                }
                if (updateOption === "2" || updateOption === "3") {
                    // Update Node Information
                    localStorage.setItem("universeNo", updatedData.floatingEarthData.universeNo);
                    localStorage.setItem("nodeCount", updatedData.floatingEarthData.nodeCount);

                    if (updateOption === "2") {
                        alert("Node information updated successfully!");
                    } else {
                        alert("Run the Update Twice to Load Categories & Completed Tasks");
                    }
                }
                if (updatePeerSync) {
                    if (updatedData.peerSyncData) {
                        localStorage.setItem("peerList", JSON.stringify(updatedData.peerSyncData.peerList));
                        localStorage.setItem("peerId", updatedData.peerSyncData.peerId);
                    } else {
                        alert("No Peer Sync Links found.");
                    }
                }
            } else {
                alert("No update option selected.");
            }

            window.location.reload();
        };
        reader.readAsText(file);
    }
}




      
// Function to reset all data
        function resetData() {
            if (confirm("Are you sure you want to reset all data?")) {
                localStorage.clear();
                alert("Tasks Reset! (Categories and Completed Tasks retained for Extended Use)");
                window.location.reload();
            }
        }

        // Event listener for reset button
        document.getElementById("resetBtn").addEventListener("click", resetData);
     

        // Event listener for backup button
        document.getElementById("backupBtn").addEventListener("click", backupData);

        // Event listener for restore button
        document.getElementById("restoreBtn").addEventListener("click", function() {
            document.getElementById("restoreInput").click();
        });

        // Event listener for restore input change
        document.getElementById("restoreInput").addEventListener("change", restoreData);

        // Event listener for update button
        document.getElementById("updateBtn").addEventListener("click", function() {
            document.getElementById("updateInput").click();
        });

        // Event listener for update input change
        document.getElementById("updateInput").addEventListener("change", updateData);
    </script>

</!doctype>
</div>
<div class='clear'></div>
</div><div class='widget BlogSearch' data-version='1' id='BlogSearch1'>
<h2 class='title'>Search This Blog</h2>
<div class='widget-content'>
<div id='BlogSearch1_form'>
<form action='https://testtesting10101010.blogspot.com/search' class='gsc-search-box' target='_top'>
<table cellpadding='0' cellspacing='0' class='gsc-search-box'>
<tbody>
<tr>
<td class='gsc-input'>
<input autocomplete='off' class='gsc-input' name='q' size='10' title='search' type='text' value=''/>
</td>
<td class='gsc-search-button'>
<input class='gsc-search-button' title='search' type='submit' value='Search'/>
</td>
</tr>
</tbody>
</table>
</form>
</div>
</div>
<div class='clear'></div>
</div><div class='widget PageList' data-version='1' id='PageList1'>
<div class='widget-content'>
<ul>
<li class='selected'>
<a href='https://testtesting10101010.blogspot.com/'>Home</a>
</li>
</ul>
<div class='clear'></div>
</div>
</div>
</div>
<table border='0' cellpadding='0' cellspacing='0' class='section-columns columns-2'>
<tbody>
<tr>
<td class='first columns-cell'>
<div class='sidebar section' id='sidebar-right-2-1'><div class='widget ReportAbuse' data-version='1' id='ReportAbuse1'>
<h3 class='title'>
<a class='report_abuse' href='https://www.blogger.com/go/report-abuse' rel='noopener nofollow' target='_blank'>
Report Abuse
</a>
</h3>
</div></div>
</td>
<td class='columns-cell'>
<div class='sidebar no-items section' id='sidebar-right-2-2'>
</div>
</td>
</tr>
</tbody>
</table>
<div class='sidebar no-items section' id='sidebar-right-3'>
</div>
</aside>
</div>
</div>
</div>
<div style='clear: both'></div>
<!-- columns -->
</div>
<!-- main -->
</div>
</div>
<div class='main-cap-bottom cap-bottom'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
</div>
<footer>
<div class='footer-outer'>
<div class='footer-cap-top cap-top'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
<div class='fauxborder-left footer-fauxborder-left'>
<div class='fauxborder-right footer-fauxborder-right'></div>
<div class='region-inner footer-inner'>
<div class='foot no-items section' id='footer-1'></div>
<table border='0' cellpadding='0' cellspacing='0' class='section-columns columns-2'>
<tbody>
<tr>
<td class='first columns-cell'>
<div class='foot no-items section' id='footer-2-1'></div>
</td>
<td class='columns-cell'>
<div class='foot no-items section' id='footer-2-2'></div>
</td>
</tr>
</tbody>
</table>
<!-- outside of the include in order to lock Attribution widget -->
<div class='foot section' id='footer-3' name='Footer'><div class='widget Attribution' data-version='1' id='Attribution1'>
<div class='widget-content' style='text-align: center;'>
Simple theme. Theme images by <a href='https://www.istockphoto.com/googleimages.php?id=11394138&amp;platform=blogger&langregion=en_GB' target='_blank'>luoman</a>. Powered by <a href='https://www.blogger.com' target='_blank'>Blogger</a>.
</div>
<div class='clear'></div>
</div></div>
</div>
</div>
<div class='footer-cap-bottom cap-bottom'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
</div>
</footer>
<!-- content -->
</div>
</div>
<div class='content-cap-bottom cap-bottom'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
</div>
</div>
<script type='text/javascript'>
    window.setTimeout(function() {
        document.body.className = document.body.className.replace('loading', '');
      }, 10);
  </script>

<script type="text/javascript" src="https://www.blogger.com/static/v1/widgets/2838643729-widgets.js"></script>
<script type='text/javascript'>
window['__wavt'] = 'AOuZoY5iY6zpj2wUVMmD7UHLenIxCeniag:1750148123939';_WidgetManager._Init('//www.blogger.com/rearrange?blogID\x3d7134852494570757091','//testtesting10101010.blogspot.com/','7134852494570757091');
_WidgetManager._SetDataContext([{'name': 'blog', 'data': {'blogId': '7134852494570757091', 'title': 'test', 'url': 'https://testtesting10101010.blogspot.com/', 'canonicalUrl': 'https://testtesting10101010.blogspot.com/', 'homepageUrl': 'https://testtesting10101010.blogspot.com/', 'searchUrl': 'https://testtesting10101010.blogspot.com/search', 'canonicalHomepageUrl': 'https://testtesting10101010.blogspot.com/', 'blogspotFaviconUrl': 'https://testtesting10101010.blogspot.com/favicon.ico', 'bloggerUrl': 'https://www.blogger.com', 'hasCustomDomain': false, 'httpsEnabled': true, 'enabledCommentProfileImages': true, 'gPlusViewType': 'FILTERED_POSTMOD', 'adultContent': false, 'analyticsAccountNumber': '', 'encoding': 'UTF-8', 'locale': 'en-GB', 'localeUnderscoreDelimited': 'en_gb', 'languageDirection': 'ltr', 'isPrivate': false, 'isMobile': false, 'isMobileRequest': false, 'mobileClass': '', 'isPrivateBlog': false, 'isDynamicViewsAvailable': true, 'feedLinks': '\x3clink rel\x3d\x22alternate\x22 type\x3d\x22application/atom+xml\x22 title\x3d\x22test - Atom\x22 href\x3d\x22https://testtesting10101010.blogspot.com/feeds/posts/default\x22 /\x3e\n\x3clink rel\x3d\x22alternate\x22 type\x3d\x22application/rss+xml\x22 title\x3d\x22test - RSS\x22 href\x3d\x22https://testtesting10101010.blogspot.com/feeds/posts/default?alt\x3drss\x22 /\x3e\n\x3clink rel\x3d\x22service.post\x22 type\x3d\x22application/atom+xml\x22 title\x3d\x22test - Atom\x22 href\x3d\x22https://www.blogger.com/feeds/7134852494570757091/posts/default\x22 /\x3e\n', 'meTag': '', 'adsenseHostId': 'ca-host-pub-1556223355139109', 'adsenseHasAds': false, 'adsenseAutoAds': false, 'boqCommentIframeForm': true, 'loginRedirectParam': '', 'view': '', 'dynamicViewsCommentsSrc': '//www.blogblog.com/dynamicviews/4224c15c4e7c9321/js/comments.js', 'dynamicViewsScriptSrc': '//www.blogblog.com/dynamicviews/a332d1916da3fccd', 'plusOneApiSrc': 'https://apis.google.com/js/platform.js', 'disableGComments': true, 'interstitialAccepted': false, 'sharing': {'platforms': [{'name': 'Get link', 'key': 'link', 'shareMessage': 'Get link', 'target': ''}, {'name': 'Facebook', 'key': 'facebook', 'shareMessage': 'Share to Facebook', 'target': 'facebook'}, {'name': 'BlogThis!', 'key': 'blogThis', 'shareMessage': 'BlogThis!', 'target': 'blog'}, {'name': 'X', 'key': 'twitter', 'shareMessage': 'Share to X', 'target': 'twitter'}, {'name': 'Pinterest', 'key': 'pinterest', 'shareMessage': 'Share to Pinterest', 'target': 'pinterest'}, {'name': 'Email', 'key': 'email', 'shareMessage': 'Email', 'target': 'email'}], 'disableGooglePlus': true, 'googlePlusShareButtonWidth': 0, 'googlePlusBootstrap': '\x3cscript type\x3d\x22text/javascript\x22\x3ewindow.___gcfg \x3d {\x27lang\x27: \x27en_GB\x27};\x3c/script\x3e'}, 'hasCustomJumpLinkMessage': false, 'jumpLinkMessage': 'Read more', 'pageType': 'index', 'pageName': '', 'pageTitle': 'test'}}, {'name': 'features', 'data': {}}, {'name': 'messages', 'data': {'edit': 'Edit', 'linkCopiedToClipboard': 'Link copied to clipboard', 'ok': 'Ok', 'postLink': 'Post link'}}, {'name': 'template', 'data': {'name': 'Simple', 'localizedName': 'Simple', 'isResponsive': false, 'isAlternateRendering': false, 'isCustom': false, 'variant': 'literate', 'variantId': 'literate'}}, {'name': 'view', 'data': {'classic': {'name': 'classic', 'url': '?view\x3dclassic'}, 'flipcard': {'name': 'flipcard', 'url': '?view\x3dflipcard'}, 'magazine': {'name': 'magazine', 'url': '?view\x3dmagazine'}, 'mosaic': {'name': 'mosaic', 'url': '?view\x3dmosaic'}, 'sidebar': {'name': 'sidebar', 'url': '?view\x3dsidebar'}, 'snapshot': {'name': 'snapshot', 'url': '?view\x3dsnapshot'}, 'timeslide': {'name': 'timeslide', 'url': '?view\x3dtimeslide'}, 'isMobile': false, 'title': 'test', 'description': '', 'url': 'https://testtesting10101010.blogspot.com/', 'type': 'feed', 'isSingleItem': false, 'isMultipleItems': true, 'isError': false, 'isPage': false, 'isPost': false, 'isHomepage': true, 'isArchive': false, 'isLabelSearch': false}}]);
_WidgetManager._RegisterWidget('_NavbarView', new _WidgetInfo('Navbar1', 'navbar', document.getElementById('Navbar1'), {}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_HeaderView', new _WidgetInfo('Header1', 'header', document.getElementById('Header1'), {}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_HTMLView', new _WidgetInfo('HTML1', 'crosscol', document.getElementById('HTML1'), {}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_HTMLView', new _WidgetInfo('HTML2', 'crosscol-overflow', document.getElementById('HTML2'), {}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_HTMLView', new _WidgetInfo('HTML3', 'crosscol-overflow', document.getElementById('HTML3'), {}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_BlogView', new _WidgetInfo('Blog1', 'main', document.getElementById('Blog1'), {'cmtInteractionsEnabled': false, 'navMessage': 'No posts.', 'lightboxEnabled': true, 'lightboxModuleUrl': 'https://www.blogger.com/static/v1/jsbin/3668400948-lbx__en_gb.js', 'lightboxCssUrl': 'https://www.blogger.com/static/v1/v-css/123180807-lightbox_bundle.css'}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_PopularPostsView', new _WidgetInfo('PopularPosts1', 'main', document.getElementById('PopularPosts1'), {}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_HTMLView', new _WidgetInfo('HTML4', 'sidebar-right-1', document.getElementById('HTML4'), {}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_BlogSearchView', new _WidgetInfo('BlogSearch1', 'sidebar-right-1', document.getElementById('BlogSearch1'), {}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_PageListView', new _WidgetInfo('PageList1', 'sidebar-right-1', document.getElementById('PageList1'), {'title': '', 'links': [{'isCurrentPage': true, 'href': 'https://testtesting10101010.blogspot.com/', 'title': 'Home'}], 'mobile': false, 'showPlaceholder': true, 'hasCurrentPage': true}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_ReportAbuseView', new _WidgetInfo('ReportAbuse1', 'sidebar-right-2-1', document.getElementById('ReportAbuse1'), {}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_AttributionView', new _WidgetInfo('Attribution1', 'footer-3', document.getElementById('Attribution1'), {}, 'displayModeFull'));
</script>
</body>
</html>