<!DOCTYPE html>
<html class='v2' dir='ltr' lang='en-GB'>
<head>
<link href='https://www.blogger.com/static/v1/widgets/573632073-css_bundle_v2.css' rel='stylesheet' type='text/css'/>
<meta content='width=1100' name='viewport'/>
<meta content='text/html; charset=UTF-8' http-equiv='Content-Type'/>
<meta content='blogger' name='generator'/>
<link href='https://testtesting10101010.blogspot.com/favicon.ico' rel='icon' type='image/x-icon'/>
<link href='https://testtesting10101010.blogspot.com/' rel='canonical'/>
<link rel="alternate" type="application/atom+xml" title="test - Atom" href="https://testtesting10101010.blogspot.com/feeds/posts/default" />
<link rel="alternate" type="application/rss+xml" title="test - RSS" href="https://testtesting10101010.blogspot.com/feeds/posts/default?alt=rss" />
<link rel="service.post" type="application/atom+xml" title="test - Atom" href="https://www.blogger.com/feeds/7134852494570757091/posts/default" />
<!--Can't find substitution for tag [blog.ieCssRetrofitLinks]-->
<meta content='https://testtesting10101010.blogspot.com/' property='og:url'/>
<meta content='test' property='og:title'/>
<meta content='' property='og:description'/>
<title>test</title>
<style id='page-skin-1' type='text/css'><!--
/*
-----------------------------------------------
Blogger Template Style
Name:     Simple
Designer: Blogger
URL:      www.blogger.com
----------------------------------------------- */
/* Content
----------------------------------------------- */
body {
font: normal normal 14px Georgia, Utopia, 'Palatino Linotype', Palatino, serif;
color: #222222;
background: #513831 url(//themes.googleusercontent.com/image?id=1KH22PlFqsiVYxboQNAoJjYmRbw5M4REHmdJbHT5M2x9zVMGrCqwSjZvaQW_A10KPc6Il) repeat scroll top center /* Credit: luoman (https://www.istockphoto.com/googleimages.php?id=11394138&amp;platform=blogger) */;
padding: 0 40px 40px 40px;
}
html body .region-inner {
min-width: 0;
max-width: 100%;
width: auto;
}
h2 {
font-size: 22px;
}
a:link {
text-decoration:none;
color: #993300;
}
a:visited {
text-decoration:none;
color: #888888;
}
a:hover {
text-decoration:underline;
color: #ff1900;
}
.body-fauxcolumn-outer .fauxcolumn-inner {
background: transparent none repeat scroll top left;
_background-image: none;
}
.body-fauxcolumn-outer .cap-top {
position: absolute;
z-index: 1;
height: 400px;
width: 100%;
}
.body-fauxcolumn-outer .cap-top .cap-left {
width: 100%;
background: transparent none repeat-x scroll top left;
_background-image: none;
}
.content-outer {
-moz-box-shadow: 0 0 40px rgba(0, 0, 0, .15);
-webkit-box-shadow: 0 0 5px rgba(0, 0, 0, .15);
-goog-ms-box-shadow: 0 0 10px #333333;
box-shadow: 0 0 40px rgba(0, 0, 0, .15);
margin-bottom: 1px;
}
.content-inner {
padding: 10px 10px;
}
.content-inner {
background-color: #fff9ee;
}
/* Header
----------------------------------------------- */
.header-outer {
background: #ccb666 url(https://resources.blogblog.com/blogblog/data/1kt/simple/gradients_light.png) repeat-x scroll 0 -400px;
_background-image: none;
}
.Header h1 {
font: normal normal 48px Georgia, Utopia, 'Palatino Linotype', Palatino, serif;
color: #ffffff;
text-shadow: 1px 2px 3px rgba(0, 0, 0, .2);
}
.Header h1 a {
color: #ffffff;
}
.Header .description {
font-size: 140%;
color: #ffffff;
}
.header-inner .Header .titlewrapper {
padding: 22px 30px;
}
.header-inner .Header .descriptionwrapper {
padding: 0 30px;
}
/* Tabs
----------------------------------------------- */
.tabs-inner .section:first-child {
border-top: 0 solid #eee5dd;
}
.tabs-inner .section:first-child ul {
margin-top: -0;
border-top: 0 solid #eee5dd;
border-left: 0 solid #eee5dd;
border-right: 0 solid #eee5dd;
}
.tabs-inner .widget ul {
background: #fff9ee none repeat-x scroll 0 -800px;
_background-image: none;
border-bottom: 1px solid #eee5dd;
margin-top: 0;
margin-left: -30px;
margin-right: -30px;
}
.tabs-inner .widget li a {
display: inline-block;
padding: .6em 1em;
font: normal normal 16px Georgia, Utopia, 'Palatino Linotype', Palatino, serif;
color: #998877;
border-left: 1px solid #fff9ee;
border-right: 1px solid #eee5dd;
}
.tabs-inner .widget li:first-child a {
border-left: none;
}
.tabs-inner .widget li.selected a, .tabs-inner .widget li a:hover {
color: #000000;
background-color: #fff9ee;
text-decoration: none;
}
/* Columns
----------------------------------------------- */
.main-outer {
border-top: 0 solid #eee5dd;
}
.fauxcolumn-left-outer .fauxcolumn-inner {
border-right: 1px solid #eee5dd;
}
.fauxcolumn-right-outer .fauxcolumn-inner {
border-left: 1px solid #eee5dd;
}
/* Headings
----------------------------------------------- */
div.widget > h2,
div.widget h2.title {
margin: 0 0 1em 0;
font: normal bold 12px Georgia, Utopia, 'Palatino Linotype', Palatino, serif;
color: #000000;
}
/* Widgets
----------------------------------------------- */
.widget .zippy {
color: #999999;
text-shadow: 2px 2px 1px rgba(0, 0, 0, .1);
}
.widget .popular-posts ul {
list-style: none;
}
/* Posts
----------------------------------------------- */
h2.date-header {
font: normal bold 11px Arial, Tahoma, Helvetica, FreeSans, sans-serif;
}
.date-header span {
background-color: transparent;
color: #222222;
padding: inherit;
letter-spacing: inherit;
margin: inherit;
}
.main-inner {
padding-top: 30px;
padding-bottom: 30px;
}
.main-inner .column-center-inner {
padding: 0 15px;
}
.main-inner .column-center-inner .section {
margin: 0 15px;
}
.post {
margin: 0 0 25px 0;
}
h3.post-title, .comments h4 {
font: normal normal 24px Georgia, Utopia, 'Palatino Linotype', Palatino, serif;
margin: .75em 0 0;
}
.post-body {
font-size: 110%;
line-height: 1.4;
position: relative;
}
.post-body img, .post-body .tr-caption-container, .Profile img, .Image img,
.BlogList .item-thumbnail img {
padding: 2px;
background: #ffffff;
border: 1px solid #eeeeee;
-moz-box-shadow: 1px 1px 5px rgba(0, 0, 0, .1);
-webkit-box-shadow: 1px 1px 5px rgba(0, 0, 0, .1);
box-shadow: 1px 1px 5px rgba(0, 0, 0, .1);
}
.post-body img, .post-body .tr-caption-container {
padding: 5px;
}
.post-body .tr-caption-container {
color: #222222;
}
.post-body .tr-caption-container img {
padding: 0;
background: transparent;
border: none;
-moz-box-shadow: 0 0 0 rgba(0, 0, 0, .1);
-webkit-box-shadow: 0 0 0 rgba(0, 0, 0, .1);
box-shadow: 0 0 0 rgba(0, 0, 0, .1);
}
.post-header {
margin: 0 0 1.5em;
line-height: 1.6;
font-size: 90%;
}
.post-footer {
margin: 20px -2px 0;
padding: 5px 10px;
color: #666555;
background-color: #eee9dd;
border-bottom: 1px solid #eeeeee;
line-height: 1.6;
font-size: 90%;
}
#comments .comment-author {
padding-top: 1.5em;
border-top: 1px solid #eee5dd;
background-position: 0 1.5em;
}
#comments .comment-author:first-child {
padding-top: 0;
border-top: none;
}
.avatar-image-container {
margin: .2em 0 0;
}
#comments .avatar-image-container img {
border: 1px solid #eeeeee;
}
/* Comments
----------------------------------------------- */
.comments .comments-content .icon.blog-author {
background-repeat: no-repeat;
background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASCAYAAABWzo5XAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEgAACxIB0t1+/AAAAAd0SU1FB9sLFwMeCjjhcOMAAAD+SURBVDjLtZSvTgNBEIe/WRRnm3U8RC1neQdsm1zSBIU9VVF1FkUguQQsD9ITmD7ECZIJSE4OZo9stoVjC/zc7ky+zH9hXwVwDpTAWWLrgS3QAe8AZgaAJI5zYAmc8r0G4AHYHQKVwII8PZrZFsBFkeRCABYiMh9BRUhnSkPTNCtVXYXURi1FpBDgArj8QU1eVXUzfnjv7yP7kwu1mYrkWlU33vs1QNu2qU8pwN0UpKoqokjWwCztrMuBhEhmh8bD5UDqur75asbcX0BGUB9/HAMB+r32hznJgXy2v0sGLBcyAJ1EK3LFcbo1s91JeLwAbwGYu7TP/3ZGfnXYPgAVNngtqatUNgAAAABJRU5ErkJggg==);
}
.comments .comments-content .loadmore a {
border-top: 1px solid #999999;
border-bottom: 1px solid #999999;
}
.comments .comment-thread.inline-thread {
background-color: #eee9dd;
}
.comments .continue {
border-top: 2px solid #999999;
}
/* Accents
---------------------------------------------- */
.section-columns td.columns-cell {
border-left: 1px solid #eee5dd;
}
.blog-pager {
background: transparent none no-repeat scroll top center;
}
.blog-pager-older-link, .home-link,
.blog-pager-newer-link {
background-color: #fff9ee;
padding: 5px;
}
.footer-outer {
border-top: 0 dashed #bbbbbb;
}
/* Mobile
----------------------------------------------- */
body.mobile  {
background-size: auto;
}
.mobile .body-fauxcolumn-outer {
background: transparent none repeat scroll top left;
}
.mobile .body-fauxcolumn-outer .cap-top {
background-size: 100% auto;
}
.mobile .content-outer {
-webkit-box-shadow: 0 0 3px rgba(0, 0, 0, .15);
box-shadow: 0 0 3px rgba(0, 0, 0, .15);
}
.mobile .tabs-inner .widget ul {
margin-left: 0;
margin-right: 0;
}
.mobile .post {
margin: 0;
}
.mobile .main-inner .column-center-inner .section {
margin: 0;
}
.mobile .date-header span {
padding: 0.1em 10px;
margin: 0 -10px;
}
.mobile h3.post-title {
margin: 0;
}
.mobile .blog-pager {
background: transparent none no-repeat scroll top center;
}
.mobile .footer-outer {
border-top: none;
}
.mobile .main-inner, .mobile .footer-inner {
background-color: #fff9ee;
}
.mobile-index-contents {
color: #222222;
}
.mobile-link-button {
background-color: #993300;
}
.mobile-link-button a:link, .mobile-link-button a:visited {
color: #ffffff;
}
.mobile .tabs-inner .section:first-child {
border-top: none;
}
.mobile .tabs-inner .PageList .widget-content {
background-color: #fff9ee;
color: #000000;
border-top: 1px solid #eee5dd;
border-bottom: 1px solid #eee5dd;
}
.mobile .tabs-inner .PageList .widget-content .pagelist-arrow {
border-left: 1px solid #eee5dd;
}

--></style>
<style id='template-skin-1' type='text/css'><!--
body {
min-width: 960px;
}
.content-outer, .content-fauxcolumn-outer, .region-inner {
min-width: 960px;
max-width: 960px;
_width: 960px;
}
.main-inner .columns {
padding-left: 0;
padding-right: 310px;
}
.main-inner .fauxcolumn-center-outer {
left: 0;
right: 310px;
/* IE6 does not respect left and right together */
_width: expression(this.parentNode.offsetWidth -
parseInt("0") -
parseInt("310px") + 'px');
}
.main-inner .fauxcolumn-left-outer {
width: 0;
}
.main-inner .fauxcolumn-right-outer {
width: 310px;
}
.main-inner .column-left-outer {
width: 0;
right: 100%;
margin-left: -0;
}
.main-inner .column-right-outer {
width: 310px;
margin-right: -310px;
}
#layout {
min-width: 0;
}
#layout .content-outer {
min-width: 0;
width: 800px;
}
#layout .region-inner {
min-width: 0;
width: auto;
}
body#layout div.add_widget {
padding: 8px;
}
body#layout div.add_widget a {
margin-left: 32px;
}
--></style>
<style>
    body {background-image:url(\/\/themes.googleusercontent.com\/image?id=1KH22PlFqsiVYxboQNAoJjYmRbw5M4REHmdJbHT5M2x9zVMGrCqwSjZvaQW_A10KPc6Il);}
    
@media (max-width: 200px) { body {background-image:url(\/\/themes.googleusercontent.com\/image?id=1KH22PlFqsiVYxboQNAoJjYmRbw5M4REHmdJbHT5M2x9zVMGrCqwSjZvaQW_A10KPc6Il&options=w200);}}
@media (max-width: 400px) and (min-width: 201px) { body {background-image:url(\/\/themes.googleusercontent.com\/image?id=1KH22PlFqsiVYxboQNAoJjYmRbw5M4REHmdJbHT5M2x9zVMGrCqwSjZvaQW_A10KPc6Il&options=w400);}}
@media (max-width: 800px) and (min-width: 401px) { body {background-image:url(\/\/themes.googleusercontent.com\/image?id=1KH22PlFqsiVYxboQNAoJjYmRbw5M4REHmdJbHT5M2x9zVMGrCqwSjZvaQW_A10KPc6Il&options=w800);}}
@media (max-width: 1200px) and (min-width: 801px) { body {background-image:url(\/\/themes.googleusercontent.com\/image?id=1KH22PlFqsiVYxboQNAoJjYmRbw5M4REHmdJbHT5M2x9zVMGrCqwSjZvaQW_A10KPc6Il&options=w1200);}}
/* Last tag covers anything over one higher than the previous max-size cap. */
@media (min-width: 1201px) { body {background-image:url(\/\/themes.googleusercontent.com\/image?id=1KH22PlFqsiVYxboQNAoJjYmRbw5M4REHmdJbHT5M2x9zVMGrCqwSjZvaQW_A10KPc6Il&options=w1600);}}
  </style>
<link href='https://www.blogger.com/dyn-css/authorization.css?targetBlogID=7134852494570757091&amp;zx=d7dc0e22-c739-41c5-9225-8b4d5599ecd8' media='none' onload='if(media!=&#39;all&#39;)media=&#39;all&#39;' rel='stylesheet'/><noscript><link href='https://www.blogger.com/dyn-css/authorization.css?targetBlogID=7134852494570757091&amp;zx=d7dc0e22-c739-41c5-9225-8b4d5599ecd8' rel='stylesheet'/></noscript>
<meta name='google-adsense-platform-account' content='ca-host-pub-1556223355139109'/>
<meta name='google-adsense-platform-domain' content='blogspot.com'/>

</head>
<body class='loading variant-literate'>
<div class='navbar section' id='navbar' name='Navbar'><div class='widget Navbar' data-version='1' id='Navbar1'><script type="text/javascript">
    function setAttributeOnload(object, attribute, val) {
      if(window.addEventListener) {
        window.addEventListener('load',
          function(){ object[attribute] = val; }, false);
      } else {
        window.attachEvent('onload', function(){ object[attribute] = val; });
      }
    }
  </script>
<div id="navbar-iframe-container"></div>
<script type="text/javascript" src="https://apis.google.com/js/platform.js"></script>
<script type="text/javascript">
      gapi.load("gapi.iframes:gapi.iframes.style.bubble", function() {
        if (gapi.iframes && gapi.iframes.getContext) {
          gapi.iframes.getContext().openChild({
              url: 'https://www.blogger.com/navbar/7134852494570757091?origin\x3dhttps://testtesting10101010.blogspot.com',
              where: document.getElementById("navbar-iframe-container"),
              id: "navbar-iframe"
          });
        }
      });
    </script><script type="text/javascript">
(function() {
var script = document.createElement('script');
script.type = 'text/javascript';
script.src = '//pagead2.googlesyndication.com/pagead/js/google_top_exp.js';
var head = document.getElementsByTagName('head')[0];
if (head) {
head.appendChild(script);
}})();
</script>
</div></div>
<div itemscope='itemscope' itemtype='http://schema.org/Blog' style='display: none;'>
<meta content='test' itemprop='name'/>
</div>
<div class='body-fauxcolumns'>
<div class='fauxcolumn-outer body-fauxcolumn-outer'>
<div class='cap-top'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
<div class='fauxborder-left'>
<div class='fauxborder-right'></div>
<div class='fauxcolumn-inner'>
</div>
</div>
<div class='cap-bottom'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
</div>
</div>
<div class='content'>
<div class='content-fauxcolumns'>
<div class='fauxcolumn-outer content-fauxcolumn-outer'>
<div class='cap-top'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
<div class='fauxborder-left'>
<div class='fauxborder-right'></div>
<div class='fauxcolumn-inner'>
</div>
</div>
<div class='cap-bottom'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
</div>
</div>
<div class='content-outer'>
<div class='content-cap-top cap-top'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
<div class='fauxborder-left content-fauxborder-left'>
<div class='fauxborder-right content-fauxborder-right'></div>
<div class='content-inner'>
<header>
<div class='header-outer'>
<div class='header-cap-top cap-top'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
<div class='fauxborder-left header-fauxborder-left'>
<div class='fauxborder-right header-fauxborder-right'></div>
<div class='region-inner header-inner'>
<div class='header section' id='header' name='Header'><div class='widget Header' data-version='1' id='Header1'>
<div id='header-inner'>
<div class='titlewrapper'>
<h1 class='title'>
test
</h1>
</div>
<div class='descriptionwrapper'>
<p class='description'><span>
</span></p>
</div>
</div>
</div></div>
</div>
</div>
<div class='header-cap-bottom cap-bottom'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
</div>
</header>
<div class='tabs-outer'>
<div class='tabs-cap-top cap-top'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
<div class='fauxborder-left tabs-fauxborder-left'>
<div class='fauxborder-right tabs-fauxborder-right'></div>
<div class='region-inner tabs-inner'>
<div class='tabs section' id='crosscol' name='Cross-column'><div class='widget HTML' data-version='1' id='HTML1'>
<div class='widget-content'>
<!doctype html>








   
    <style>


        /* Add your CSS styles here */


/* Modal container styling */
.modal-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start; /* Align items to the top */
    max-width: 800px; /* Limit width for readability */
    padding: 20px;
    border: 1px solid #ccc;
    border-radius: 10px;
    background-color: #f9f9f9;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); /* Subtle shadow */
    margin: 0 auto;
    gap: 20px; /* Add space between elements */
}

/* Styling for the paragraph */
.modal-container p {
    font-size: 18px;
    color: #333;
    margin-bottom: 10px; /* Space below the paragraph */
}

/* Styling for the select dropdown */
#editCategorySelect {
    font-size: 16px;
    padding: 12px 20px;
    margin-bottom: 20px; /* Space below the select */
    border-radius: 8px;
    border: 2px solid #ccc;
    background-color: #f9f9f9;
    width: 100%; /* Make the dropdown fill the container width */
    max-width: 300px; /* Limit the width of the dropdown */
    cursor: pointer;
}

/* Button styling */
button {
    font-size: 16px;
    padding: 12px 20px;
    border-radius: 8px;
    border: 2px solid #ccc;
    background-color: #f0f0f0;
    color: #333;
    cursor: pointer;
    margin: 10px 0; /* Space between buttons */
    transition: background-color 0.3s ease, transform 0.3s ease;
}

button:hover {
    background-color: #e0e0e0;
    transform: scale(1.05); /* Slightly enlarge on hover */
}

/* Specific styles for the Save and Add New Category buttons */
#saveEditedCategoryBtn {
    background-color: #4CAF50; /* Green for Save button */
    color: white;
}

#addNewCategoryBtn {
    background-color: #008CBA; /* Blue for Add New button */
    color: white;
}

#saveEditedCategoryBtn:hover {
    background-color: #45a049; /* Darker green on hover */
}

#addNewCategoryBtn:hover {
    background-color: #007bb5; /* Darker blue on hover */
}











#showModal {
    font-size: 16px; /* Adjust font size */
    padding: 12px 20px; /* Adjust button size with padding */
    border-radius: 8px; /* Rounded corners */
    border: 2px solid #ccc; /* Border style */
    background-color: #f0f0f0; /* Light background */
    color: #333; /* Text color */
    cursor: pointer; /* Pointer on hover */
    margin: 10px 0; /* Spacing around the button */
    transition: background-color 0.3s ease, transform 0.3s ease; /* Smooth transition */
}

#showModal:hover {
    background-color: #e0e0e0; /* Change background on hover */
    transform: scale(1.05); /* Slightly enlarge on hover */
}



#setReminder {
    font-size: 16px; /* Adjust font size */
    padding: 12px 20px; /* Adjust button size with padding */
    border-radius: 8px; /* Rounded corners */
    border: 2px solid #ccc; /* Border style */
    background-color: #f0f0f0; /* Light background */
    color: #333; /* Text color */
    cursor: pointer; /* Pointer on hover */
    margin: 10px 0; /* Spacing around the button */
    transition: background-color 0.3s ease, transform 0.3s ease; /* Smooth transition */
}

#setReminder:hover {
    background-color: #e0e0e0; /* Change background on hover */
    transform: scale(1.05); /* Slightly enlarge on hover */
}



#shareCompletedTasks, #clearCompleted {
    font-size: 16px; /* Adjust font size */
    padding: 12px 20px; /* Adjust button size with padding */
    border-radius: 8px; /* Rounded corners */
    border: 2px solid #ccc; /* Border style */
    background-color: #f0f0f0; /* Light background */
    color: #333; /* Text color */
    cursor: pointer; /* Pointer on hover */
    margin: 10px 0; /* Spacing between buttons */
    transition: background-color 0.3s ease, transform 0.3s ease; /* Smooth transition */
}

#shareCompletedTasks:hover, #clearCompleted:hover {
    background-color: #e0e0e0; /* Change background on hover */
    transform: scale(1.05); /* Slightly enlarge on hover */
}


#viewAllTasks, #viewUrgentTasks {
    font-size: 16px; /* Adjust font size */
    padding: 12px 20px; /* Adjust button size with padding */
    border-radius: 8px; /* Rounded corners */
    border: 2px solid #ccc; /* Border style */
    background-color: #f0f0f0; /* Light background */
    color: #333; /* Text color */
    cursor: pointer; /* Pointer on hover */
    margin: 10px 0; /* Spacing between buttons */
    transition: background-color 0.3s ease, transform 0.3s ease; /* Smooth transition */
}

#viewAllTasks:hover, #viewUrgentTasks:hover {
    background-color: #e0e0e0; /* Change background on hover */
    transform: scale(1.05); /* Slightly enlarge on hover */
}


  #clock {
    font-size: 24px;
    font-family: Arial, sans-serif;
    padding: 10px;
    border: 1px solid #ccc;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    background-color: #f9f9f9;
    width: 3in;
    position: absolute;
    top: 10;
    left: 0;
    right: 0;
    bottom: 10;
    display: flex;
    justify-content: center;
    align-items: center;
    margin: auto; /* Ensures it's centered within the parent container */
    cursor: grab;
}



#shareSelectedTasks {
    padding: 12px 24px;
    font-size: 18px;
    position: absolute; /* Enable manual positioning */
    left: 1000px;       /* Adjust this value to move left or right */
    top: 570px;         /* Adjust this value to move up or down */
}


#pasteTasks {
    padding: 12px 24px;
    font-size: 18px;
    position: absolute;    /* Enable manual positioning */
    left: 50px;           /* Adjust this value to move left or right */

}









  /* Style for the message board container */
  .message-board {
    display: flex;
    align-items: center;
    justify-content: flex-start;
    width: 70%;
    height: 40px;
    background-color: #FFF;
    color: #000;
    font-size: 18px;
    white-space: nowrap;
    overflow: hidden;
    border: 2px solid #ccc;
    border-radius: 5px;
    cursor: pointer;
    padding: 5px;
    position: relative;
  }

  /* Marquee effect */
  .message-board span {
    display: inline-block;
    padding-left: 100%;
    white-space: nowrap;
    animation: marquee linear infinite;
  }

  @keyframes marquee {
    0% { transform: translateX(0); }
    100% { transform: translateX(-100%); }
  }







#setReminder.move-down {
    top: 40px; /* Move down */
}

/* Hover effect */
#setReminder:hover {
    background-color: #0056b3;
    box-shadow: 0 0 10px rgba(0, 123, 255, 0.5);
}




/* Style the completion checkbox */
input[type="checkbox"] {
    width: 18px; /* Set the width */
    height: 18px; /* Set the height */
    cursor: pointer; /* Show pointer cursor on hover */
    appearance: none; /* Remove default checkbox style */
    background-color: #fff; /* Background color */
    border: 2px solid #ccc; /* Border style */
    border-radius: 5px; /* Optional: Rounded corners */
    transition: all 0.3s ease; /* Smooth hover effect */
}

/* Style the checkbox when checked */
input[type="checkbox"]:checked {
    background-color: #0071c5; /* Green background when checked */
    border-color: #4CAF50;
    box-shadow: 0 0 10px rgba(76, 175, 80, 0.6); /* Glow effect */
}

/* Hover effect */
input[type="checkbox"]:hover {
    border-color: #007bff; /* Border color on hover */
    box-shadow: 0 0 5px rgba(0, 123, 255, 0.5); /* Subtle glow */
}






/* Style the select element */
.priority-select {
    width: 70%; /* Make it take full width of the column */
    padding: 3px;
    font-size: 24px;
    border: 1px solid #ccc;
    border-radius: 30%; /* Makes the dropdown circular */
    background-color: #fff;
    transition: background-color 0.3s ease, border 0.3s ease;
    cursor: pointer;
}




/* Style the highlight selector to be circular */
.highlight-select {
    width: 60px;                      /* Set width */
    height: 60px;                     /* Set height */
    border: 2px solid #ccc;           /* Add border to make it visible */
    border-radius: 50%;               /* Make it circular */
    cursor: pointer;
    text-align: center;
    padding: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    font-size: 24px;                  /* Make the emojis bigger */
}

/* Style the dropdown options */
.highlight-select option {
    font-size: 24px;                  /* Larger font size for emojis */
    padding: 10px;
    text-align: center;               /* Center the emoji */
    height: auto;                     /* Let height adjust based on content */
    width: 100%;
    background-color: #fff;
    color: #333;
    border-radius: 5px;
    box-sizing: border-box;
    display: flex;
    justify-content: center;
    align-items: center;
}

/* Prevent hover effect on dropdown options */
.highlight-select option:hover {
    background-color: transparent !important;
    color: inherit !important;
}




/* Styling for the completed task list container */
#completedList {
    list-style-type: none;
    padding: 20px;
    margin: 0;
    background-color: #f2f2f2;
    border-radius: 10px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    max-width: 800px;
    margin: auto;
}

/* Task items styling */
#completedList .task {
    background-color: #ffffff;
    margin: 10px 0;
    padding: 15px;
    border-radius: 8px;
    font-family: 'Arial', sans-serif;
    font-size: 16px;
    line-height: 1.6;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
    transition: transform 0.3s ease, box-shadow 0.3s ease;
}

/* Hover effect for task items */
#completedList .task:hover {
    transform: translateY(-5px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}

/* Styling for urgent tasks */
#completedList .task.urgent {
    background-color: #ff6347;
    color: white;
    font-weight: bold;
}

/* Deadline and extra information styling */
#completedList .task span {
    font-size: 14px;
    color: #888;
    display: block;
    margin-top: 8px;
}

/* Horizontal line styling after each task */
#completedList hr {
    border: 0;
    border-top: 1px solid #ddd;
    margin: 10px 0;
}

/* Smooth animation for the list when items are added */
@keyframes fadeIn {
    from {
        opacity: 0;
    }
    to {
        opacity: 1;
    }
}

/* Apply the fadeIn effect */
#completedList .task {
    animation: fadeIn 0.5s ease-in-out;
}










/* Display Task */
.list-item {
    display: block;
    width: 100%;
    transition: all 0.3s ease-in-out; /* Smooth transition for hover effect */
}

/* The first row that contains only infoColumn */
.info-row {
    display: block; /* This ensures the infoColumn takes full width */
    margin-top: 40px; /* Adjust spacing between tasks here */
    width: 100%; /* Ensures it takes the full width of the list-item */
    padding: 10px;
    background-color: #f9f9f9; /* Subtle background color */
    border-bottom: 1px solid #ccc;
        border-radius: 8px; /* Rounded corners for a soft look */
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); /* Soft shadow */
    transition: all 0.3s ease; /* Smooth hover effect */
}

.info-row:hover {
    background-color: #e6e6e6; /* Slight color change on hover */
    transform: translateY(-5px); /* Slightly lift up the row on hover */
    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.15); /* Enhanced shadow on hover */
}

/* The second row for other columns (grid layout) */
.details-row {
    display: grid; /* Grid for the remaining columns */
    grid-template-columns: repeat(10, 1fr); /* Adjust based on the number of columns in the second row */
    gap: 0px;
  font-size: 16px; /* Set your desired font size */
    padding: 10px 0;
    width: 100%;
}

/* Optional: Style individual columns */
.column {
    display: flex;
    justify-content: center; /* Center the content horizontally */
    align-items: center; /* Center content vertically */
    transition: all 0.3s ease-in-out; /* Smooth hover effect */
    padding: 10px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); /* Subtle shadow */
}

.column:hover {
    background-color: #e0f7fa; /* Change background on hover */
    transform: scale(1.05); /* Slightly enlarge on hover */
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15); /* Enhance shadow */
}

/* Add cool hover effect for the entire list item */
.list-item:hover {
    background-color: #f0f0f0; /* Subtle background change */
    transform: translateY(-10px); /* Lift the entire list item */
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1); /* Enhanced shadow effect */
}

/* Add a pulse effect to make items stand out */
.list-item:active {
    animation: pulse 0.5s ease-in-out; /* Cool pulse effect on click */
}

@keyframes pulse {
    0% {
        transform: scale(1);
    }
    50% {
        transform: scale(1.05);
    }
    100% {
        transform: scale(1);
    }
}

/* Add a smooth fading effect when the item is added or removed */
.list-item {
    opacity: 0;
    animation: fadeIn 0.5s forwards; /* Fade-in effect */
}

@keyframes fadeIn {
    0% {
        opacity: 0;
    }
    100% {
        opacity: 1;
    }
}

/* Add a glowing effect for interactive items */
.column:active {
    box-shadow: 0 0 10px 5px rgba(0, 255, 255, 0.5); /* Glowing effect on click */
}



/* Style for the notebook icon */
.notebook-icon {
    cursor: pointer;
    font-size: 24px;
    margin-left: 10px;
    color: blue;
}

/* Style for the note popup */
.note-popup {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 40%;
    max-width: 90%; /* Ensures it fits on smaller screens */
    background: white;
    border: 1px solid #ccc;
    padding: 20px;
    z-index: 1000;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
}

/* Style for the close button (X) */
.close-button {
    position: absolute;
    top: 10px;
    right: 10px;
    font-size: 24px;
    cursor: pointer;
    color: red;
}

/* Style for the textarea inside the popup */
.note-popup textarea {
    width: 100%;
    height: 150px;
    margin-top: 20px;
}

/* Optional: Add some styling for the notes column */
.notes-column {
    display: flex;
    align-items: center;
}




#displayTasks {
        width: 120px; /* Adjust width */
        height: 120px; /* Adjust height */
        border-radius: 50%; /* Makes the button circular */
        background-color: #F0F0F0; /* Background color (adjust as needed) */
        color: black; /* Text color */
        border: none; /* Remove default border */
        font-size: 92px; /* Font size */
        font-weight: bold; /* Font weight */
        text-align: center; /* Center text horizontally */
        line-height: 60px; /* Center text vertically */
        cursor: pointer; /* Change cursor to pointer on hover */
        position: absolute; /* Allows positioning */
        z-index: 1000; /* Ensure it's above other elements */
        transition: background-color 0.3s, transform 0.3s; /* Smooth transition for hover effect */
    }


    /* Hover effect */
    #displayTasks:hover {
        background-color: #FFFFFF; /* Darker background color on hover */
        transform: scale(1.1); /* Slightly increase size on hover */
    }

    /* Position the button */
    /* You can change top, right, bottom, and left values to reposition the button */
    #displayTasks {
        top: 100px; /* Distance from the top of the viewport */
        right: -20px; /* Distance from the right of the viewport */
    }
   
    /* General modal styles */
    .modal {
        display: none; /* Hidden by default */
        position: fixed; /* Stay in place */
        z-index: 1; /* Sit on top */
        left: 0;
        top: 0;
        width: 40vw; /* Full viewport width */
        height: 10vh; /* Full viewport height */
        overflow: hidden; /* Prevent scrolling in the modal */
        background-color: rgba(0,0,0,0.4); /* Black background with opacity */
    }

    .modal-content {
        background-color: #fefefe;
        margin: 0 auto; /* Center horizontally */
        padding: 0;
        border: 1px solid #888;
        width: 90vw; /* 90% of viewport width */
        height: 68vh; /* 90% of viewport height */
        overflow: hidden; /* Hide overflow to avoid scrollbars on modal */
        display: flex; /* Flexbox for center alignment */
        align-items: center; /* Center content vertically */
        justify-content: center; /* Center content horizontally */
    }

    #tasksIframe {
        width: 150%;
        height: 100%;
        border: none;
        overflow: auto; /* Allow iframe content to be scrollable */
    }

    .close {
        color: white; /* White color for better contrast */
        font-size: 36px; /* Larger font size */
        font-weight: bold;
        cursor: pointer;
        padding: 10px;
        background-color: #F0F0F0; /* Dark background for visibility */
        border-radius: 50%; /* Circular button */
        position: absolute; /* Position it in the top-right corner */
        top: 10px;
        right: 10px;
        transition: background-color 0.3s, color 0.3s; /* Smooth transition effect */
    }

    .close:hover,
    .close:focus {
        color: #F0F0F0; /* Change color on hover for visibility */
        background-color: rgba(255,255,255,0.5); /* Lighter background on hover */
        text-decoration: none;
    }






/* Save Edited Category Button Hover Effect */
button#saveEditedCategory:hover {
    background-color: #000000; /* Darker blue on hover */
}

/* Save Edited Category Button Focus Effect */
button#saveEditedCategory:focus {
    outline: none; /* Remove default outline */
    box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.5); /* Outline effect for accessibility */
}

/* Save New Category Button Styles */
button#saveNewCategory {
    background-color: #000000; /* Green background color */
    color: white; /* White text color */
    border: none; /* Remove default border */
    border-radius: 4px; /* Rounded corners */
    padding: 10px 20px; /* Padding inside the button */
    font-size: 16px; /* Font size */
    cursor: pointer; /* Pointer cursor on hover */
    box-shadow: 0 2px 4px rgba(0,0,0,0.2); /* Subtle shadow */
    transition: background-color 0.3s, box-shadow 0.3s; /* Smooth transition */
}

/* Save New Category Button Hover Effect */
button#saveNewCategory:hover {
    background-color: #000000; /* Darker green on hover */
}

/* Save New Category Button Focus Effect */
button#saveNewCategory:focus {
    outline: none; /* Remove default outline */
    box-shadow: 0 0 0 3px rgba(40, 167, 69, 0.5); /* Outline effect for accessibility */
}


/* Confirm Paste Button Styles */
button#confirmPaste {
    background-color: #000000; /* Green background color */
    color: white; /* White text color */
    border: none; /* Remove default border */
    border-radius: 4px; /* Rounded corners */
    padding: 10px 20px; /* Padding inside the button */
    font-size: 16px; /* Font size */
    cursor: pointer; /* Pointer cursor on hover */
    box-shadow: 0 2px 4px rgba(0,0,0,0.2); /* Subtle shadow */
    transition: background-color 0.3s, box-shadow 0.3s; /* Smooth transition */
}

/* Confirm Paste Button Hover Effect */
button#confirmPaste:hover {
    background-color: #000000; /* Darker green on hover */
}

/* Confirm Paste Button Focus Effect */
button#confirmPaste:focus {
    outline: none; /* Remove default outline */
    box-shadow: 0 0 0 3px rgba(40, 167, 69, 0.5); /* Outline effect for accessibility */
}



/* Modal Window Styles */
.modal {
    display: none; /* Hidden by default */
    position: fixed; /* Stay in place */
    z-index: 1; /* Sit on top */
    left: 0;
    top: 0;
    width: 100%; /* Full width */
    height: 100%; /* Full height */
    overflow: auto; /* Enable scroll if needed */
    background-color: rgba(0,0,0,0.4); /* Black background with opacity */
}

/* Modal Content Styles */
.modal-content {
    background-color: #fefefe; /* White background */
    margin: 10% auto; /* 10% from the top and center horizontally */
    padding: 20px;
    border: 1px solid #888; /* Border color */
    width: 80%; /* Width of the modal */
    max-width: 600px; /* Maximum width */
    border-radius: 8px; /* Rounded corners */
    box-shadow: 0 4px 8px rgba(0,0,0,0.2); /* Shadow for depth */
}

/* Modal Title */
.modal-content h2 {
    margin-top: 0; /* Remove top margin */
    font-size: 24px; /* Title font size */
    color: #333; /* Dark gray color for text */
}

/* Textarea Styles */
textarea#pastedTasks {
    width: 100%; /* Full width */
    height: 150px; /* Height of the textarea */
    padding: 10px; /* Padding inside textarea */
    font-size: 16px; /* Font size */
    border: 1px solid #ccc; /* Border color */
    border-radius: 4px; /* Rounded corners */
    box-sizing: border-box; /* Include padding and border in width/height */
    resize: vertical; /* Allow vertical resizing only */
    margin-bottom: 20px; /* Space below textarea */
}

/* Button Styles inside Modal */
.modal-content button {
    width: 100%; /* Full width */
    max-width: 150px; /* Maximum width of the button */
    height: 45px; /* Height of the button */
    padding: 0 15px; /* Padding inside the button */
    font-size: 16px; /* Font size */
    border: 1px; /* Remove default border */
    border-radius: 4px; /* Rounded corners */
    background-color: #FFFFFF; /* Background color */
    color: black; /* Text color */
    cursor: pointer; /* Pointer cursor on hover */
    box-shadow: 0 2px 4px rgba(0,0,0,0.1); /* Subtle shadow */
    transition: background-color 0.3s, box-shadow 0.3s; /* Smooth transition */
    margin-top: 10px; /* Space above the button */
    text-align: center; /* Center text inside the button */
}

/* Button Hover Effects */
.modal-content button:hover {
    background-color: #FFFFFF; /* Darker background color on hover */
}

/* Close Button Styles */
.close {
    color: #FFFFFF; /* Light gray color */
    float: right; /* Float right */
    font-size: 28px; /* Font size */
    font-weight: bold; /* Bold text */
}

.close:hover,
.close:focus {
    color: black; /* Change color on hover/focus */
    text-decoration: none; /* Remove underline */
    cursor: pointer; /* Pointer cursor */
}



/* Modal Window Styles */
.modal {
    display: none; /* Hidden by default */
    position: fixed; /* Stay in place */
    z-index: 1; /* Sit on top */
    left: 0;
    top: 0;
    width: 100%; /* Full width */
    height: 100%; /* Full height */
    overflow: auto; /* Enable scroll if needed */
    background-color: rgba(0,0,0,0.4); /* Black background with opacity */
}

/* Modal Content Styles */
.modal-content {
    background-color: #FFFFFF; /* White background */
    margin: 15% auto; /* 15% from the top and center horizontally */
    padding: 20px;
    border: 1px solid #888; /* Border color */
    width: 80%; /* Width of the modal */
    max-width: 500px; /* Maximum width */
    border-radius: 8px; /* Rounded corners */
}

/* Button Styles inside Modal */
.modal-content button {
    width: 100%; /* Full width */
    max-width: 150px; /* Maximum width of the button */
    height: 45px; /* Height of the button */
    padding: 0 15px; /* Padding inside the button */
    font-size: 16px; /* Font size */
    border: 1px solid black; /* Remove default border */
    border-radius: 4px; /* Rounded corners */
    background-color: #FFFFFF; /* Background color */
    color: white; /* Text color */
    cursor: pointer; /* Pointer cursor on hover */
    box-shadow: #000000; /* Subtle shadow */
    transition: background-color 0.3s, box-shadow 0.3s; /* Smooth transition */
    margin: 5px 0; /* Space between buttons */
    text-align: center; /* Center text inside the button */
}

/* Button Background Colors */
#addCategory {
    background-color: #FFFFFF; /* Green for Add */
}

#editCategory {
    background-color: #FFFFFF; /* Yellow for Edit */
}

#deleteCategory {
    background-color: #FFFFFF; /* Red for Delete */
}

/* Button Hover Effects */
.modal-content button:hover {
    background-color: #FFFFFF; /* Darker background color on hover */
}

/* Close Button Styles */
.close {
    color: #aaa; /* Light gray color */
    float: right; /* Float right */
    font-size: 28px; /* Font size */
    font-weight: bold; /* Bold text */
}

.close:hover,
.close:focus {
    color: black; /* Change color on hover/focus */
    text-decoration: none; /* Remove underline */
    cursor: pointer; /* Pointer cursor */
}



/* Style for the main button */
#showModal {
    width: 100%; /* Adjust width to fit the container */
    max-width: 200px; /* Maximum width of the button */
    height: 45px; /* Height of the button */
    padding: 0 20px; /* Padding inside the button */
    font-size: 16px; /* Font size of the text inside the button */
    border: none; /* Remove default border */
    border-radius: 4px; /* Rounded corners */
    background-color: FFFFFF; /* Background color */
    color: black; /* Text color */
    cursor: pointer; /* Pointer cursor on hover */
    box-shadow: 0 2px 4px rgba(0,0,0,0.1); /* Subtle shadow */
    transition: background-color 0.3s, box-shadow 0.3s; /* Smooth transition for background color and shadow */
    margin-bottom: 10px; /* Space below the button */
    text-align: center; /* Center text inside the button */
}

/* Style for the button on hover */
#showModal:hover {
    background-color: FFFFFF; /* Darker background color on hover */
}

/* Style for the button on focus */
#showModal:focus {
    outline: none; /* Remove default outline */
    box-shadow: FFFFFF; /* Add custom focus ring */
}


/* Style for the sort select dropdown */
#sortSelect {
    width: 100%; /* Adjust width to fit the container */
    max-width: 400px; /* Maximum width of the dropdown */
    height: 40px; /* Height of the dropdown */
    padding: 0 10px; /* Padding inside the dropdown */
    font-size: 16px; /* Font size of the text inside the dropdown */
    border: 1px solid #ccc; /* Border color and style */
    border-radius: 4px; /* Rounded corners */
    box-shadow: 0 2px 4px rgba(0,0,0,0.1); /* Subtle shadow */
    transition: border-color 0.3s; /* Smooth transition for border color */
    margin-bottom: 10px; /* Space below the dropdown */
}

/* Style for the sort select dropdown on focus */
#sortSelect:focus {
    border-color: #007bff; /* Border color when focused */
    outline: none; /* Remove default outline */
}

/* Style for the label "Select All" */
label[for="selectAllTasks"] {
    display: inline-block;
    padding: 10px 10px;
    background-color: FFFFFF; /* Background color for the button appearance */
    color: black; /* Text color */
    font-size: 16px;
    border-radius: 2px;
    border: none; /* Remove default border */
    cursor: pointer; /* Change cursor to pointer to indicate clickable item */
    text-align: center; /* Center text inside the button */
    margin: 2px; /* Space around the button */
    user-select: none; /* Prevent text selection */
    transition: background-color 0.3s; /* Smooth transition for background color on hover */
}

/* Style for the label on hover */
label[for="selectAllTasks"]:hover {
    background-color: FFFFFF; /* Darker background color on hover */
}


/* Style for the "Add Task" button */
#addTask {
    width: 250px; /* Set width to a fixed size */
    height: 120px; /* Set height to the same size as width for a circular shape */
    padding: 0; /* Remove padding to keep the circle shape */
    margin: 10px 0; /* Space above and below the button */
    border-radius: 50%; /* Make the button circular */
    border: none; /* Black border */
    background-color: FFFFFF; /* Background color */
    color: black; /* Text color */
    font-size: 78px; /* Font size */
    cursor: pointer; /* Pointer cursor on hover */
    text-align: center; /* Center the text */
    line-height: 60px; /* Center text vertically */
    display: flex; /* Flexbox for centering text horizontally */
    align-items: center; /* Center text vertically with Flexbox */
    justify-content: center; /* Center text horizontally with Flexbox */
    font-weight: none; /* Optional: Make the text bold */
}

/* Change background color on hover for the "Add Task" button */
#addTask:hover {
    background-color: FFFFFF; /* Darker green on hover */
}

/* Style for the task entry container */
.task-entry {
    display: flex; /* Use flexbox for horizontal alignment */
    align-items: center; /* Center align items vertically */
    gap: 15px; /* Space between each element */
    margin: 10px 0; /* Space around the container */
}





/* Style for the new task input field */
#newTask {
    width: 100%; /* Adjust width to fit the container */
    max-width: 630px; /* Maximum width of the input field */
    height: 40px; /* Height of the input field */
    padding: 0 10px; /* Padding inside the input field */
    font-size: 16px; /* Font size of the text inside the input field */
    border: 1px solid #ccc; /* Border color and style */
    border-radius: 4px; /* Rounded corners */
    box-shadow: 0 2px 4px rgba(0,0,0,0.1); /* Subtle shadow */
    transition: border-color 0.3s; /* Smooth transition for border color */
    margin-bottom: -3px; /* Space below the input field */
}

/* Style for the new task input field on focus */
#newTask:focus {
    border-color: #007bff; /* Border color when focused */
    outline: none; /* Remove default outline */
}

/* Style for the category select dropdown */
#categorySelect {
    width: 100%; /* Adjust width to fit the container */
    max-width: 160px; /* Maximum width of the dropdown */
    height: 40px; /* Height of the dropdown */
    padding: 0 10px; /* Padding inside the dropdown */
    font-size: 16px; /* Font size of the text inside the dropdown */
    border: 1px solid #ccc; /* Border color and style */
    border-radius: 4px; /* Rounded corners */
    box-shadow: 0 2px 4px rgba(0,0,0,0.1); /* Subtle shadow */
    transition: border-color 0.3s; /* Smooth transition for border color */
}

/* Style for the category select dropdown on focus */
#categorySelect:focus {
    border-color: #007bff; /* Border color when focused */
    outline: none; /* Remove default outline */
}

/* Style for the search bar container */
.search-container {
    margin: 10px; /* Space around the search bar */
}

/* Style for the search input */
#searchBar {
    width: 100%; /* Adjust width to fit the container */
    max-width: 400px; /* Maximum width of the search bar */
    height: 40px; /* Height of the search bar */
    padding: 0 10px; /* Padding inside the search bar */
    font-size: 16px; /* Font size of the text inside the search bar */
    border: 1px solid #ccc; /* Border color and style */
    border-radius: 4px; /* Rounded corners */
    box-shadow: 0 2px 4px rgba(0,0,0,0.1); /* Subtle shadow */
    transition: border-color 0.3s; /* Smooth transition for border color */
}

/* Style for the search input on focus */
#searchBar:focus {
    border-color: #007bff; /* Border color when focused */
    outline: none; /* Remove default outline */
}

/* Optional: Style for the search button if you have one */
#searchButton {
    padding: 10px 20px;
    font-size: 16px;
    color: #fff;
    background-color: #007bff;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    margin-left: 10px;
    transition: background-color 0.3s;
}

#searchButton:hover {
    background-color: #0056b3;
}





.deadline-button {
    background-color: white;
    color: white;
    border: none;
    padding: 5px 10px;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    font-size: 14px;
}

.deadline-button .deadline-text {
    margin-right: 5px;
}

.deadline-button.expired::after {
    content: ' !';
    color: white;
    font-weight: bold;
}




/* Modal background */
.modal {
    display: none; /* Hidden by default */
    position: fixed; /* Fixed position to keep it in place relative to the viewport */
    top: 0;
    left: 0;
    width: 100%; /* Full width of the viewport */
    height: 100%; /* Full height of the viewport */
    background-color: rgba(0, 0, 0, 0.4); /* Background color with opacity */
    z-index: 1000; /* Ensure the modal is above other content */
    display: flex; /* Use flexbox to center the modal content */
    justify-content: center; /* Center horizontally */
    align-items: center; /* Center vertically */
}

/* Modal content (the actual box) */
.modal-content {
    background-color: white; /* White background for the modal */
    border: 1px solid #ccc; /* Border around the modal */
    padding: 20px; /* Padding inside the modal */
    border-radius: 4px; /* Rounded corners */
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1); /* Shadow for better visibility */
    width: 300px; /* Fixed width for the modal */
    max-width: 90%; /* Ensure modal does not exceed viewport width */
    box-sizing: border-box; /* Include padding and border in width calculation */
    position: relative; /* Ensure close button is positioned correctly */
}

/* Close button */
.close {
    position: absolute;
    top: 10px;
    right: 10px;
    cursor: pointer;
    font-size: 18px;
    font-weight: bold;
}

/* Button styling */
.modal-content button {
    padding: 10px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    background-color: #007bff;
    color: white;
    width: 100%; /* Full width buttons */
    margin-top: 5px; /* Space between buttons */
}

.modal-content button:hover {
    background-color: #0056b3;
}



/* Default background color and uniform styling for the information column */
.infoColumn {
    background-color: #f0f0f0; /* Light grey background by default */
    padding: 10px; /* Consistent padding for uniform spacing */
    border-radius: 4px; /* Rounded corners for a neat look */
    margin: 5px 0; /* Margin for spacing between list items */
    transition: background-color 0.3s ease; /* Smooth transition for background color changes */
    width: 100%; /* Ensure the column fills the width of its container */
    display: block; /* Ensure the element behaves like a block-level element */
}

/* Ensure the parent element (li) does not interfere with styling */
ul li {
    padding: 0; /* Remove default padding if any */
    margin: 0; /* Remove default margin if any */
}

/* Increased opacity for urgent tasks */
ul li.urgent .infoColumn {
    background-color: rgba(255, 0, 0, 0.2); /* Red background with increased opacity */
}

/* Ensure the entire background of the list item changes color */
ul li.urgent {
    background-color: rgba(255, 0, 0, 0.2); /* Red background for the entire list item */
}



/* Basic styling for tasks */
.task {
    padding: 50px;
    margin: 25px 0;
margin-bottom: 20px; /* Adds space between tasks */
    background-color: #f0f0f0;
    border: 1px solid #ccc;
    border-radius: 25px;
    cursor: pointer; /* Cursor style to indicate clickable/draggable */
}

/* Styling when hovering over a draggable item */
.task:hover {
    background-color: #e0e0e0;
}

/* Styling when dragging an item */
.task.dragging {
    opacity: 0.5; /* Reduced opacity to indicate dragging */
    border: 1px dashed #666; /* Dashed border while dragging */
}





/* Styling for horizontal line (hr) */
hr {
    margin: 10px 0; /* Add margin above and below the horizontal line */
    border: none;
    border-top: 1px solid #ccc; /* Solid line with light gray color */
}


body {
            font-size: 20px;
        }

        h1 {
            font-size: 30px;
        }



        ul li.urgent {
            color: black; /* Highlight urgent tasks in red */
        }

        ul li label {
            display: flex;
            align-items: center;
            color: black; /* Change label color to black */
        }

        ul li label.input {
            margin-right: 5px;
        }

        input[type="text"] {
            width: 70%;
            padding: 10px;
            font-size: 18px;
        }

        button {
            padding: 6px 12px; /* Smaller padding for buttons */
            font-size: 14px; /* Smaller font size for buttons */
            margin-right: 10px; /* Add margin to separate buttons */
        }

        .urgent-text {
            color: black; /* Change color of 'urgent' to black */
        }


        
        /* Style for modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 1;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.4);
        }

        .modal-content {
            background-color: #fefefe;
            margin: 15% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }

        .close:hover,
        .close:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }

        .task-entry {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }

.category-buttons {
    display: flex;
    flex-direction: column; /* Stack buttons vertically */
}

.category-buttons button {
    margin-bottom: 10px; /* Add margin between buttons */
}

#addCategory,
#deleteCategory,
#editCategory {
    font-size: 11px; /* Adjust the font size as needed */
}

/* Apply glassy effect to all buttons except edit and delete buttons */
button:not(.edit-button):not(.delete-button) {
    background-color: FFFFFF; /* Use rgba to specify a color with transparency */
    border: none;
    border-radius: 5px; /* Add rounded corners */
    padding: 6px 12px;
    font-size: 14px;
    margin-right: 10px;
    box-shadow: 0 2px 4px rgba(255, 255, 255, 1); /* Add a subtle shadow effect */
    color: #000000; /* Set the font color to white */
}







/* Style for the edit and delete buttons */
.edit-button,
.delete-button {
    padding: 4px 8px; /* Adjust padding for smaller size */
    font-size: 12px; /* Adjust font size for smaller size */
    cursor: pointer;
    border: none;
    outline: none;
    background-color: #ccc; /* Grey background */
    color: #000; /* Black color */
    border-radius: 4px; /* Add border-radius for rounded corners */
    transition: background-color 0.3s, color 0.3s; /* Smooth transition */
}

.edit-button:hover,
.delete-button:hover {
    background-color: #999; /* Darker grey background on hover */
    color: #000; /* Black color on hover */
}


.checkbox-wrapper {
    margin-left: 7.75in; /* Move the checkbox 5.7 inches to the left  */
   position: relative; /* Set position to relative */
    top: -0.2in; /* Move the checkbox 1.2cm upwards (negative value) */




/* Style for the container of input fields and dropdowns */
.input-container {
    margin: 10px; /* Space around the input fields and dropdowns */
}


/* CSS styles for the popup window */
.popup {
    display: none;
    position: fixed;
    z-index: 1;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow: auto;
    background-color: rgba(0, 0, 0, 0.4);
}

.popup-content {
    background-color: #fefefe;
    margin: 15% auto;
    padding: 20px;
    border: 1px solid #888;
    width: 50%;
}

.close {
    color: #aaa;
    float: right;
    font-size: 28px;
    font-weight: bold;
    cursor: pointer;
}

.close:hover,
.close:focus {
    color: black;
    text-decoration: none;
    cursor: pointer;
}





</style>



    


<!-- Center-aligned heading -->
<h3 style="text-align: center;"></h3>

<br />
<br />
<br />

<!-- Center-aligned div content -->
<div style="text-align: center;">
    

    <label for="sortSelect"></label>
    <select id="sortSelect">
        <option value="none" />&#9881;&#65039; Sorters 🎱
        <option value="urgency" />Urgent Puller 📣
        <option value="category" />Categorizer 📑
        <option value="date-oldest" />Ascender 🔺&#65039;
        <option value="date-newest" />Descender 🔽
        <option value="priority" />Prioritizer &#11093;&#65039;
<option value="deadline" />Deadliner 🗓&#65039;    
<option value="color" />Colorizer 🎨 <!-- New Color Sort Option -->
</select>        

<br/>
<br/>


 <button id="setReminder">🔔 Set Reminder &#9201;&#65039;</button> <!-- Add Set Reminder button -->
</div>

   




    <div class="task-entry">
        <button id="addTask"> 📝   </button>
        <input type="text" id="newTask" placeholder="🆕&#9999;&#65039;📃Add a New Task (Use Emojis for Vibrance📱 &#10024;&#65039; 🌎)" />
        <select id="categorySelect"> <!-- Add select dropdown for categories -->
            <option value="" />Category 
            <!-- Categories will be dynamically populated here -->
        </select>



<!-- Main Button to trigger the modal -->
<button id="showModal">🗄&#65039; Organize 📂</button>








<!-- Modal Window -->
<div id="categoryModal" class="modal">
    <div class="modal-content">
        <button id="addCategory">&#10133; Add Category 📁</button> <!-- Button for adding new category -->
        <button id="editCategory">🛠&#65039; Rename Category 🔨</button> <!-- Button for editing category name -->
        <button id="deleteCategory">🗑&#65039; Delete Category 📛</button> <!-- Button for deleting category -->
        <span class="close">&times;</span> <!-- Close button for the modal -->
    </div>
</div>






</div>
<!-- Modal for editing category name -->
<div id="editCategoryModal" class="modal">
    <div class="modal-content">
        <span class="close">&times;</span>
        <h2>Edit Category</h2>
        <input type="text" id="editCategoryInput" placeholder="Enter new category" />
        <button id="saveEditedCategory">Save 💾</button>
    </div>
</div>
    



  

<button id="viewAllTasks">📖 View All 👀Tasks &#9874;&#65039;</button> <!-- Button for viewing all tasks -->
<input type="text" id="searchBar" placeholder="🔎 Search tasks...🔍" />



<button id="viewUrgentTasks">🛑&#9200; View All Urgent Tasks &#8252;&#65039;&#8265;&#65039;</button> <!-- Button for viewing urgent tasks -->





 
<br/>
<br/>
<div class="message-board" id="messageBoard">
  <span id="messageText">IMPORTANT NOTICE: 100% Device📲 Centric Storage!🙂 We do not store any user data in servers or have any access to it!💯 All data is stored locally in YOUR device!💻 All data is stored on your end and your security is your responsibility on the internet. Only when a reminder is set, the task is handed over to Google Calendar.💻 Greetings  🎆and a Warm Welcome🎉 from our team at 🪔Free Checklist App!💡You can Click/Tap to edit this message!📝 This is your Whiteboard!🪧 Reminder: If you need to reset categories and completed tasks easily, simply download the default tasks via incognito mode and use that as a Clean Installation file. 👓 Categories and completed tasks are user protected by nature and require multiple uploads to restore/update, and a Factory Reset to clear. 🧶WARNING🔴: Since accessed via browser, clearing browser data🚮 will result in data loss🚮. Please download👇 and backup👇 before browser reset. 🥸- Chief </span>
</div>

<span class="checkbox-wrapper">
    <label for="selectAllTasks">🔷 Select All &#9989;</label> <!-- Label for the checkbox -->
    <input type="checkbox" id="selectAllTasks" /> <!-- Checkbox for selecting all tasks -->
</span>

<br/>
<div id="clock">Loading...</div>
     <button id="shareSelectedTasks">📲 Share Selected Tasks 🖨&#65039;</button> <!-- Button for sharing selected tasks -->
  


  <button id="pasteTasks">🅿&#65039; Paste Tasks 🔗</button> <!-- Button for pasting tasks -->

<!-- Button to trigger the display of all tasks -->
<button id="displayTasks">📜</button>

<!-- Modal to display tasks in an iframe -->
<div id="tasksModal" class="modal">
    <div class="modal-content">
        <span class="close">&times;</span>
        <iframe id="tasksIframe"></iframe>
    </div>
</div>



<br/>
<br/>
<br/>


    <ul id="taskList">

        <!-- Existing tasks will be listed here -->
    </ul>
    <h2>Completed Tasks</h2>
    <ul id="completedList">
        <!-- Completed tasks will be listed here -->
    </ul>

<br/>





<button id="shareCompletedTasks">📱 Share Completed Tasks 💻</button> <!-- Button for sharing completed tasks -->  

<button id="clearCompleted">🚮 Clear Completed 🗑&#65039;</button>

  <!-- Modal for adding new category -->
    <div id="addCategoryModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>Add New Category</h2>
            <input type="text" id="newCategoryInput" placeholder="Enter new category" />
            <button id="saveNewCategory">Save 💾</button>
        </div>
    </div>
    <!-- Modal for pasting tasks -->
    <div id="pasteModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>Paste Tasks</h2>
            <textarea id="pastedTasks" placeholder="Paste copied tasks here"></textarea>
            <button id="confirmPaste">Confirm</button>
        </div>
    </div>
    <script>
        if (typeof(Storage) !== "undefined") {
            let storedTasks = JSON.parse(localStorage.getItem('tasks')) || [];
            let completedTasks = JSON.parse(localStorage.getItem('completedTasks')) || [];
            



// Add event listener for the "Select All" checkbox
document.getElementById('selectAllTasks').addEventListener('change', function() {
    const selectAllCheckbox = this;
    const selectedCategory = document.getElementById('categorySelect').value;
    storedTasks.forEach(task => {
        if (task.category === selectedCategory || selectedCategory === '') {
            // Only select tasks that belong to the current category or all tasks if no category is selected
            task.select = selectAllCheckbox.checked;
        }
    });
    updateLocalStorage(); // Update local storage after selecting all tasks
    displayTasks(); // Refresh the displayed tasks
});


// Add event listener for category selection change
document.getElementById('categorySelect').addEventListener('change', function() {
    const selectAllCheckbox = document.getElementById('selectAllTasks');
    const selectedCategory = this.value;
    let tasksInSelectedCategory = storedTasks.filter(task => task.category === selectedCategory);
    // Check if there are any tasks selected in the new category
    const anyTasksSelected = tasksInSelectedCategory.some(task => task.select);
    if (!anyTasksSelected) {
        // If no tasks are selected in the new category, uncheck the "Select All" checkbox
        selectAllCheckbox.checked = false;
    }
    // Refresh the displayed tasks
    displayTasks();
});




let categories = JSON.parse(localStorage.getItem('categories')) || [ "Personal 🏠", "Work 🏢", "Study 🎒", "Other 📚"]; // Initialize with default categories

            const updateLocalStorage = () => {
                localStorage.setItem('tasks', JSON.stringify(storedTasks));
                localStorage.setItem('completedTasks', JSON.stringify(completedTasks));
                localStorage.setItem('categories', JSON.stringify(categories));
            };




 // Function to sort tasks by category
                const sortTasksByCategory = () => {
                    storedTasks.sort((a, b) => {
                        if (a.category < b.category) return -1;
                        if (a.category > b.category) return 1;
                        return 0;
                    });
// Save the sorted tasks back to localStorage
    updateLocalStorage();                       
displayTasks(); // Refresh the task display after sorting
                };

                // Function to sort tasks by urgency
                const sortTasksByUrgency = () => {
                    storedTasks.sort((a, b) => {
                        return b.urgent - a.urgent; // Sort so that urgent tasks come first
                    });
// Save the sorted tasks back to localStorage
    updateLocalStorage();                   
 displayTasks(); // Refresh the task display after sorting
                };

            
//Function to sort tasks by date
const sortTasksByDate = (order = 'newest') => {
    console.log("Sorting tasks by date");
    console.log("Before sorting:", storedTasks);

    // Function to convert locale date string to ISO string
    const parseDate = (dateString) => {
        // Example dateString: "20/08/2024, 16:27:54"
        const [datePart, timePart] = dateString.split(', ');
        const [day, month, year] = datePart.split('/').map(Number);
        const [hours, minutes, seconds] = timePart.split(':').map(Number);

        // Return the ISO string format
        return new Date(year, month - 1, day, hours, minutes, seconds).toISOString();
    };

    storedTasks.sort((a, b) => {
        // Convert locale strings to ISO strings
        const isoDateA = parseDate(a.timestamp);
        const isoDateB = parseDate(b.timestamp);

        // Compare ISO strings
        return order === 'newest' ? isoDateB.localeCompare(isoDateA) : isoDateA.localeCompare(isoDateB);
    });

// Save the sorted tasks back to localStorage
    updateLocalStorage();
    console.log("After sorting:", storedTasks);
    displayTasks();
};






// Function to sort tasks by priority
const sortTasksByPriority = () => {
    console.log("Sorting tasks by priority");
    console.log("Before sorting:", storedTasks);

    storedTasks.sort((a, b) => {
        // Assign default priority if not set
        const priorityA = a.priority !== undefined ? a.priority : 3;
        const priorityB = b.priority !== undefined ? b.priority : 3;

        return priorityB - priorityA; // Sort so that tasks with higher priority come first
    });

// Save the sorted tasks back to localStorage
    updateLocalStorage();
    console.log("After sorting:", storedTasks);
    displayTasks(); // Refresh the task display after sorting
};




// Function to sort tasks by deadline
const sortTasksByDeadline = () => {
    console.log("Sorting tasks by deadline");
    console.log("Before sorting:", storedTasks);
    storedTasks.sort((a, b) => {
        if (!a.deadline && !b.deadline) return 0; // If both tasks have no deadline
        if (!a.deadline) return 1; // If task 'a' has no deadline, move it down
        if (!b.deadline) return -1; // If task 'b' has no deadline, move it down
        const deadlineA = new Date(a.deadline);
        const deadlineB = new Date(b.deadline);
        return deadlineA - deadlineB; // Sort tasks so the earliest deadline comes first
    });
// Save the sorted tasks back to localStorage
    updateLocalStorage();
    console.log("After sorting:", storedTasks);
    displayTasks(); // Refresh the task display after sorting
};


// Function to sort tasks by highlight color
const sortTasksByColor = () => {
    console.log("Sorting tasks by color");
    console.log("Before sorting:", storedTasks);

    // Define the order of colors for sorting
    const colorOrder = [
        "#FFD700", // Golden Yellow
        "#A0C4FF", // Sky Blue
        "#98D98E", // Soft Green
        "#FFB07C", // Warm Peach
        "#C8A2C8", // Lilac
        "#66B2B2", // Teal
        "#E9747A", // Rose
        "#E0E0E0"  // Default (Gray, should be last)
    ];

    storedTasks.sort((a, b) => {
        const colorA = a.colorCode || "#E0E0E0"; // Default color if none is assigned
        const colorB = b.colorCode || "#E0E0E0";
        
        return colorOrder.indexOf(colorA) - colorOrder.indexOf(colorB);
    });

    // Save the sorted tasks back to localStorage
    updateLocalStorage();
    console.log("After sorting:", storedTasks);
    displayTasks(); // Refresh the task display after sorting
};



              // Add event listener for the sort dropdown
document.getElementById('sortSelect').addEventListener('change', function() {
    console.log("Sort option selected:", this.value);
localStorage.setItem('selectedSortType', this.value); // Save selected sort type
    
if (this.value === 'category') {
        sortTasksByCategory();
    } else if (this.value === 'urgency') {
        sortTasksByUrgency();
    } else if (this.value === 'date-newest') {
        sortTasksByDate('newest');
    } else if (this.value === 'date-oldest') {
        sortTasksByDate('oldest');
 } else if (this.value === 'priority') {
        sortTasksByPriority(); // Call the new sorting function
} else if (this.value === 'deadline') {
        sortTasksByDeadline(); // Call the new sorting function for deadlines
    } else if (this.value === 'color') {
        sortTasksByColor(); // New color sorting function
    } else {
        displayTasks(); // Reset to original display if "None" is selected
    }
});


// Function to sort tasks based on search input
const sortTasksBySearch = (searchTerm) => {
    console.log("Sorting tasks by search term:", searchTerm);
    console.log("Before sorting:", storedTasks);

    // Convert search term to lowercase for case-insensitive comparison
    const lowerCaseSearchTerm = searchTerm.toLowerCase();

    // Sort tasks so that those matching the search term come first
    storedTasks.sort((a, b) => {
        const aText = (a.text + ' ' + a.category).toLowerCase();
        const bText = (b.text + ' ' + b.category).toLowerCase();

        // Check if the search term is 'urgent'
        const isUrgentSearch = lowerCaseSearchTerm === 'urgent';

        // Determine if the task matches the search term
        const aMatches = aText.includes(lowerCaseSearchTerm) ? 1 : 0;
        const bMatches = bText.includes(lowerCaseSearchTerm) ? 1 : 0;

        // Prioritize tasks marked as urgent if the search term is 'urgent'
        if (isUrgentSearch) {
            return (b.urgent ? 1 : 0) - (a.urgent ? 1 : 0);
        }

        // Place tasks matching the search term at the top
        return bMatches - aMatches;
    });

    // Save the sorted tasks back to localStorage
    updateLocalStorage();
    console.log("After sorting:", storedTasks);

    // Refresh the task display after sorting
    displayTasks();
};

// Add event listener for the search bar
document.getElementById('searchBar').addEventListener('input', function() {
    const searchTerm = this.value;
    if (searchTerm.trim() === '') {
        // If the search term is empty, reset to original order or display all tasks
        displayTasks(); // Ensure you have a function to reset to the default display
    } else {
        sortTasksBySearch(searchTerm);
    }
});



           const addTask = () => {
    let newTaskText = document.getElementById('newTask').value;
    const category = document.getElementById('categorySelect').value; // Get selected category

    let isUrgent = false;

    // Check if the word 'urgent' is in the task text
    if (newTaskText.toLowerCase().includes('urgent')) {
        isUrgent = true;
        newTaskText = newTaskText.replace(/urgent/gi, '').trim(); // Remove the word 'urgent' from the task text
    }

    if (newTaskText.trim() !== '' && category.trim() !== '') {
        const newTask = {
            text: newTaskText,
            category: category, // Assign selected category to task
            completed: false,
            urgent: isUrgent, // Set the urgent flag based on the command
            select: false, // New property for selecting task
            timestamp: new Date().toLocaleString() // Add date and time of task entry
        };

        storedTasks.push(newTask);
        // Get the selected sort type from localStorage
        const selectedSortType = localStorage.getItem('selectedSortType');
        console.log("Auto-sorting by:", selectedSortType);

        // Auto-sort based on the selected sort type
        if (selectedSortType === 'category') {
            sortTasksByCategory();
        } else if (selectedSortType === 'urgency') {
            sortTasksByUrgency();
        } else if (selectedSortType === 'date-newest') {
            sortTasksByDate('newest');
        } else if (selectedSortType === 'date-oldest') {
            sortTasksByDate('oldest');
        } else if (selectedSortType === 'priority') {
            sortTasksByPriority();
        } else if (selectedSortType === 'deadline') {
            sortTasksByDeadline();
        }


        updateLocalStorage(); // Save to localStorage
        document.getElementById('newTask').value = '';
        displayTasks();
    } else {
        alert("Please enter both task and category.");
    }
};


     // Function to clear all completed tasks
const clearCompleted = () => {
    // Log the number of tasks before clearing
    console.log('Number of completed tasks before clearing:', completedTasks.length);
    
    // Log the completed tasks being cleared
    console.log('Completed tasks before clearing:', completedTasks.map(task => task.text));

    // Remove completed tasks from storedTasks
    storedTasks = storedTasks.filter(task => !task.completed);

    // Log the number of tasks after clearing
    console.log('Number of tasks in storedTasks after clearing completed:', storedTasks.length);

    // Clear the completedTasks array
    completedTasks = [];

    // Log the clearing of completedTasks array
    console.log('Completed tasks array has been cleared.');

    // Update localStorage with the new storedTasks
    updateLocalStorage();
    
    // Log localStorage update
    console.log('localStorage updated with new storedTasks.');

    // Refresh the display of completed tasks and all tasks
    displayCompletedTasks();
    displayTasks(); // Refresh all tasks to reflect changes

    // Log the refresh actions
    console.log('Completed tasks display and all tasks display refreshed.');
};







           
const displayTasks = () => {
    const taskList = document.getElementById('taskList');
    taskList.innerHTML = '';
    const selectedCategory = document.getElementById('categorySelect').value;

    const urlRegex = /(?:https?:\/\/(?:www\.)?[^\s]+)|(?:www\.[^\s]+)|(?:\b[A-Za-z0-9.-]+\.[A-Za-z]{2,}\b)/gi;


    for (let i = 0; i < storedTasks.length; i++) {
        const task = storedTasks[i];
        if (!task.completed && (selectedCategory === '' || task.category === selectedCategory)) {
            const listItem = document.createElement('li');
            listItem.classList.add('task');
            if (task.urgent) {
                listItem.classList.add('urgent');
            }



 // Checkbox for completion status
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.checked = task.completed;
            checkbox.addEventListener('change', () => {
                task.completed = checkbox.checked;
                updateLocalStorage();
                displayTasks();
                if (task.completed) {
task.completedTimestamp = new Date().toLocaleString(); // Log the current date and time as the completion timestamp
                    completedTasks.push(task);
                    updateLocalStorage();
                    displayCompletedTasks();
                }
            });
            listItem.appendChild(checkbox);

            // Information Column
            const infoColumn = document.createElement('div');
            infoColumn.classList.add('column');
            const taskTextWithLinks = task.text.replace(urlRegex, (match) => {
                const url = match.startsWith('www') ? `http://${match}` : match;
                return `<a href="${url}" target="_blank" style="color: blue;">${match}</a>`;
            });
            infoColumn.innerHTML = taskTextWithLinks;
            listItem.appendChild(infoColumn);

 

            // Notes Column
const notesColumn = document.createElement('div');
notesColumn.classList.add('column', 'notes-column'); // Apply notes column styles

// Create a notebook icon that opens the note editor
const notebookIcon = document.createElement('span');
notebookIcon.classList.add('notebook-icon');
notebookIcon.innerHTML = '📝'; // You can use an emoji or FontAwesome icon here

// Find the task text from the adjacent info column
const taskText = infoColumn.textContent.trim();

// Add an event listener to open the note editor for this task
notebookIcon.addEventListener('click', () => {
    openNoteEditor(taskText);
});

// Append the notebook icon to the notes column
notesColumn.appendChild(notebookIcon);

// Append the notes column to the list item
listItem.appendChild(notesColumn);

// Function to open the note editor
function openNoteEditor(taskText) {
    // Ensure no duplicate popups
    document.querySelectorAll('.note-popup').forEach(popup => popup.remove());

    const notePopup = document.createElement('div');
    notePopup.classList.add('note-popup');

    // Create the close button (X)
    const closeButton = document.createElement('span');
    closeButton.classList.add('close-button');
    closeButton.innerHTML = '&#215;'; // The "X" symbol
    closeButton.addEventListener('click', () => {
        notePopup.remove(); // Close the popup when clicked
    });

    // Create the textarea for note entry
    const noteTextArea = document.createElement('textarea');
    noteTextArea.placeholder = 'Write your notes here...';

    // Retrieve the task dataset from localStorage
    let storedTasks = JSON.parse(localStorage.getItem('tasks')) || [];
    let task = storedTasks.find(t => t.text === taskText);

    // Load existing note if available
    if (task && task.note) {
        noteTextArea.value = task.note;
    }

    // Auto-save notes when the user types
    noteTextArea.addEventListener('input', () => {
        saveTaskNote(taskText, noteTextArea.value);
    });

    // Append elements to the popup
    notePopup.appendChild(closeButton);
    notePopup.appendChild(noteTextArea);
    document.body.appendChild(notePopup);

    // Apply basic popup styles inline
    Object.assign(notePopup.style, {
        position: 'fixed',
        top: '50%',
        left: '50%',
        transform: 'translate(-50%, -50%)',
        width: '40%',
        maxWidth: '90%',
        background: 'white',
        border: '1px solid #ccc',
        padding: '20px',
        zIndex: '1000',
        boxShadow: '0 4px 8px rgba(0, 0, 0, 0.1)',
    });
}

// Function to save notes inside the existing task dataset
function saveTaskNote(taskText, note) {
    let storedTasks = JSON.parse(localStorage.getItem('tasks')) || [];

    const taskIndex = storedTasks.findIndex(t => t.text === taskText);
    if (taskIndex !== -1) {
        storedTasks[taskIndex].note = note;
        localStorage.setItem('tasks', JSON.stringify(storedTasks));
    }
}




// Highlights Column with Color Selector for Each Task
const highlightsColumn = document.createElement('div');
highlightsColumn.classList.add('column');

// Create a select element for background color selection
const highlightSelect = document.createElement('select');
highlightSelect.classList.add('highlight-select');

// Define highlight color options (with color emojis)
const highlightColors = [
    { name: "Default", value: "#E0E0E0", emoji: "🩶" },
    { name: "Sky Blue", value: "#A0C4FF", emoji: "💙" },
    { name: "Soft Green", value: "#98D98E", emoji: "💚" },
    { name: "Golden Yellow", value: "#FFD700", emoji: "💛" },
    { name: "Warm Peach", value: "#FFB07C", emoji: "🧡" },
    { name: "Lilac", value: "#C8A2C8", emoji: "💜" },
    { name: "Teal", value: "#66B2B2", emoji: "💧" },
    { name: "Rose", value: "#E9747A", emoji: "🌹" }
];

// Function to retrieve saved highlight color from tasks dataset
function getTaskColor(taskText) {
    const tasks = JSON.parse(localStorage.getItem('tasks')) || [];
    const task = tasks.find(t => t.text === taskText);
    return task && task.colorCode ? task.colorCode : "#E0E0E0"; // Default to #E0E0E0 if no color is found
}

// Assign the saved color (if any) to the current task
const taskColor = getTaskColor(task.text); // Use Task Text as the unique identifier

// Add color options to the dropdown with color emojis
highlightColors.forEach(color => {
    const option = document.createElement('option');
    option.value = color.value;
    option.textContent = color.emoji;
    highlightSelect.appendChild(option);
});

// Set the current selected color based on the saved color for the task
highlightSelect.value = taskColor;

// Function to update the background color while respecting Urgent status
function updateTaskBackground() {
    if (task.urgent) {
        listItem.style.backgroundColor = "#FF4C4C"; // Urgent color always trumps
        highlightSelect.disabled = true; // Disable highlight selection for urgent tasks
    } else {
        listItem.style.backgroundColor = highlightSelect.value;
        highlightSelect.disabled = false; // Enable highlight selection for non-urgent tasks
    }
}

// Function to update task color in localStorage
function saveTaskColor(taskText, color) {
    let tasks = JSON.parse(localStorage.getItem('tasks')) || [];
    let taskIndex = tasks.findIndex(t => t.text === taskText);

    if (taskIndex !== -1) {
        if (color === "#E0E0E0") {
            delete tasks[taskIndex].colorCode; // Remove the property if default is selected
        } else {
            tasks[taskIndex].colorCode = color; // Assign new colorCode
        }
        localStorage.setItem('tasks', JSON.stringify(tasks));
    }
}

// Event listener for when a new highlight color is selected
highlightSelect.addEventListener('change', function () {
    const selectedColor = this.value;
    saveTaskColor(task.text, selectedColor); // Update the task object in localStorage
    updateTaskBackground(); // Apply the new color to the task
});

// Append the select element to the highlights column
highlightsColumn.appendChild(highlightSelect);
listItem.appendChild(highlightsColumn);

// Apply the background color update
updateTaskBackground();




// Priority Column with Dropdown
       // Create a container for the priority column
const priorityColumn = document.createElement('div');
priorityColumn.classList.add('column');

// Create a select element for priority levels
const prioritySelect = document.createElement('select');
prioritySelect.classList.add('priority-select');


// Add options to the select element for priorities 5 (highest) to 1 (lowest)
    [5, 4, 3, 2, 1].forEach(level => {
        const option = document.createElement('option');
        option.value = level;
        // Set the display text based on the priority level
        switch(level) {
            case 5:
                option.textContent = '🔥';
                break;
            case 4:
                option.textContent = '😬';
                break;
            case 3:
                option.textContent = '🚦';
                break;
            case 2:
                option.textContent = '🙏';
                break;
            case 1:
                option.textContent = '💚';
                break;
        }
        // Set the selected option based on the task's current priority, default to 3 if not set
        if ((task.priority && task.priority == level) || (!task.priority && level == 3)) {
            option.selected = true;
        }
        prioritySelect.appendChild(option);
    });

// Add an event listener to update the task's priority when a new option is selected
prioritySelect.addEventListener('change', function() {
    task.priority = parseInt(this.value); // Update the task's priority, ensuring it's an integer
    
// Auto-sort by priority after changing the priority
        sortTasksByPriority();
updateLocalStorage(); // Save the updated tasks to local storage
    displayTasks(); // Refresh the displayed tasks
});

// Append the select element to the priority column
priorityColumn.appendChild(prioritySelect);

// Append the priority column to the list item
listItem.appendChild(priorityColumn);





 // Urgency Column
            const urgencyColumn = document.createElement('div');
            urgencyColumn.classList.add('column', 'urgency-column'); // Apply urgency column styles
            const urgentLabel = document.createElement('label');
            const urgentText = document.createElement('span');
            urgentText.innerText = 'Urgent';
            urgentText.classList.add('urgent-text');
            urgentLabel.appendChild(urgentText);
            const urgentCheckbox = document.createElement('input');
            urgentCheckbox.type = 'checkbox';
            urgentCheckbox.checked = task.urgent;
            urgentCheckbox.addEventListener('change', () => {
                task.urgent = urgentCheckbox.checked;
                sortTasksByUrgency();    
updateLocalStorage();
                displayTasks();
                if (task.urgent) {
                    listItem.classList.add('urgent');
                } else {
                    listItem.classList.remove('urgent');
                }
            });
            urgentLabel.appendChild(urgentCheckbox);
            urgencyColumn.appendChild(urgentLabel);
            listItem.appendChild(urgencyColumn);





// Deadline Column
// Add this to the code where the columns are created
const deadlineColumn = document.createElement('div');
deadlineColumn.classList.add('column');

const deadlineButton = document.createElement('button');
deadlineButton.innerHTML = '&#9200;';
deadlineButton.classList.add('deadline-button');

// Check if there's already a deadline set for the task
if (task.deadline) {
    deadlineButton.innerText = task.deadline;
    checkAndUpdateDeadline(task, deadlineButton); // Call the function to update the background color based on the deadline
}

// Event listener for setting the deadline
deadlineButton.addEventListener('click', () => {
    // Request notification permission
    if (Notification.permission === 'default') {
        Notification.requestPermission().then(permission => {
            if (permission === 'granted') {
                proceedWithDeadlineSetting();
            } else {
                alert('Notification permission is required to set deadlines.');
            }
        });
    } else if (Notification.permission === 'granted') {
        proceedWithDeadlineSetting();
    } else {
        alert('Notification permission is required to set deadlines.');
    }
});

deadlineColumn.appendChild(deadlineButton);
listItem.appendChild(deadlineColumn);

// Function to proceed with setting the deadline after notification permission is granted
function proceedWithDeadlineSetting() {
    const deadlineInput = prompt('Enter Deadline (yyyy-mm-dd hh:mm):', task.deadline || '');
    if (isValidDeadline(deadlineInput)) {
        const isAmending = task.deadline !== undefined;

        task.deadline = deadlineInput;
        updateLocalStorage();
        deadlineButton.innerText = task.deadline;
        checkAndUpdateDeadline(task, deadlineButton); // Update background color based on the deadline
        sortTasksByDeadline(); // Sort tasks by deadline after setting a new one

        // Cancel previous reminders before scheduling new ones
        cancelReminders(task);
        scheduleDeadlineReminders(task); // Schedule reminders for the deadline
        
        // Notify based on whether the deadline was set or amended
        notifyDeadlineChange(task, isAmending);
    } else {
        alert('Invalid deadline format. Please enter a valid date and time in the format yyyy-mm-dd hh:mm.');
    }
}

// Function to notify when the deadline is set or amended
function notifyDeadlineChange(task, isAmending) {
    if (!isAmending) {
        new Notification('Deadline Set', {
            body: `Deadline for task "${task.text}" has been set for ${task.deadline}.`,
            icon: 'https://freechecklistapp.com/freechecklistapplogo.jpg'
        });
    } else {
        new Notification('Deadline Amended', {
            body: `Deadline for task "${task.text}" has been amended to ${task.deadline}.`,
            icon: 'https://freechecklistapp.com/freechecklistapplogo.jpg'
        });
    }
}

// Function to check and update the background color and icon based on the deadline
function checkAndUpdateDeadline(task, buttonElement) {
    const deadline = new Date(task.deadline);
    const now = new Date();
    const timeDifference = deadline - now;
    const hoursDifference = timeDifference / (1000 * 60 * 60);

    if (deadline < now) {
        buttonElement.innerHTML = `${task.deadline} &#9888;&#65039;`; // Add red exclamation mark for expired deadline
        buttonElement.style.backgroundColor = 'red';
        buttonElement.style.color = 'white';
    } else if (hoursDifference <= 24) {
        buttonElement.innerHTML = `&#9200; ${task.deadline}`; // Keep the clock icon for upcoming deadlines within 24 hours
        buttonElement.style.backgroundColor = 'red';
        buttonElement.style.color = 'white';
    } else {
        buttonElement.innerHTML = `&#9200; ${task.deadline}`; // Keep the clock icon for deadlines more than 24 hours away
        buttonElement.style.backgroundColor = 'white';
        buttonElement.style.color = 'black';
    }
}

// Function to validate the deadline input
function isValidDeadline(deadlineInput) {
    const deadlineRegex = /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}$/;
    if (!deadlineInput || !deadlineRegex.test(deadlineInput)) {
        return false;
    }
    const date = new Date(deadlineInput);
    return date instanceof Date && !isNaN(date);
}

// Function to schedule reminders for the deadline
function scheduleDeadlineReminders(task) {
    const deadline = new Date(task.deadline);
    const now = new Date();

    // Clear previous reminders before scheduling new ones
    cancelReminders(task);

    const timeIntervals = [
        { label: '1 month', milliseconds: 30 * 24 * 60 * 60 * 1000 },
        { label: '2 weeks', milliseconds: 14 * 24 * 60 * 60 * 1000 },
        { label: '1 week', milliseconds: 7 * 24 * 60 * 60 * 1000 },
        { label: '5 days', milliseconds: 5 * 24 * 60 * 60 * 1000 },
        { label: '3 days', milliseconds: 3 * 24 * 60 * 60 * 1000 },
        { label: '1 day', milliseconds: 24 * 60 * 60 * 1000 },
        { label: '12 hours', milliseconds: 12 * 60 * 60 * 1000 },
        { label: '6 hours', milliseconds: 6 * 60 * 60 * 1000 },
        { label: '3 hours', milliseconds: 3 * 60 * 60 * 1000 },
        { label: '1 hour', milliseconds: 1 * 60 * 60 * 1000 },
    ];

    timeIntervals.forEach(interval => {
        const reminderTime = deadline - interval.milliseconds;
        if (reminderTime > now) {
            scheduleReminder(task, reminderTime, interval.label);
        }
    });
}

// Function to schedule a single reminder with double-check verification
function scheduleReminder(task, reminderTime, intervalLabel) {
    const now = new Date().getTime();
    const timeUntilReminder = reminderTime - now;

    // Only set a reminder if the time until the reminder is positive
    if (timeUntilReminder > 0) {
        const reminderId = setTimeout(() => {
            doubleCheckAndNotify(task, reminderTime, intervalLabel);
        }, timeUntilReminder);

        // Store the reminder ID in the task object for future reference
        if (!task.reminderIds) {
            task.reminderIds = [];
        }
        task.reminderIds.push(reminderId);
        updateLocalStorage();
    }
}

// Function to double-check and notify
function doubleCheckAndNotify(task, reminderTime, intervalLabel) {
    const checkInterval = 5000; // 5 seconds
    let checkCount = 0;
    const maxChecks = 3;

    const intervalId = setInterval(() => {
        const now = new Date().getTime();
        if (now >= reminderTime) {
            checkCount++;
            if (checkCount >= maxChecks) {
                clearInterval(intervalId);

                // Perform the final check before notifying
                if (!task.completed) {
                    new Notification('Deadline Reminder', {
                        body: `Task: ${task.text} is due in ${intervalLabel}!`,
                        icon: 'https://freechecklistapp.com/freechecklistapplogo.jpg', // Optional: Add an icon for the notification
                        tag: task.id // Use the task id to avoid duplicate notifications
                    });

                    // Update the task object and localStorage
                    updateLocalStorage();
                }
            }
        }
    }, checkInterval);
}

// Function to cancel all reminders for a task
function cancelReminders(task) {
    if (task.reminderIds) {
        task.reminderIds.forEach(id => clearTimeout(id));
        task.reminderIds = []; // Clear stored reminder IDs
        updateLocalStorage();
    }
}

// Example function to mark a task as completed and cancel its reminders
function markTaskAsCompleted(task) {
    task.completed = true;
    cancelReminders(task);
    updateLocalStorage();
    // Additional logic for marking the task as completed (e.g., updating the UI)
}



// Edit Column
const editColumn = document.createElement('div');
editColumn.classList.add('column');
const editButton = document.createElement('button');
editButton.innerText = 'Edit';
editButton.classList.add('edit-button');
editButton.addEventListener('click', () => {
    // Edit task info
    const editedTaskText = prompt('Edit Task:', task.text);
    if (editedTaskText !== null && editedTaskText.trim() !== '') {
        task.text = editedTaskText.trim();
        updateLocalStorage();
        displayTasks(); // Update task list

                // Create modal for editing category
const editCategoryModal = document.createElement('div');
editCategoryModal.classList.add('modal');
editCategoryModal.innerHTML = `
    <div class="modal-content">
               <p>Select a new category:</p>
<br/>
</br>
               <select id="editCategorySelect">
            ${categories.map(category => `<option value="${category}">${category}</option>`).join('')}
        </select>
         
<br/>
<br/>
      <button id="saveEditedCategoryBtn">Save 💾</button>
                <button id="addNewCategoryBtn"> 🅰&#65039;Add New Category📂</button>


    </div>`;

        document.body.appendChild(editCategoryModal);
        editCategoryModal.style.display = "block";

        // Close modal when outside modal is clicked
        window.onclick = function (event) {
            if (event.target == editCategoryModal) {
                editCategoryModal.style.display = "none";
                document.body.removeChild(editCategoryModal);
            }
        };

        // Save edited category
        const saveEditedCategoryBtn = document.getElementById('saveEditedCategoryBtn');
        saveEditedCategoryBtn.onclick = () => {
            const selectedCategory = document.getElementById('editCategorySelect').value;
            if (selectedCategory !== '') {
                task.category = selectedCategory; // Update task's category
                updateLocalStorage(); // Update local storage with the edited category
                displayTasks(); // Update task list
                editCategoryModal.style.display = "none";
                document.body.removeChild(editCategoryModal);
            } else {
                alert("Please select a category.");
            }
        };

        // Add new category functionality
        const addNewCategoryBtn = document.getElementById('addNewCategoryBtn');
        addNewCategoryBtn.onclick = () => {
            const newCategoryName = prompt('Enter New Category:');
            if (newCategoryName !== null && newCategoryName.trim() !== '') {
                const newCategory = newCategoryName.trim();
                categories.push(newCategory);
                updateLocalStorage();
                populateCategories();
                task.category = newCategory; // Update task's category
                updateLocalStorage();
                displayTasks(); // Update task list
                editCategoryModal.style.display = "none";
                document.body.removeChild(editCategoryModal);
            }
        };
    }
});
editColumn.appendChild(editButton);
listItem.appendChild(editColumn);



            // Delete Column
const deleteColumn = document.createElement('div');
deleteColumn.classList.add('column');
const deleteButton = document.createElement('button');
deleteButton.innerText = 'Delete';
deleteButton.classList.add('delete-button');

deleteButton.addEventListener('click', () => {
    // Prompt user to confirm deletion
    const confirmDelete = confirm('Are you sure you want to delete this task?');
    if (confirmDelete) {
        // Log the confirmation
        console.log('User confirmed deletion.');

        // Delete task from storedTasks array
        const taskIndex = storedTasks.indexOf(task);
        if (taskIndex !== -1) {
            // Log the task being deleted
            console.log('Deleting task:', storedTasks[taskIndex].text);

            // Log the task before deletion
            logTaskDeletion(storedTasks[taskIndex].text);

            storedTasks.splice(taskIndex, 1);
            updateLocalStorage();
            displayTasks(); // Update task list

            // Log the successful deletion and update
            console.log('Task deleted and storedTasks updated.');
        } else {
            // Log if task is not found
            console.error('Task not found in storedTasks.');
        }
    } else {
        // Log if user canceled the deletion
        console.log('User canceled the deletion.');
    }
});

deleteColumn.appendChild(deleteButton);
listItem.appendChild(deleteColumn);


          
            // Select Column
            const selectColumn = document.createElement('div');
            selectColumn.classList.add('column');
            const selectCheckbox = document.createElement('input');
            selectCheckbox.type = 'checkbox';
            selectCheckbox.checked = task.select;
            selectCheckbox.addEventListener('change', () => {
                task.select = selectCheckbox.checked;
                updateLocalStorage();
            });
            const selectLabel = document.createElement('label');
            selectLabel.innerText = 'Select';
            selectLabel.appendChild(selectCheckbox);
            selectColumn.appendChild(selectLabel);
            listItem.appendChild(selectColumn);

            // Category Column
            const categoryColumn = document.createElement('div');
            categoryColumn.classList.add('column');
            categoryColumn.innerText = task.category;
            listItem.appendChild(categoryColumn);

            // Date and Time Column
            const timestampColumn = document.createElement('div');
            timestampColumn.classList.add('column');
            timestampColumn.innerText = task.timestamp;
            listItem.appendChild(timestampColumn);

            taskList.appendChild(listItem);

   

      
// Function to update local storage
const updatelocalStorage = () => {
    localStorage.setItem('tasks', JSON.stringify(storedTasks));
};

// Ensure the tasks are loaded and displayed on page load
document.addEventListener('DOMContentLoaded', () => {
    if (localStorage.getItem('tasks')) {
        storedTasks = JSON.parse(localStorage.getItem('tasks'));
    }
    displayTasks();
});



// Select all columns inside listItem
const columns = listItem.querySelectorAll('.column');

if (columns.length > 0) {
    // Create a wrapper for the infoColumn, which will be the first row
    const infoRow = document.createElement('div');
    infoRow.classList.add('info-row');

    // Move the first column (infoColumn) into infoRow
    infoRow.appendChild(columns[0]);
    
    // Insert the infoRow as the first row inside listItem
    listItem.prepend(infoRow);

    if (columns.length > 1) {
        // Create a wrapper for the other columns, which will be the second row
        const detailsRow = document.createElement('div');
        detailsRow.classList.add('details-row');

        // Move all columns except the first one into detailsRow
        for (let i = 1; i < columns.length; i++) {
            detailsRow.appendChild(columns[i]);
        }

        // Append the new row to listItem
        listItem.appendChild(detailsRow);
    }
}


  // Add horizontal line after each task
            taskList.appendChild(document.createElement('hr'));
        }
    }
};







const displayCompletedTasks = () => {
    const completedList = document.getElementById('completedList');
    completedList.innerHTML = '';
    for (let i = 0; i < completedTasks.length; i++) {
        const task = completedTasks[i];
        const listItem = document.createElement('li');
        listItem.classList.add('task');
        if (task.urgent) {
            listItem.classList.add('urgent');
        }
 
const deadlineText = task.deadline ? `Deadline: ${task.deadline}` : ''; 

const taskText = `${task.text} (Category: ${task.category}, Started: ${task.timestamp}${deadlineText ? `, ${deadlineText}` : ''}, Completed: ${task.completedTimestamp})`;

listItem.innerHTML = taskText;

listItem.addEventListener('click', () => {
    moveCompletedToTasks(task);
});

        completedList.appendChild(listItem);

        // Add horizontal line after each completed task
        completedList.appendChild(document.createElement('hr'));
    }
};


let currentTasks = JSON.parse(localStorage.getItem('tasks')) || []; // Initialize with current data from localStorage

const checkForUpdates = () => {
    console.log("Checking for updates...");

    // Retrieve the latest tasks from localStorage
    const updatedTasks = JSON.parse(localStorage.getItem('tasks')) || [];

    // Compare the length of currentTasks and updatedTasks to detect changes
    if (JSON.stringify(currentTasks) !== JSON.stringify(updatedTasks)) {
        console.log("Update detected. Updating tasks...");
        // Update the currentTasks to the latest state
        currentTasks = updatedTasks;

        // Update localStorage with the new data
        storedTasks = updatedTasks;
        updateLocalStorage();
        displayTasks(); // Call displayTasks to refresh the task display
    } else {
        console.log("No updates found.");
    }
};

// Check for updates every second
setInterval(checkForUpdates, 1000);




            const moveCompletedToTasks = (task) => {
                task.completed = false;
                task.timestamp = new Date().toLocaleString();
                const existingTaskIndex = storedTasks.findIndex(t => t.text === task.text && t.timestamp === task.timestamp);
                if (existingTaskIndex === -1) {
                    storedTasks.push(task);
                }
                completedTasks = completedTasks.filter((t) => t !== task);
                updateLocalStorage();
                displayTasks();
                displayCompletedTasks();
            };

const addCategory = () => {
    const modal = document.getElementById('addCategoryModal');
    const closeBtn = modal.getElementsByClassName('close')[0];
    modal.style.display = "block";
    closeBtn.onclick = function () {
        modal.style.display = "none";
        document.getElementById('newCategoryInput').value = ''; // Clear the input box when modal is closed
    };
    window.onclick = function (event) {
        if (event.target == modal) {
            modal.style.display = "none";
            document.getElementById('newCategoryInput').value = ''; // Clear the input box when modal is closed
        }
    };
    const saveBtn = document.getElementById('saveNewCategory');
    saveBtn.onclick = function () {
        const newCategory = document.getElementById('newCategoryInput').value.trim();
        if (newCategory !== '' && !categories.includes(newCategory)) {
            categories.push(newCategory);
            updateLocalStorage();
            populateCategories();
            document.getElementById('newCategoryInput').value = ''; // Clear the input box after successfully adding the category
            modal.style.display = "none";
        } else {
            alert("Category already exists or no category found.");
        }
    };
};

const editCategory = () => {
    const selectedCategory = document.getElementById('categorySelect').value;
    if (selectedCategory.trim() !== '') {
        const modal = document.getElementById('editCategoryModal');
        const closeBtn = modal.getElementsByClassName('close')[0];
        const editInput = document.getElementById('editCategoryInput');
        editInput.value = selectedCategory; // Pre-fill input with current category name
        modal.style.display = "block";
        closeBtn.onclick = function () {
            modal.style.display = "none";
        };
        window.onclick = function (event) {
            if (event.target == modal) {
                modal.style.display = "none";
            }
        };
        const saveBtn = document.getElementById('saveEditedCategory');
        saveBtn.onclick = function () {
            const editedCategoryName = editInput.value.trim();
            if (editedCategoryName !== '' && selectedCategory !== '') {
                categories = categories.map(category => category === selectedCategory ? editedCategoryName : category);
                storedTasks.forEach(task => {
                    if (task.category === selectedCategory) {
                        task.category = editedCategoryName;
                    }
                });
                updateLocalStorage();
                populateCategories();
                displayTasks();
                modal.style.display = "none";
            } else {
                alert("Please enter a new category.");
            }
        };
    } else {
        alert("Please select a category to rename.");
    }
};

document.getElementById('editCategory').addEventListener('click', editCategory);

            const deleteCategory = () => {
                const selectedCategory = document.getElementById('categorySelect').value;
                if (selectedCategory.trim() !== '') {
                    if (confirm(`Are you sure you want to delete the category "${selectedCategory}"? This action cannot be undone.`)) {
                        categories = categories.filter(cat => cat !== selectedCategory);
                        updateLocalStorage();
                        populateCategories();
                    }
                } else {
                    alert("Please select a category to delete.");
                }
            };

            const viewAllTasks = () => {
                document.getElementById('categorySelect').selectedIndex = 0;
                displayTasks();
            };

            const viewUrgentTasks = () => {
    document.getElementById('categorySelect').selectedIndex = 0;
    const urgentTasks = storedTasks.filter(task => task.urgent && !task.completed);
    const taskList = document.getElementById('taskList');
    taskList.innerHTML = '';
    urgentTasks.forEach(task => {
        const listItem = document.createElement('li');
        listItem.classList.add('task', 'urgent');
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = task.completed;
        checkbox.addEventListener('change', () => {
            task.completed = checkbox.checked;
            updateLocalStorage();
            displayTasks();
            if (task.completed) {
                completedTasks.push(task);
                updateLocalStorage();
                displayCompletedTasks();
            }
        });
        listItem.appendChild(checkbox);

        // Information Column
        const infoColumn = document.createElement('div');
        infoColumn.classList.add('column');
        infoColumn.innerText = task.text;
        listItem.appendChild(infoColumn);



// Notes Column
const notesColumn = document.createElement('div');
notesColumn.classList.add('column', 'notes-column'); // Apply notes column styles

// Create a notebook icon that opens the note editor
const notebookIcon = document.createElement('span');
notebookIcon.classList.add('notebook-icon');
notebookIcon.innerHTML = '📝'; // You can use an emoji or FontAwesome icon here

// Find the task text from the adjacent info column
const taskText = infoColumn.textContent.trim();

// Add an event listener to open the note editor for this task
notebookIcon.addEventListener('click', () => {
    openNoteEditor(taskText);
});

// Append the notebook icon to the notes column
notesColumn.appendChild(notebookIcon);

// Append the notes column to the list item
listItem.appendChild(notesColumn);

// Function to open the note editor
function openNoteEditor(taskText) {
    // Ensure no duplicate popups
    document.querySelectorAll('.note-popup').forEach(popup => popup.remove());

    const notePopup = document.createElement('div');
    notePopup.classList.add('note-popup');

    // Create the close button (X)
    const closeButton = document.createElement('span');
    closeButton.classList.add('close-button');
    closeButton.innerHTML = '&#215;'; // The "X" symbol
    closeButton.addEventListener('click', () => {
        notePopup.remove(); // Close the popup when clicked
    });

    // Create the textarea for note entry
    const noteTextArea = document.createElement('textarea');
    noteTextArea.placeholder = 'Write your notes here...';

    // Retrieve the task dataset from localStorage
    let storedTasks = JSON.parse(localStorage.getItem('tasks')) || [];
    let task = storedTasks.find(t => t.text === taskText);

    // Load existing note if available
    if (task && task.note) {
        noteTextArea.value = task.note;
    }

    // Auto-save notes when the user types
    noteTextArea.addEventListener('input', () => {
        saveTaskNote(taskText, noteTextArea.value);
    });

    // Append elements to the popup
    notePopup.appendChild(closeButton);
    notePopup.appendChild(noteTextArea);
    document.body.appendChild(notePopup);

    // Apply basic popup styles inline
    Object.assign(notePopup.style, {
        position: 'fixed',
        top: '50%',
        left: '50%',
        transform: 'translate(-50%, -50%)',
        width: '40%',
        maxWidth: '90%',
        background: 'white',
        border: '1px solid #ccc',
        padding: '20px',
        zIndex: '1000',
        boxShadow: '0 4px 8px rgba(0, 0, 0, 0.1)',
    });
}

// Function to save notes inside the existing task dataset
function saveTaskNote(taskText, note) {
    let storedTasks = JSON.parse(localStorage.getItem('tasks')) || [];

    const taskIndex = storedTasks.findIndex(t => t.text === taskText);
    if (taskIndex !== -1) {
        storedTasks[taskIndex].note = note;
        localStorage.setItem('tasks', JSON.stringify(storedTasks));
    }
}



// Highlights Column with Color Selector for Each Task
const highlightsColumn = document.createElement('div');
highlightsColumn.classList.add('column');

// Create a select element for background color selection
const highlightSelect = document.createElement('select');
highlightSelect.classList.add('highlight-select');

// Define highlight color options (with color emojis)
const highlightColors = [
    { name: "Default", value: "#E0E0E0", emoji: "🩶" },
    { name: "Sky Blue", value: "#A0C4FF", emoji: "💙" },
    { name: "Soft Green", value: "#98D98E", emoji: "💚" },
    { name: "Golden Yellow", value: "#FFD700", emoji: "💛" },
    { name: "Warm Peach", value: "#FFB07C", emoji: "🧡" },
    { name: "Lilac", value: "#C8A2C8", emoji: "💜" },
    { name: "Teal", value: "#66B2B2", emoji: "💧" },
    { name: "Rose", value: "#E9747A", emoji: "🌹" }
];

// Function to retrieve saved highlight color from tasks dataset
function getTaskColor(taskText) {
    const tasks = JSON.parse(localStorage.getItem('tasks')) || [];
    const task = tasks.find(t => t.text === taskText);
    return task && task.colorCode ? task.colorCode : "#E0E0E0"; // Default to #E0E0E0 if no color is found
}

// Assign the saved color (if any) to the current task
const taskColor = getTaskColor(task.text); // Use Task Text as the unique identifier

// Add color options to the dropdown with color emojis
highlightColors.forEach(color => {
    const option = document.createElement('option');
    option.value = color.value;
    option.textContent = color.emoji;
    highlightSelect.appendChild(option);
});

// Set the current selected color based on the saved color for the task
highlightSelect.value = taskColor;

// Function to update the background color while respecting Urgent status
function updateTaskBackground() {
    if (task.urgent) {
        listItem.style.backgroundColor = "#FF4C4C"; // Urgent color always trumps
        highlightSelect.disabled = true; // Disable highlight selection for urgent tasks
    } else {
        listItem.style.backgroundColor = highlightSelect.value;
        highlightSelect.disabled = false; // Enable highlight selection for non-urgent tasks
    }
}

// Function to update task color in localStorage
function saveTaskColor(taskText, color) {
    let tasks = JSON.parse(localStorage.getItem('tasks')) || [];
    let taskIndex = tasks.findIndex(t => t.text === taskText);

    if (taskIndex !== -1) {
        if (color === "#E0E0E0") {
            delete tasks[taskIndex].colorCode; // Remove the property if default is selected
        } else {
            tasks[taskIndex].colorCode = color; // Assign new colorCode
        }
        localStorage.setItem('tasks', JSON.stringify(tasks));
    }
}

// Event listener for when a new highlight color is selected
highlightSelect.addEventListener('change', function () {
    const selectedColor = this.value;
    saveTaskColor(task.text, selectedColor); // Update the task object in localStorage
    updateTaskBackground(); // Apply the new color to the task
});

// Append the select element to the highlights column
highlightsColumn.appendChild(highlightSelect);
listItem.appendChild(highlightsColumn);

// Apply the background color update
updateTaskBackground();



// Priority Column with Dropdown
       // Create a container for the priority column
const priorityColumn = document.createElement('div');
priorityColumn.classList.add('column');

// Create a select element for priority levels
const prioritySelect = document.createElement('select');
prioritySelect.classList.add('priority-select');


// Add options to the select element for priorities 5 (highest) to 1 (lowest)
    [5, 4, 3, 2, 1].forEach(level => {
        const option = document.createElement('option');
        option.value = level;
        // Set the display text based on the priority level
        switch(level) {
            case 5:
                option.textContent = '🔥';
                break;
            case 4:
                option.textContent = '😬';
                break;
            case 3:
                option.textContent = '🚦';
                break;
            case 2:
                option.textContent = '🙏';
                break;
            case 1:
                option.textContent = '💚';
                break;
        }
        // Set the selected option based on the task's current priority, default to 3 if not set
        if ((task.priority && task.priority == level) || (!task.priority && level == 3)) {
            option.selected = true;
        }
        prioritySelect.appendChild(option);
    });

// Add an event listener to update the task's priority when a new option is selected
prioritySelect.addEventListener('change', function() {
    task.priority = parseInt(this.value); // Update the task's priority, ensuring it's an integer
    // Auto-sort by priority after changing the priority
        sortTasksByPriority();
updateLocalStorage(); // Save the updated tasks to local storage
    displayTasks(); // Refresh the displayed tasks
viewUrgentTasks(); // Reload the urgent tasks view

});

// Append the select element to the priority column
priorityColumn.appendChild(prioritySelect);

// Append the priority column to the list item
listItem.appendChild(priorityColumn);



// Urgency Column
const urgencyColumn = document.createElement('div');
urgencyColumn.classList.add('column');

// Create a label for the urgent checkbox
const urgentLabel = document.createElement('label');
const urgentText = document.createElement('span');
urgentText.innerText = 'Urgent';
urgentText.classList.add('urgent-text');

// Create the urgent checkbox
const urgentCheckbox = document.createElement('input');
urgentCheckbox.type = 'checkbox';
urgentCheckbox.checked = task.urgent; // Set the checkbox state based on the task's urgency

// Event listener to handle urgency toggling
urgentCheckbox.addEventListener('change', () => {
    task.urgent = urgentCheckbox.checked; // Update the task's urgency state
    updateLocalStorage(); // Save the updated task state to localStorage
    displayTasks(); // Refresh the displayed tasks
    viewUrgentTasks(); // Reload the urgent tasks view

    // Optionally, you can add a visual cue in the listItem to indicate urgency
    if (task.urgent) {
        listItem.classList.add('urgent'); // Add a class if the task is urgent
    } else {
        listItem.classList.remove('urgent'); // Remove the class if the task is not urgent
    }
});

// Append the checkbox and text to the label
urgentLabel.appendChild(urgentText);
urgentLabel.appendChild(urgentCheckbox);

// Append the urgency label to the urgency column
urgencyColumn.appendChild(urgentLabel);

// Append the urgency column to the list item
listItem.appendChild(urgencyColumn);

// Append the list item to the task list
taskList.appendChild(listItem);




// Deadline Column
// Add this to the code where the columns are created
const deadlineColumn = document.createElement('div');
deadlineColumn.classList.add('column');

const deadlineButton = document.createElement('button');
deadlineButton.innerHTML = '&#9200;';
deadlineButton.classList.add('deadline-button');

// Check if there's already a deadline set for the task
if (task.deadline) {
    deadlineButton.innerText = task.deadline;
    checkAndUpdateDeadline(task, deadlineButton); // Call the function to update the background color based on the deadline
}

// Event listener for setting the deadline
deadlineButton.addEventListener('click', () => {
    // Request notification permission
    if (Notification.permission === 'default') {
        Notification.requestPermission().then(permission => {
            if (permission === 'granted') {
                proceedWithDeadlineSetting();
            } else {
                alert('Notification permission is required to set deadlines.');
            }
        });
    } else if (Notification.permission === 'granted') {
        proceedWithDeadlineSetting();
    } else {
        alert('Notification permission is required to set deadlines.');
    }
});

deadlineColumn.appendChild(deadlineButton);
listItem.appendChild(deadlineColumn);

// Function to proceed with setting the deadline after notification permission is granted
function proceedWithDeadlineSetting() {
    const deadlineInput = prompt('Enter Deadline (yyyy-mm-dd hh:mm):', task.deadline || '');
    if (isValidDeadline(deadlineInput)) {
        const isAmending = task.deadline !== undefined;

        task.deadline = deadlineInput;
        updateLocalStorage();
        deadlineButton.innerText = task.deadline;
        checkAndUpdateDeadline(task, deadlineButton); // Update background color based on the deadline
        sortTasksByDeadline(); // Sort tasks by deadline after setting a new one

        // Cancel previous reminders before scheduling new ones
        cancelReminders(task);
        scheduleDeadlineReminders(task); // Schedule reminders for the deadline
        
        // Notify based on whether the deadline was set or amended
        notifyDeadlineChange(task, isAmending);
    } else {
        alert('Invalid deadline format. Please enter a valid date and time in the format yyyy-mm-dd hh:mm.');
    }
}

// Function to notify when the deadline is set or amended
function notifyDeadlineChange(task, isAmending) {
    if (!isAmending) {
        new Notification('Deadline Set', {
            body: `Deadline for task "${task.text}" has been set for ${task.deadline}.`,
            icon: 'https://freechecklistapp.com/freechecklistapplogo.jpg'
        });
    } else {
        new Notification('Deadline Amended', {
            body: `Deadline for task "${task.text}" has been amended to ${task.deadline}.`,
            icon: 'https://freechecklistapp.com/freechecklistapplogo.jpg'
        });
    }
}

// Function to check and update the background color and icon based on the deadline
function checkAndUpdateDeadline(task, buttonElement) {
    const deadline = new Date(task.deadline);
    const now = new Date();
    const timeDifference = deadline - now;
    const hoursDifference = timeDifference / (1000 * 60 * 60);

    if (deadline < now) {
        buttonElement.innerHTML = `${task.deadline} &#9888;&#65039;`; // Add red exclamation mark for expired deadline
        buttonElement.style.backgroundColor = 'red';
        buttonElement.style.color = 'white';
    } else if (hoursDifference <= 24) {
        buttonElement.innerHTML = `&#9200; ${task.deadline}`; // Keep the clock icon for upcoming deadlines within 24 hours
        buttonElement.style.backgroundColor = 'red';
        buttonElement.style.color = 'white';
    } else {
        buttonElement.innerHTML = `&#9200; ${task.deadline}`; // Keep the clock icon for deadlines more than 24 hours away
        buttonElement.style.backgroundColor = 'white';
        buttonElement.style.color = 'black';
    }
}

// Function to validate the deadline input
function isValidDeadline(deadlineInput) {
    const deadlineRegex = /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}$/;
    if (!deadlineInput || !deadlineRegex.test(deadlineInput)) {
        return false;
    }
    const date = new Date(deadlineInput);
    return date instanceof Date && !isNaN(date);
}

// Function to schedule reminders for the deadline
function scheduleDeadlineReminders(task) {
    const deadline = new Date(task.deadline);
    const now = new Date();

    // Clear previous reminders before scheduling new ones
    cancelReminders(task);

    const timeIntervals = [
        { label: '1 month', milliseconds: 30 * 24 * 60 * 60 * 1000 },
        { label: '2 weeks', milliseconds: 14 * 24 * 60 * 60 * 1000 },
        { label: '1 week', milliseconds: 7 * 24 * 60 * 60 * 1000 },
        { label: '5 days', milliseconds: 5 * 24 * 60 * 60 * 1000 },
        { label: '3 days', milliseconds: 3 * 24 * 60 * 60 * 1000 },
        { label: '1 day', milliseconds: 24 * 60 * 60 * 1000 },
        { label: '12 hours', milliseconds: 12 * 60 * 60 * 1000 },
        { label: '6 hours', milliseconds: 6 * 60 * 60 * 1000 },
        { label: '3 hours', milliseconds: 3 * 60 * 60 * 1000 },
        { label: '1 hour', milliseconds: 1 * 60 * 60 * 1000 },
    ];

    timeIntervals.forEach(interval => {
        const reminderTime = deadline - interval.milliseconds;
        if (reminderTime > now) {
            scheduleReminder(task, reminderTime, interval.label);
        }
    });
}

// Function to schedule a single reminder with double-check verification
function scheduleReminder(task, reminderTime, intervalLabel) {
    const now = new Date().getTime();
    const timeUntilReminder = reminderTime - now;

    // Only set a reminder if the time until the reminder is positive
    if (timeUntilReminder > 0) {
        const reminderId = setTimeout(() => {
            doubleCheckAndNotify(task, reminderTime, intervalLabel);
        }, timeUntilReminder);

        // Store the reminder ID in the task object for future reference
        if (!task.reminderIds) {
            task.reminderIds = [];
        }
        task.reminderIds.push(reminderId);
        updateLocalStorage();
    }
}

// Function to double-check and notify
function doubleCheckAndNotify(task, reminderTime, intervalLabel) {
    const checkInterval = 5000; // 5 seconds
    let checkCount = 0;
    const maxChecks = 3;

    const intervalId = setInterval(() => {
        const now = new Date().getTime();
        if (now >= reminderTime) {
            checkCount++;
            if (checkCount >= maxChecks) {
                clearInterval(intervalId);

                // Perform the final check before notifying
                if (!task.completed) {
                    new Notification('Deadline Reminder', {
                        body: `Task: ${task.text} is due in ${intervalLabel}!`,
                        icon: 'https://freechecklistapp.com/freechecklistapplogo.jpg', // Optional: Add an icon for the notification
                        tag: task.id // Use the task id to avoid duplicate notifications
                    });

                    // Update the task object and localStorage
                    updateLocalStorage();
                }
            }
        }
    }, checkInterval);
}

// Function to cancel all reminders for a task
function cancelReminders(task) {
    if (task.reminderIds) {
        task.reminderIds.forEach(id => clearTimeout(id));
        task.reminderIds = []; // Clear stored reminder IDs
        updateLocalStorage();
    }
}

// Example function to mark a task as completed and cancel its reminders
function markTaskAsCompleted(task) {
    task.completed = true;
    cancelReminders(task);
    updateLocalStorage();
    // Additional logic for marking the task as completed (e.g., updating the UI)
}


        
 // Edit Column
const editColumn = document.createElement('div');
editColumn.classList.add('column');
const editButton = document.createElement('button');
editButton.innerText = 'Edit';
editButton.classList.add('edit-button');
editButton.addEventListener('click', () => {
    // Edit task info
    const editedTaskText = prompt('Edit Task:', task.text);
    if (editedTaskText !== null && editedTaskText.trim() !== '') {
        task.text = editedTaskText.trim();
        updateLocalStorage();
        displayTasks(); // Update task list

        // Create modal for editing category
        const editCategoryModal = document.createElement('div');
        editCategoryModal.classList.add('modal');
        editCategoryModal.innerHTML = `
            <div class="modal-content">
                
                <p>Select a new Category:</p>
                <select id="editCategorySelect">
                    ${categories.map(category => `<option value="${category}" />${category}`).join('')}
                </select>
<br/>
<br/>               
<button id="saveEditedCategoryBtn">Save 💾</button>
                <button id="addNewCategoryBtn">🅰&#65039;Add New Category📂</button>


            </div>`;
        document.body.appendChild(editCategoryModal);
        editCategoryModal.style.display = "block";

        // Close modal when outside modal is clicked
        window.onclick = function (event) {
            if (event.target == editCategoryModal) {
                editCategoryModal.style.display = "none";
                document.body.removeChild(editCategoryModal);
            }
        };

        // Save edited category
        const saveEditedCategoryBtn = document.getElementById('saveEditedCategoryBtn');
        saveEditedCategoryBtn.onclick = () => {
            const selectedCategory = document.getElementById('editCategorySelect').value;
            if (selectedCategory !== '') {
                task.category = selectedCategory; // Update task's category
                updateLocalStorage(); // Update local storage with the edited category
                displayTasks(); // Update task list
                editCategoryModal.style.display = "none";
                document.body.removeChild(editCategoryModal);
            } else {
                alert("Please select a category.");
            }
        };

        // Add new category functionality
        const addNewCategoryBtn = document.getElementById('addNewCategoryBtn');
        addNewCategoryBtn.onclick = () => {
            const newCategoryName = prompt('Enter New Category:');
            if (newCategoryName !== null && newCategoryName.trim() !== '') {
                const newCategory = newCategoryName.trim();
                categories.push(newCategory);
                updateLocalStorage();
                populateCategories();
                task.category = newCategory; // Update task's category
                updateLocalStorage();
                displayTasks(); // Update task list
                editCategoryModal.style.display = "none";
                document.body.removeChild(editCategoryModal);
            }
        };
    }
});
editColumn.appendChild(editButton);
listItem.appendChild(editColumn);

            // Delete Column
const deleteColumn = document.createElement('div');
deleteColumn.classList.add('column');
const deleteButton = document.createElement('button');
deleteButton.innerText = 'Delete';
deleteButton.classList.add('delete-button');
deleteButton.addEventListener('click', () => {
    // Prompt user to confirm deletion
    const confirmDelete = confirm('Are you sure you want to delete this task?');
    if (confirmDelete) {
        // Delete task from storedTasks array
        const taskIndex = storedTasks.indexOf(task);
        if (taskIndex !== -1) {
            storedTasks.splice(taskIndex, 1);
            updateLocalStorage();
            displayTasks(); // Update task list
        }
    }
});
deleteColumn.appendChild(deleteButton);
listItem.appendChild(deleteColumn);


// Select Column
        const selectColumn = document.createElement('div');
        selectColumn.classList.add('column');
        const selectCheckbox = document.createElement('input');
        selectCheckbox.type = 'checkbox';
        selectCheckbox.checked = task.select;
        selectCheckbox.addEventListener('change', () => {
            task.select = selectCheckbox.checked;
            updateLocalStorage();
        });
        const selectLabel = document.createElement('label');
        selectLabel.innerText = 'Select';
        selectLabel.appendChild(selectCheckbox);
        selectColumn.appendChild(selectLabel);
        listItem.appendChild(selectColumn);


        // Category Column
        const categoryColumn = document.createElement('div');
        categoryColumn.classList.add('column');
        categoryColumn.innerText = task.category;
        listItem.appendChild(categoryColumn);


// Date and Time Column
        const timestampColumn = document.createElement('div');
        timestampColumn.classList.add('column');
        timestampColumn.innerText = task.timestamp;
        listItem.appendChild(timestampColumn);




// Function to update local storage
const updatelocalStorage = () => {
    localStorage.setItem('tasks', JSON.stringify(storedTasks));
};

// Ensure the tasks are loaded and displayed on page load
document.addEventListener('DOMContentLoaded', () => {
    if (localStorage.getItem('tasks')) {
        storedTasks = JSON.parse(localStorage.getItem('tasks'));
    }
    displayTasks();
});



// Select all columns inside listItem
const columns = listItem.querySelectorAll('.column');

if (columns.length > 0) {
    // Create a wrapper for the infoColumn, which will be the first row
    const infoRow = document.createElement('div');
    infoRow.classList.add('info-row');

    // Move the first column (infoColumn) into infoRow
    infoRow.appendChild(columns[0]);
    
    // Insert the infoRow as the first row inside listItem
    listItem.prepend(infoRow);

    if (columns.length > 1) {
        // Create a wrapper for the other columns, which will be the second row
        const detailsRow = document.createElement('div');
        detailsRow.classList.add('details-row');

        // Move all columns except the first one into detailsRow
        for (let i = 1; i < columns.length; i++) {
            detailsRow.appendChild(columns[i]);
        }

        // Append the new row to listItem
        listItem.appendChild(detailsRow);
    }
}
      
        



        // Add horizontal line after each task
        taskList.appendChild(document.createElement('hr'));
    });
};

             const populateCategories = () => {
                const select = document.getElementById('categorySelect');
                select.innerHTML = '<option value="" />📑Category🗃&#65039;'; // Reset dropdown
                categories.forEach(category => {
                    const option = document.createElement('option');
                    option.text = category;
                    option.value = category;
                    select.add(option);
                });
            };



            populateCategories(); // Populate category dropdown initially
            displayTasks();
            displayCompletedTasks();

            document.getElementById('addTask').addEventListener('click', addTask);
            document.getElementById('clearCompleted').addEventListener('click', clearCompleted);
            document.getElementById('addCategory').addEventListener('click', addCategory);
            document.getElementById('deleteCategory').addEventListener('click', deleteCategory);
            document.getElementById('viewAllTasks').addEventListener('click', viewAllTasks);
            document.getElementById('viewUrgentTasks').addEventListener('click', viewUrgentTasks);

            document.getElementById('newTask').addEventListener('keyup', function (event) {
                if (event.key === "Enter") {
                    addTask();
                }
            });

            document.getElementById('categorySelect').addEventListener('change', displayTasks); // Update tasks when category selection changes

            document.getElementById('shareSelectedTasks').addEventListener('click', shareSelectedTasks); // Share selected tasks button click event

            document.getElementById('pasteTasks').addEventListener('click', () => {
                const pasteModal = document.getElementById('pasteModal');
                const closeBtn = pasteModal.getElementsByClassName('close')[0];
                pasteModal.style.display = "block";
                closeBtn.onclick = function () {
                    pasteModal.style.display = "none";
                };
                window.onclick = function (event) {
                    if (event.target == pasteModal) {
                        pasteModal.style.display = "none";
                    }
                };
            });

            document.getElementById('confirmPaste').addEventListener('click', () => {
                const pastedTasks = document.getElementById('pastedTasks').value.trim();
                if (pastedTasks !== '') {
                    processPastedTasks(pastedTasks);
                    document.getElementById('pastedTasks').value = '';
                } else {
                    alert("Please paste tasks.");
                }
            });

            





 // Function to share selected tasks
function shareSelectedTasks() {
    const selectedTasks = storedTasks.filter(task => task.select && !task.completed); // Filter selected and active tasks
    let sharedList = 'Compiled Tasks:\n';
    
    selectedTasks.forEach(task => {
        const isUrgent = task.urgent ? 'Yes' : 'No'; // Check if task is urgent
        const deadline = task.deadline ? task.deadline : 'No deadline'; // Check if deadline is set
        const priority = task.priority ? task.priority : 'Not set';        
        
        // Fetch the corresponding note for the task from the 'note' dataset
        const taskNote = task.note ? task.note : 'No notes'; // Check if task has a note, otherwise display 'No notes'

        sharedList += `- ${task.text} (Category: ${task.category}, Urgent: ${isUrgent}, Deadline: ${deadline}, Priority: ${priority}, Notes: ${taskNote})\n`; // Include urgent, deadline, priority, and notes
    });

    sharedList += '\nwww.freechecklistapp.com'; // Add website link
    copyTextToClipboard(sharedList); // Copy generated list to clipboard
    alert("Selected tasks have been copied to clipboard."); // Inform user
    
    // Clear the selection of tasks and refresh checkboxes
    storedTasks.forEach(task => {
        task.select = false;
    });
    updateLocalStorage(); // Update local storage
    displayTasks(); // Refresh task display
    
    // Uncheck the "Select All" checkbox after sharing
    document.getElementById('selectAllTasks').checked = false;
}

document.getElementById('shareSelectedTasks').addEventListener('click', shareSelectedTasks); // Share selected tasks button click event

// Function to process pasted tasks
function processPastedTasks(pastedTasks) {
    const lines = pastedTasks.split('\n');
    const newTasks = [];
    const existingCategories = categories.slice(); // Create a copy of categories array
    const renamedCategories = {}; // Object to keep track of renamed categories
    const processedCategories = new Set(); // Set to store categories that have been processed

    lines.forEach(line => {
        const parts = line.split('(Category: ');
        if (parts.length === 2) {
            const taskText = parts[0].trim();
            let category = parts[1].split(',')[0].trim(); // Extract category name
            category = category.replace(/[^a-zA-Z0-9 ]/g, ''); // Remove non-alphanumeric characters
            category = category.trim(); // Trim any leading or trailing whitespace
            const urgent = parts[1].includes('Urgent: Yes');
            
            // Extract the deadline from the pasted text
            const deadlineMatch = parts[1].match(/Deadline: ([^,]+)/);
            const deadline = deadlineMatch && deadlineMatch[1].trim() !== 'No deadline' ? deadlineMatch[1].trim() : null;

            // Extract the priority from the pasted text
            const priorityMatch = parts[1].match(/Priority: (\d+)/);
            const priority = priorityMatch ? parseInt(priorityMatch[1].trim(), 10) : null;

            // Extract the note from the pasted text (if available)
            const noteMatch = parts[1].match(/Notes: ([^\n]+)/);
            const note = noteMatch ? noteMatch[1].trim() : '';

            if (taskText !== '' && category !== '') {
                if (!processedCategories.has(category)) {
                    const existingCategoryIndex = existingCategories.findIndex(cat => cat.replace(/[^a-zA-Z0-9]/g, '').toLowerCase() === category.replace(/[^a-zA-Z0-9]/g, '').toLowerCase());
                    if (existingCategoryIndex !== -1) {
                        const tasksUnderCategory = lines.filter(task => task.replace(/[^a-zA-Z0-9]/g, '').toLowerCase().includes(category.replace(/[^a-zA-Z0-9]/g, '').toLowerCase())).length > 0;
                        if (tasksUnderCategory) {
                            const addToExisting = confirm(`Category "${existingCategories[existingCategoryIndex]}" already exists. Do you want to paste tasks in category "${existingCategories[existingCategoryIndex]}"?`);
                            processedCategories.add(category);
                            if (addToExisting) {
                                lines.forEach(line => {
                                    const parts = line.split('(Category: ');
                                    if (parts.length === 2) {
                                        const taskText = parts[0].trim();
                                        const taskCategory = parts[1].split(',')[0].trim();
                                        const urgent = parts[1].includes('Urgent: Yes');
                                        const deadlineMatch = parts[1].match(/Deadline: ([^,]+)/);
                                        const deadline = deadlineMatch && deadlineMatch[1].trim() !== 'No deadline' ? deadlineMatch[1].trim() : null;
                                        const priorityMatch = parts[1].match(/Priority: (\d+)/);
                                        const priority = priorityMatch ? parseInt(priorityMatch[1].trim(), 10) : null;

                                        if (taskCategory.replace(/[^a-zA-Z0-9]/g, '').toLowerCase() === category.replace(/[^a-zA-Z0-9]/g, '').toLowerCase()) {
                                            const newTask = {
                                                text: taskText,
                                                category: existingCategories[existingCategoryIndex],
                                                completed: false,
                                                urgent: urgent,
                                                select: false,
                                                timestamp: new Date().toLocaleString(),
                                                note: note // Store the note from the pasted task
                                            };

                                            if (deadline) {
                                                newTask.deadline = deadline;
                                            }

                                            if (priority !== null) {
                                                newTask.priority = priority;
                                            }

                                            newTasks.push(newTask);
                                        }
                                    }
                                });
                            } else {
                                const newCategoryName = prompt(`Enter a new category for tasks under category "${existingCategories[existingCategoryIndex]}":`);
                                if (newCategoryName !== null && newCategoryName.trim() !== '') {
                                    const newCategory = newCategoryName.trim();
                                    lines.forEach(line => {
                                        const parts = line.split('(Category: ');
                                        if (parts.length === 2) {
                                            const taskText = parts[0].trim();
                                            const taskCategory = parts[1].split(',')[0].trim();
                                            const urgent = parts[1].includes('Urgent: Yes');
                                            const deadlineMatch = parts[1].match(/Deadline: ([^,]+)/);
                                            const deadline = deadlineMatch && deadlineMatch[1].trim() !== 'No deadline' ? deadlineMatch[1].trim() : null;
                                            const priorityMatch = parts[1].match(/Priority: (\d+)/);
                                            const priority = priorityMatch ? parseInt(priorityMatch[1].trim(), 10) : null;

                                            if (taskCategory.replace(/[^a-zA-Z0-9]/g, '').toLowerCase() === category.replace(/[^a-zA-Z0-9]/g, '').toLowerCase()) {
                                                const newTask = {
                                                    text: taskText,
                                                    category: newCategory,
                                                    completed: false,
                                                    urgent: urgent,
                                                    select: false,
                                                    timestamp: new Date().toLocaleString(),
                                                    note: note // Store the note from the pasted task
                                                };

                                                if (deadline) {
                                                    newTask.deadline = deadline;
                                                }

                                                if (priority !== null) {
                                                    newTask.priority = priority;
                                                }

                                                newTasks.push(newTask);
                                            }
                                        }
                                    });
                                    existingCategories.push(newCategory);
                                    renamedCategories[category] = newCategory;
                                }
                            }
                        }
                    } else {
                        lines.forEach(line => {
                            const parts = line.split('(Category: ');
                            if (parts.length === 2) {
                                const taskText = parts[0].trim();
                                const taskCategory = parts[1].split(',')[0].trim();
                                const urgent = parts[1].includes('Urgent: Yes');
                                const deadlineMatch = parts[1].match(/Deadline: ([^,]+)/);
                                const deadline = deadlineMatch && deadlineMatch[1].trim() !== 'No deadline' ? deadlineMatch[1].trim() : null;
                                const priorityMatch = parts[1].match(/Priority: (\d+)/);
                                const priority = priorityMatch ? parseInt(priorityMatch[1].trim(), 10) : null;

                                if (taskCategory.replace(/[^a-zA-Z0-9]/g, '').toLowerCase() === category.replace(/[^a-zA-Z0-9]/g, '').toLowerCase()) {
                                    const newTask = {
                                        text: taskText,
                                        category: category,
                                        completed: false,
                                        urgent: urgent,
                                        select: false,
                                        timestamp: new Date().toLocaleString(),
                                        note: note // Store the note from the pasted task
                                    };

                                    if (deadline) {
                                        newTask.deadline = deadline;
                                    }

                                    if (priority !== null) {
                                        newTask.priority = priority;
                                    }

                                    newTasks.push(newTask);
                                }
                            }
                        });
                        existingCategories.push(category);
                    }
                    processedCategories.add(category);
                }
            }
        }
    });

    // Adjust category names for tasks with renamed categories
    newTasks.forEach(task => {
        if (task.category in renamedCategories) {
            task.category = renamedCategories[task.category];
        }
    });

    storedTasks = storedTasks.concat(newTasks);
    updateLocalStorage();
    categories = existingCategories; // Update categories array
    populateCategories(); // Update the category dropdown
    displayTasks();

    // Close the paste modal after processing the tasks
    const pasteModal = document.getElementById('pasteModal');
    pasteModal.style.display = "none";
}




  

// Function to share completed tasks
const shareCompletedTasks = () => {
    let completedTasksText = "Completed Tasks:\n";
    completedTasks.forEach(task => {
        let taskText = `- ${task.text} (Category: ${task.category}, Started: ${task.timestamp})`;
        if (task.urgent) {
            taskText += " (Was Urgent)";
        }
        completedTasksText += taskText + "\n";
    });
    
completedTasksText += '\nwww.freechecklistapp.com'; // Add website link

copyTextToClipboard(completedTasksText);
    alert("Completed tasks have been copied to clipboard.");
};

// Add event listener for the "Share Completed Tasks" button
    document.getElementById('shareCompletedTasks').addEventListener('click', shareCompletedTasks);


            // Function to copy text to clipboard
            function copyTextToClipboard(text) {
                const textArea = document.createElement("textarea"); // Create a textarea element
                textArea.value = text; // Set its value to the text to be copied
                document.body.appendChild(textArea); // Append textarea to document body
                textArea.select(); // Select the text
                document.execCommand("copy"); // Execute copy command
                document.body.removeChild(textArea); // Remove textarea
            }
        } else {
            alert("Sorry, your browser does not support local storage.");
        }




// Get elements
const modal = document.getElementById('categoryModal');
const showModalButton = document.getElementById('showModal');
const closeButton = document.querySelector('.close');
const addCategoryButton = document.getElementById('addCategory');
const editCategoryButton = document.getElementById('editCategory');
const deleteCategoryButton = document.getElementById('deleteCategory');

// Function to close the modal
function closeModal() {
    modal.style.display = 'none';
}

// Show the modal
showModalButton.addEventListener('click', () => {
    modal.style.display = 'block';
});

// Hide the modal
closeButton.addEventListener('click', closeModal);

// Hide the modal when clicking outside of it
window.addEventListener('click', (event) => {
    if (event.target === modal) {
        closeModal();
    }
});

// Add event listeners to the action buttons
addCategoryButton.addEventListener('click', () => {
    // Your code to add a category here
    // After action is completed
    closeModal();
});

editCategoryButton.addEventListener('click', () => {
    // Your code to edit a category here
    // After action is completed
    closeModal();
});

deleteCategoryButton.addEventListener('click', () => {
    // Your code to delete a category here
    // After action is completed
    closeModal();
});




// Function to check and update deadline status
const updateDeadlineStatus = (button, deadline) => {
    if (deadline) {
        const now = new Date();
        const deadlineDate = new Date(deadline);
        if (now > deadlineDate) {
            button.classList.add('expired');
        } else {
            button.classList.remove('expired');
        }
    } else {
        button.classList.remove('expired');
    }
};

// Example of how you might call this function
const updateDeadlineDisplay = () => {
    const deadlineButtons = document.querySelectorAll('.deadline-button');
    deadlineButtons.forEach(button => {
        const deadline = button.getAttribute('data-deadline'); // Example attribute where deadline is stored
        updateDeadlineStatus(button, deadline);
    });
};

// Call this function whenever you need to check and update deadline statuses
updateDeadlineDisplay();


// Function to log deleted task text
function logTaskDeletion(taskText) {
    let deletionLog = JSON.parse(localStorage.getItem('deletion-log')) || [];
    deletionLog.push(taskText);
    localStorage.setItem('deletion-log', JSON.stringify(deletionLog));
    console.log('Task text logged:', taskText);
}


// Function to clear the deletion log
function clearDeletionLog() {
    localStorage.removeItem('deletion-log'); // Clear the log
    console.log('Deletion log has been cleared.');
}

// Function to update the last cleared date
function updateLastClearedDate() {
    const currentDate = new Date().toISOString(); // Get current date in ISO format
    localStorage.setItem('last-cleared-date', currentDate);
}

// Function to check and clear the log if a month has passed
function checkAndClearLogMonthly() {
    const lastClearedDate = localStorage.getItem('last-cleared-date');
    const currentDate = new Date();
    
    if (lastClearedDate) {
        const lastDate = new Date(lastClearedDate);
        const timeDifference = currentDate - lastDate; // Difference in milliseconds
        const oneMonthInMilliseconds = 30 * 24 * 60 * 60 * 1000; // Approximate milliseconds in a month
        
        if (timeDifference >= oneMonthInMilliseconds) {
            clearDeletionLog();
            updateLastClearedDate(); // Update last cleared date after clearing
        }
    } else {
        // If there's no record of last cleared date, clear the log and set the date
        clearDeletionLog();
        updateLastClearedDate();
    }
}

document.addEventListener('DOMContentLoaded', function () {
    checkAndClearLogMonthly(); // Check and clear the log when the page loads
});

// Optionally, run this check daily
setInterval(checkAndClearLogMonthly, 24 * 60 * 60 * 1000); // Check once a day


// Function to periodically check for updates in categories
function checkAndUpdateCategories() {
    const checkInterval = 1000; // Interval in milliseconds (1 second)

    setInterval(() => {
        // Retrieve categories from localStorage
        const storedCategoriesString = localStorage.getItem('categories');
        const storedCategories = storedCategoriesString ? JSON.parse(storedCategoriesString) : [];

        // Retrieve categories currently populated in the menu
        const existingCategories = Array.from(document.querySelectorAll('#categoriesMenu option')).map(option => option.textContent.trim());

        // Log the retrieved and existing categories for debugging
        console.log('Stored Categories:', storedCategories);
        console.log('Existing Categories in Menu:', existingCategories);

        // Find new categories that are in localStorage but not in the menu
        const newCategories = storedCategories.filter(category => !existingCategories.includes(category));

        // Log the new categories for debugging
        console.log('New Categories Found:', newCategories);

        if (newCategories.length > 0) {
            // If new categories are found, update the categories and refresh the menu
            console.log('Updating categories...');
            populateCategories(); // Call function to update categories menu
            storedTasks.forEach(task => {
                if (newCategories.includes(task.category)) {
                    task.category = task.category; // Update task's category if necessary
                }
            });
            updateLocalStorage(); // Save updated task categories to localStorage
            displayTasks(); // Refresh task display
        }
    }, checkInterval);
}

// Call the function to start periodically checking for category updates
checkAndUpdateCategories();



 document.addEventListener('DOMContentLoaded', function () {
    // Function to create HTML content from tasks
    function generateTasksHTML(tasks) {
        let htmlContent = '<html><head><style>';
        htmlContent += 'body { font-family: Arial, sans-serif; margin: 0; padding: 0; }';
        htmlContent += '.task { border-bottom: 1px solid #ddd; padding: 10px; }';
        htmlContent += '.task-title { font-size: 18px; font-weight: bold; margin-bottom: 5px; }';
        htmlContent += '.task-details { font-size: 14px; margin-bottom: 5px; }';
        htmlContent += '.urgent { color: red; font-weight: bold; }';
        htmlContent += '.completed { text-decoration: line-through; color: gray; }';
        htmlContent += '</style></head><body>';
        tasks.forEach(task => {
            htmlContent += `<div class="task ${task.completed ? 'completed' : ''}">`;
            htmlContent += `<div class="task-title">${task.text || 'Untitled Task'}</div>`;
            if (task.urgent) {
                htmlContent += `<div class="task-details urgent">Urgent</div>`;
            }
            if (task.deadline) {
                htmlContent += `<div class="task-details">Deadline: ${task.deadline}</div>`;
            }
            if (task.category) {
                htmlContent += `<div class="task-details">Category: ${task.category}</div>`;
            }
            htmlContent += `<div class="task-details">Priority: ${getPriorityText(task.priority)}</div>`;
            htmlContent += '</div>';
        });
        htmlContent += '</body></html>';
        return htmlContent;
    }

    // Function to map priority level to text
    function getPriorityText(level) {
        switch(level) {
            case 5:
                return '🔥';
            case 4:
                return '😬';
            case 3:
                return '🚦';
            case 2:
                return '🙏';
            case 1:
                return '💚';
            default:
                return '🚦'; // Default to priority 3 if not set
        }
    }

    // Function to display tasks in the iframe
    function displayTasksInIframe() {
        const tasks = JSON.parse(localStorage.getItem('tasks')) || [];
        const iframe = document.getElementById('tasksIframe');
        const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
        iframeDoc.open();
        iframeDoc.write(generateTasksHTML(tasks));
        iframeDoc.close();
    }

    // Event listener for the "Show All Tasks" button
    document.getElementById('displayTasks').addEventListener('click', function () {
        displayTasksInIframe();
        document.getElementById('tasksModal').style.display = 'block';
        startAutoUpdate(); // Start auto-updating the iframe when modal is opened
    });

    // Event listener for closing the modal
    document.querySelector('#tasksModal .close').addEventListener('click', function () {
        document.getElementById('tasksModal').style.display = 'none';
        stopAutoUpdate(); // Stop auto-updating the iframe when modal is closed
    });

    // Interval ID for auto-updating
    let updateIntervalId;

    // Function to start auto-updating the iframe
    function startAutoUpdate() {
        updateIntervalId = setInterval(displayTasksInIframe, 5000); // Update every 5 seconds
    }

    // Function to stop auto-updating the iframe
    function stopAutoUpdate() {
        clearInterval(updateIntervalId);
    }
});




const defaultTasks = [
    {
        id: 'task1',
        text: '🎉Greetings! 🥳Get Started with Free Checklist App&#8482;&#65039;!&#9854;&#65039;',
        category: 'Welcome🪔',
        completed: false,
        timestamp: '2021-12-07 16:20',
        reminderIds: []
    },

    {
        id: 'task2',
        text: '🗃&#65039;Organize, 🥇Prioritize, 🔔Set Reminders, 🤝Collaborate and 🥳Stay Productive!💡',
        category: 'Welcome🪔',
        completed: false,
        timestamp: '2021-12-07 16:20',
        reminderIds: []
    },

    {
        id: 'task3',
        text: '🌚Explore🔭 all the features📲 and functionality🎛&#65039;! We Support 98 Different Languages🔠!',
        category: 'Welcome🪔',
        completed: false,
        timestamp: '2021-12-07 16:20',
        reminderIds: []
    },

    // Add more default tasks as needed
];
function initializeDefaultTasks() {
    const storedTasks = JSON.parse(localStorage.getItem('tasks')) || [];
    if (storedTasks.length === 0) {
        defaultTasks.forEach(task => {
            storedTasks.push(task);
        });
        localStorage.setItem('tasks', JSON.stringify(storedTasks));
    }
}

function loadTasks() {
    const storedTasks = JSON.parse(localStorage.getItem('tasks')) || [];
    storedTasks.forEach(task => {
        displayTask(task);
    });
}

function displayTask(task) {
    const listItem = document.createElement('div');
    listItem.classList.add('task-item');

    const taskText = document.createElement('div');
    taskText.textContent = task.text;
    listItem.appendChild(taskText);

    const taskCategory = document.createElement('div');
    taskCategory.textContent = task.category;
    listItem.appendChild(taskCategory);

    const taskTimestamp = document.createElement('div');
    taskTimestamp.textContent = task.timestamp;
    listItem.appendChild(taskTimestamp);

    document.getElementById('taskListContainer').appendChild(listItem);
}

document.addEventListener('DOMContentLoaded', () => {
    initializeDefaultTasks();
    loadTasks();
    // Other initialization code
});




// Set Reminder Function with Google Calendar Integration for Multiple Tasks
document.addEventListener('DOMContentLoaded', function () {
    document.getElementById('setReminder').addEventListener('click', function () {
        const storedTasks = JSON.parse(localStorage.getItem('tasks')) || [];
        const selectedTasks = storedTasks.filter(task => task.select && !task.completed);

        if (selectedTasks.length === 0) {
            alert('Please select at least one task to set a reminder.');
            return;
        }

        // Prompt user for reminder date and time
        const reminderDateTime = prompt('Enter the date and time for the reminder (YYYY-MM-DD HH:MM format):');
        if (!reminderDateTime) return;

        const reminderTimestamp = Date.parse(reminderDateTime);
        if (isNaN(reminderTimestamp)) {
            alert('Invalid date/time format. Please enter in YYYY-MM-DD HH:MM format.');
            return;
        }

        // Compile selected tasks into a formatted list
        let taskDetails = 'Tasks for Reminder:\n';
        selectedTasks.forEach((task, index) => {
            const isUrgent = task.urgent ? 'Yes' : 'No';
            const deadline = task.deadline ? task.deadline : 'No deadline';
            const priority = task.priority ? task.priority : 'Not set';
            taskDetails += `${index + 1}. ${task.text} (Category: ${task.category}, Urgent: ${isUrgent}, Deadline: ${deadline}, Priority: ${priority})\n`;
        });

        // Generate Google Calendar event link
        const formattedDate = new Date(reminderTimestamp).toISOString().replace(/-|:|\.\d+/g, '');
        const googleCalendarURL = `https://calendar.google.com/calendar/u/0/r/eventedit?dates=${formattedDate}/${formattedDate}&details=${encodeURIComponent(taskDetails)}&text=Task Reminder`;

        // Display task details and Google Calendar link
        alert(`Reminder Information:\n${taskDetails}\n\nClick OK to add this to Google Calendar.`);
        window.open(googleCalendarURL, '_blank');

        // Uncheck the "Select All" checkbox after sharing the reminder
        document.getElementById('selectAllTasks').checked = false;

        // Deselect all tasks that were selected
        storedTasks.forEach(task => {
            task.select = false;  // Deselect tasks
        });
        
        // Save the updated tasks to localStorage
        localStorage.setItem('tasks', JSON.stringify(storedTasks));
    });
});




  const messageBoard = document.getElementById('messageBoard');
  const messageText = document.getElementById('messageText');
  const defaultMessage = "IMPORTANT NOTICE: 100% Device📲 Centric Storage!🙂 We do not store any user data in servers or have any access to it!💯 All data is stored locally in YOUR device!💻 All data is stored on your end and your security is your responsibility on the internet. Only when a reminder is set, the task is handed over to Google Calendar.💻 Greetings  🎆and a Warm Welcome🎉 from our team at 🪔Free Checklist App!💡You can Click/Tap to edit this message!📝 This is your Whiteboard!🪧 Reminder: If you need to reset categories and completed tasks easily, simply download the default tasks via incognito mode and use that as a Clean Installation file. 👓 Categories and completed tasks are user protected by nature and require multiple uploads to restore/update, and a Factory Reset to clear. 🧶WARNING🔴: Since accessed via browser, clearing browser data🚮 will result in data loss🚮. Please download👇 and backup👇 before browser reset. 🥸- Chief ";

  // Load saved message or use default
  function loadMessage() {
    const savedMessage = localStorage.getItem('chalkboardMessage') || defaultMessage;
    messageText.textContent = savedMessage;
    setMarqueeSpeed();
  }

  // Set the animation speed based on message width
  function setMarqueeSpeed() {
    const messageWidth = messageText.scrollWidth;
    const speed = 50; // Speed in pixels per second
    const duration = messageWidth / speed;

    messageText.style.animationDuration = `${duration}s`;
  }

  // Handle click to edit message
  messageBoard.addEventListener('click', () => {
    const currentMessage = localStorage.getItem('chalkboardMessage') || messageText.textContent;
    const newMessage = prompt('Enter your new message:', currentMessage);

    if (newMessage !== null) {
      if (newMessage.trim() === '') {
        localStorage.setItem('chalkboardMessage', defaultMessage);
        messageText.textContent = defaultMessage;
      } else {
        localStorage.setItem('chalkboardMessage', newMessage);
        messageText.textContent = newMessage;
      }
      setMarqueeSpeed(); // Update speed after message change
    }
  });

  // Initialize
  loadMessage();



function updateClock() {
        const clockElement = document.getElementById('clock');
        const now = new Date();
        clockElement.innerText = now.toLocaleTimeString();
    }

    setInterval(updateClock, 1000);
    updateClock();



</script>








    

</!doctype>
</div>
<div class='clear'></div>
</div></div>
<div class='tabs section' id='crosscol-overflow' name='Cross-Column 2'><div class='widget HTML' data-version='1' id='HTML2'>
<div class='widget-content'>
<!doctype html>


  
  
  
  <style>


#linkContainer {
    text-align: center;
    padding: 10px;
}

#linkContainer a {
    font-size: 1rem;
    color: #007bff;
    text-decoration: none;
    font-family: 'Arial', sans-serif;
    padding: 10px 20px;
    border: 2px solid #007bff;
    border-radius: 8px;
    transition: all 0.3s ease;
}

#linkContainer a:hover {
    background-color: #007bff;
    color: #fff;
    cursor: pointer;
}



/* Style for the main heading */
h1 {
    font-size: 2.5rem;
    font-family: 'Georgia', sans-serif;
    text-align: center;
    color: #333; /* Dark grey */
    padding: 10px;
    display: inline-block;
}

/* Style for the subheading */
h3 {
    font-size: 1.8rem;
    font-family: 'Georgia', sans-serif;
    text-align: center;
    color: #333; /* Dark grey */
    padding: 8px;
    display: inline-block;
}



/* General button styling */
#forceSync, #copyPeerId, #resetPeerId, #addPeer, #disconnectAllPeers, #connectAllPeers {
    font-size: 16px; /* Adjust font size */
    padding: 12px 20px; /* Adjust button size with padding */
    border-radius: 8px; /* Rounded corners */
    border: 2px solid #ccc; /* Border style */
    background-color: #f0f0f0; /* Light background */
    color: #333; /* Text color */
    cursor: pointer; /* Pointer on hover */
    margin: 10px 5px; /* Spacing around buttons */
    transition: background-color 0.3s ease, transform 0.3s ease; /* Smooth transition */
}

/* Hover effect */
#forceSync:hover, #copyPeerId:hover, #resetPeerId:hover, #addPeer:hover, #disconnectAllPeers:hover, #connectAllPeers:hover {
    background-color: #e0e0e0; /* Change background on hover */
    transform: scale(1.05); /* Slightly enlarge on hover */
}

/* Disabled button styling */
#disconnectAllPeers:disabled, #connectAllPeers:disabled {
    background-color: #ddd; /* Grey out disabled buttons */
    color: #888;
    cursor: not-allowed;
    transform: none;
}

/* Peer ID display */
#peerId {
    font-weight: bold;
    font-size: 18px;
    color: #444;
}

/* Input field styling */
#remotePeerId {
    font-size: 16px;
    padding: 10px;
    border: 2px solid #ccc;
    border-radius: 8px;
    width: 300px;
    margin: 10px 5px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    outline: none;
}

#remotePeerId:focus {
    border-color: #007bff;
    box-shadow: 0 0 8px rgba(0, 123, 255, 0.3);
}




    #peerListContainer {
      margin-top: 20px;
    }

    #peerList {
      list-style-type: none;
      padding: 0;
    }

    #peerList li {
      margin-bottom: 10px;
    }

    #peerList button {
      margin-left: 10px;
    }

    .disconnected {
      color: red;
    }

    .connected {
      color: green;
    }

    .peer-id-container {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .peer-id-container button {
      margin: 0;
    }


  </style>


  <h1>👩&#8205;💻 Peer Sync🔄 (beta&#10160;)</h1>

<div id="linkContainer">
    <a href="https://www.freechecklistapp.com/p/learn-to-setup-and-use-peer-sync.html" target="_blank">🌐 Learn to Setup and Use 🚀</a>
</div>


  <p id="status">Initializing...</p>

  <div class="peer-id-container">
<button id="forceSync">🪛Force Sync🔌</button>
   
<span>Your Peer ID: <span id="peerId">N/A</span></span>
    <button id="copyPeerId">&#10175;Copy Peer📡 ID</button>
    <button id="resetPeerId">&#9851;&#65039;Reset Peer📡 ID</button>
  </div>
  <input type="text" id="remotePeerId" placeholder="&#10133;Enter Remote📶 Peer ID🧑&#8205;💻📡📲" />
  <button id="addPeer">&#10133;Add Peer🧑&#8205;💻</button>

  <div id="peerListContainer">
    <h3>📡Connected Peers👥</h3>
    <ul id="peerList"></ul>
    <button id="disconnectAllPeers" disabled>🔃Refresh All Peers👩&#8205;💻</button>
    <button id="connectAllPeers" disabled>📶Connect All Peers📲</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/peerjs@1.3.2/dist/peerjs.min.js"></script>
  <script>
   let peer;
let connections = {}; // Store multiple connections
let storedPeerId = localStorage.getItem('peerId');
let storedPeers = JSON.parse(localStorage.getItem('peerList')) || {};
let lastLocalStorageState = JSON.stringify(localStorage);

// Heartbeat function to keep TURN server alive
let heartbeatIntervals = {};

function startHeartbeat(connection) {
  const peerId = connection.peer;
  
  if (heartbeatIntervals[peerId]) {
    clearInterval(heartbeatIntervals[peerId]);
  }

  heartbeatIntervals[peerId] = setInterval(() => {
    if (connection && connection.open) {
      connection.send(JSON.stringify({ type: 'heartbeat' }));
      console.log(`Heartbeat sent to peer ${peerId}`);
    }
  }, 1);
}

function stopHeartbeat(peerId) {
  clearInterval(heartbeatIntervals[peerId]);
  delete heartbeatIntervals[peerId];
}

function initializePeer() {
  peer = new Peer(storedPeerId, {
    debug: 2,
    config: {
      iceServers: [
        { 
          urls: 'turn:openrelay.metered.ca:80',
          username: 'openrelayproject',
          credential: 'openrelayproject'
        }
      ]
    }
  });

  peer.on('open', (id) => {
    if (!storedPeerId) {
      localStorage.setItem('peerId', id);
      storedPeerId = id;
    }
    console.log(`Peer connection opened. ID: ${id}`);
    document.getElementById('status').textContent = 'Ready to connect';
    document.getElementById('peerId').textContent = id;
    updatePeerList();
  });

  peer.on('error', (error) => {
    console.error('PeerJS error:', error);
    document.getElementById('status').textContent = 'Error: ' + error.type;
  });

  peer.on('connection', (connection) => {
    console.log('Incoming connection from peer:', connection.peer);
    handleIncomingConnection(connection);
  });
}

function handleIncomingConnection(connection) {
  const existingLabel = Object.keys(storedPeers).find(label => storedPeers[label].id === connection.peer);

  connection.on('open', () => {
    startHeartbeat(connection);
  });

  connection.on('close', () => {
    console.log(`Connection with ${connection.peer} closed.`);
    stopHeartbeat(connection.peer);
  });

  connection.on('data', (data) => {
    try {
      const message = JSON.parse(data);
      if (message.type === 'heartbeat') {
        console.log(`Heartbeat received from peer ${connection.peer}`);
      }
    } catch (error) {
      console.error('Failed to parse incoming message:', error);
    }
  });

if (existingLabel) {
    addConnection(connection, existingLabel);
  } else {
    const nameLabel = prompt("Enter a label for this peer connection:");

    if (nameLabel) {
      storedPeers[nameLabel] = { connected: true, id: connection.peer };
      localStorage.setItem('peerList', JSON.stringify(storedPeers));
      addConnection(connection, nameLabel);
      connection.send(JSON.stringify({ type: 'nameLabel', label: nameLabel }));
    } else {
      alert('Please enter a valid label');
      connection.close();
    }
  }
}







    function addConnection(connection, name) {
  connections[name] = connection;

  connection.on('open', () => {
    console.log(`Connected to peer: ${name}`);
    storedPeers[name] = { connected: true, id: connection.peer };
    localStorage.setItem('peerList', JSON.stringify(storedPeers));
    updatePeerList();
    syncLocalStorage(connection);
  });

  connection.on('data', (data) => {
    if (data.type === 'sync') {
      updateLocalStorage(data.storage);
    } else if (data.type === 'nameLabel') {
      storedPeers[data.label] = storedPeers[data.label] || { connected: false };
      storedPeers[data.label].connected = true;
      localStorage.setItem('peerList', JSON.stringify(storedPeers));
      updatePeerList();
    }
  });

  connection.on('close', () => {
    console.log(`Connection with peer ${name} closed`);
    storedPeers[name].connected = false; // Mark as disconnected
    localStorage.setItem('peerList', JSON.stringify(storedPeers));
    updatePeerList();
  });

  connection.on('error', (error) => {
    console.error(`Connection error with peer ${name}:`, error);
  });
}







       function syncLocalStorage(connection) {
  const storage = {};
  for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i);
    if (key !== 'peerId') {
      storage[key] = encodeURIComponent(localStorage.getItem(key)); // Ensure safe encoding
    }
  }
  console.log('Sending localStorage data:', storage);
  connection.send({ type: 'sync', storage: storage });
  updateSyncStatus('Sync completed');
}

function updateLocalStorage(incomingStorage) {
  let updated = false;

  Object.keys(incomingStorage).forEach((key) => {
    const incomingData = decodeURIComponent(incomingStorage[key]); // Decode received data
    localStorage.setItem(key, incomingData);
    updated = true;
  });

  if (updated) {
    updateSyncStatus('Local storage updated');
    signalUpdateToChecklistApp();
  }
}


    function mergeTasks(existingTasks, incomingTasks) {
      const mergedTasks = existingTasks.map((task) => {
        const matchingTask = incomingTasks.find(
          (incomingTask) =>
            incomingTask.text === task.text && incomingTask.category === task.category
        );

        if (matchingTask) {
          return {
            ...task,
            ...matchingTask, // Merge all fields from the matching task
          };
        }
        return task;
      });

      incomingTasks.forEach((incomingTask) => {
        const exists = mergedTasks.some(
          (task) =>
            task.text === incomingTask.text && task.category === incomingTask.category
        );

        if (!exists) {
          mergedTasks.push(incomingTask);
        }
      });

      return mergedTasks;
    }

    function updateSyncStatus(status) {
      console.log(status);
      document.getElementById('status').textContent = status;
    }

    function updatePeerList() {
      const peerList = document.getElementById('peerList');
      peerList.innerHTML = ''; // Clear the list
      const disconnectAllBtn = document.getElementById('disconnectAllPeers');
      const connectAllBtn = document.getElementById('connectAllPeers');
      
      Object.keys(storedPeers).forEach((name) => {
        const li = document.createElement('li');
        const status = storedPeers[name].connected ? 'Connected' : 'Disconnected';
        const statusClass = storedPeers[name].connected ? 'connected' : 'disconnected';

        li.innerHTML = `Peer: ${name} <span class="${statusClass}">${status}</span>`;

        if (storedPeers[name].connected) {
          const disconnectBtn = document.createElement('button');
          disconnectBtn.textContent = 'Disconnect';
          disconnectBtn.onclick = () => disconnectPeer(name);
          li.appendChild(disconnectBtn);

          const connectBtn = document.createElement('button');
          connectBtn.textContent = 'Connect';
          connectBtn.onclick = () => connectPeer(storedPeers[name].id);
          li.appendChild(connectBtn);
        } else {
          const connectBtn = document.createElement('button');
          connectBtn.textContent = 'Connect';
          connectBtn.onclick = () => connectPeer(storedPeers[name].id);
          li.appendChild(connectBtn);
        }

        const removeBtn = document.createElement('button');
        removeBtn.textContent = 'Remove Peer';
        removeBtn.onclick = () => removePeer(name);
        li.appendChild(removeBtn);

        peerList.appendChild(li);
      });

      disconnectAllBtn.disabled = Object.keys(connections).length === 0;
      connectAllBtn.disabled = Object.keys(storedPeers).length === 0 || Object.values(storedPeers).every(peer => peer.connected);
    }

    function connectPeer(id) {
      if (!connections[id]) {
        // Connect using Peer ID stored in localStorage
        const connection = peer.connect(id);
        addConnection(connection, Object.keys(storedPeers).find(label => storedPeers[label].id === id));
      }
    }

    function connectAllPeers() {
      Object.keys(storedPeers).forEach(name => {
        if (!storedPeers[name].connected) {
          connectPeer(storedPeers[name].id);
        }
      });
    }

    function disconnectPeer(name) {
      if (connections[name]) {
        connections[name].close();
        delete connections[name];
        storedPeers[name].connected = false;
        localStorage.setItem('peerList', JSON.stringify(storedPeers));
        updatePeerList();
      }
    }

    function disconnectAllPeers() {
      Object.keys(connections).forEach(name => {
        disconnectPeer(name);
      });
    }

    function removePeer(name) {
      if (confirm(`Are you sure you want to remove the peer ${name}?`)) {
        disconnectPeer(name);
        delete storedPeers[name];
        localStorage.setItem('peerList', JSON.stringify(storedPeers));
        updatePeerList();
      }
    }

    function autoSync() {
      const currentLocalStorageState = JSON.stringify(localStorage);

      if (currentLocalStorageState !== lastLocalStorageState) {
        lastLocalStorageState = currentLocalStorageState;

        Object.values(connections).forEach(connection => {
          if (connection.open) {
            syncLocalStorage(connection);
          }
        });
      }
    }

    setInterval(autoSync, 2000);

    function handlePeerIdInput() {
      const peerIdInput = document.getElementById('remotePeerId').value.trim();
      if (peerIdInput && !Object.values(storedPeers).some(peer => peer.id === peerIdInput)) {
        const nameLabel = prompt("Enter a label for this peer connection:");
        if (nameLabel) {
          storedPeers[nameLabel] = { connected: false, id: peerIdInput };
          localStorage.setItem('peerList', JSON.stringify(storedPeers));
          const connection = peer.connect(peerIdInput);
          addConnection(connection, nameLabel);
        } else {
          alert('Please enter a valid label');
        }
      } else {
        alert('Please enter a valid Peer ID');
      }
    }





function syncLocalStorageWithDeletionCheck(connection) {
  const storedData = localStorage.getItem('taskList');
  const localDeletionLog = JSON.parse(localStorage.getItem('deletion-log')) || [];

  if (storedData) {
    const parsedData = JSON.parse(storedData);

    const filteredData = parsedData.filter(task => 
      !localDeletionLog.includes(task.id)
    );

    connection.send(JSON.stringify({ 
      type: 'sync', 
      storage: filteredData, 
      deletionLog: localDeletionLog 
    }));

    console.log('Synced data after checking local deletion-log:', filteredData);
  }
}

// When receiving data, propagate deletions globally
function updateLocalStorageWithDeletionCheck(incomingData, incomingDeletionLog) {
  const localDeletionLog = JSON.parse(localStorage.getItem('deletion-log')) || [];

  // Merge incoming and local deletion logs
  const mergedDeletionLog = [...new Set([...localDeletionLog, ...incomingDeletionLog])];
  localStorage.setItem('deletion-log', JSON.stringify(mergedDeletionLog));

  const filteredData = incomingData.filter(task => 
    !mergedDeletionLog.includes(task.id)
  );

  localStorage.setItem('taskList', JSON.stringify(filteredData));
  console.log('Updated localStorage, skipping globally deleted tasks:', filteredData);
}

// Periodically scan and clean up localStorage
setInterval(() => {
  const storedData = JSON.parse(localStorage.getItem('taskList')) || [];
  const deletionLog = JSON.parse(localStorage.getItem('deletion-log')) || [];

  const cleanedData = storedData.filter(task => !deletionLog.includes(task.id));

  localStorage.setItem('taskList', JSON.stringify(cleanedData));
  console.log('Periodic cleanup: Removed tasks in deletion-log from taskList');
}, 1000); // Runs every 5 seconds










function forceSync() {
  Object.values(connections).forEach(connection => {
    if (connection.open) {
      syncLocalStorage(connection);
    }
  });
  updateSyncStatus('Force Sync initiated');
}





document.getElementById('forceSync').addEventListener('click', forceSync);
    

document.getElementById('addPeer').addEventListener('click', handlePeerIdInput);
    document.getElementById('disconnectAllPeers').addEventListener('click', disconnectAllPeers);
    document.getElementById('connectAllPeers').addEventListener('click', connectAllPeers);
    document.getElementById('copyPeerId').addEventListener('click', () => {
      const peerId = document.getElementById('peerId').textContent;
      navigator.clipboard.writeText(peerId).then(() => {
        alert('Peer ID copied to clipboard');
      });
    });

    document.getElementById('resetPeerId').addEventListener('click', () => {
      const newPeerId = prompt('Type: CONFIRM - Press Ok. Refresh to Unlock');
      if (newPeerId) {
        localStorage.removeItem('peerId');
        localStorage.removeItem('peerList');
        peer.destroy();
        initializePeer();
      }
    });








window.addEventListener("storage", function (event) {
    if (event.key) {
        document.getElementById("forceSync").click();
    }
});



// Function to detect category changes and trigger a page refresh
function checkForCategoryChanges() {
  const localStorageCategories = JSON.parse(localStorage.getItem('categories') || '[]');
  const syncedCategories = JSON.parse(sessionStorage.getItem('syncedCategories') || '[]');

  // Check if there's a difference between localStorage and synced categories
  const hasNewCategories = !arraysEqual(localStorageCategories, syncedCategories);

  if (hasNewCategories) {
    // Update sessionStorage with the latest categories
    sessionStorage.setItem('syncedCategories', JSON.stringify(localStorageCategories));

    // Trigger a page refresh
    window.location.reload();
  }
}

// Helper function to compare two arrays
function arraysEqual(a, b) {
  if (a.length !== b.length) return false;
  return a.every((value, index) => value === b[index]);
}

// Set an interval to check for category changes every second
setInterval(checkForCategoryChanges, 3000);

// Example function to be called when categories are synced
function onCategoriesSynced(newCategories) {
  localStorage.setItem('categories', JSON.stringify(newCategories));
  // Trigger immediate check for category changes
  checkForCategoryChanges();
}



document.getElementById('forceSync').addEventListener('click', () => {
  if (Object.keys(connections).length === 0) {
    updateSyncStatus('No connected peers to sync with.');
    return;
  }

  Object.values(connections).forEach(connection => {
    if (connection.open) {
      syncLocalStorage(connection); // Use your existing sync function
    }
  });

  updateSyncStatus('Manual sync initiated.');
});




function handleNetworkStatus() {
  window.addEventListener('Error: Network', () => {
    console.warn('Network connection lost. Refreshing page...');
    setTimeout(() => {
      location.reload();
    }, 3000); // Refresh after 3 seconds
  });

  window.addEventListener('online', () => {
    console.log('Network connection restored.');
  });
}

// Call the function on page load
handleNetworkStatus();










function ensureCompletedStatus(key, incomingData) {
  try {
    const existingData = localStorage.getItem(key) 
      ? JSON.parse(decodeURIComponent(localStorage.getItem(key))) 
      : null;

    if (existingData && existingData.completed !== true && incomingData.completed === true) {
      // Update localStorage if incoming task is marked as completed
      existingData.completed = true;
      localStorage.setItem(key, encodeURIComponent(JSON.stringify(existingData)));
      updateSyncStatus(`Task "${existingData.text}" marked as completed via sync.`);
      signalUpdateToChecklistApp();
    }
  } catch (e) {
    console.error(`Error ensuring completed status for key ${key}:`, e);
  }
}



// Track connected peers
function hasConnectedPeers() {
  console.log('Checking connected peers...');
  console.log('Connections:', connections);
  return Object.values(connections).some(connection => connection.open);
}

// Handle visibility change
document.addEventListener('visibilitychange', () => {
  console.log('Visibility changed:', document.visibilityState);
  if (document.visibilityState === 'visible') {
    if (hasConnectedPeers()) {
      console.log('App is back in foreground with connected peers &#8212; refreshing page.');
      location.reload();
    } else {
      console.log('App is back in foreground &#8212; no connected peers, skipping refresh.');
    }
  }
});



window.addEventListener("load", function () {
    document.getElementById("connectAllPeers").click();
});



window.addEventListener("beforeunload", function () {
    document.getElementById("disconnectAllPeers").click();
});



setInterval(() => {
  const connectButton = document.getElementById("connectAllPeers");
  
  if (connectButton) {
    connectButton.click();
    console.log("Connect All Peers button clicked.");
  } else {
    console.log("Connect All Peers button not found.");
  }
}, 1000); // Clicks every 1 second













   initializePeer();




 </script>

</!doctype>
</div>
<div class='clear'></div>
</div><div class='widget HTML' data-version='1' id='HTML3'>
<div class='widget-content'>
<div>
  <h3>Peer Sync Setup</h3>
  <button onclick="setupServer()">Setup Peer Sync via GitHub</button>

  <select id="repoSelect" style="display:none; margin-left: 10px;"></select>
  <button id="accessBtn" style="display:none;" onclick="accessServer()">Access Peer Sync</button>
  <button id="deleteBtn" style="display:none; margin-left: 10px;" onclick="deleteSelectedRepo()">Delete Repo</button>
</div>

<!-- Fullscreen Popup -->
<div id="popup" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:#fff;z-index:9999;">
  <button onclick="closePopup()" style="position:absolute;top:10px;right:10px;z-index:10000;font-size:18px;">&#10006; Close</button>
  <iframe id="iframe" style="width:100%;height:100%;border:none;"></iframe>
</div>

<script>
  const LS_KEY = "peerSyncRepos";

  window.onload = function () {
    loadRepoDropdown();
  };

  function loadRepoDropdown() {
    const repoList = JSON.parse(localStorage.getItem(LS_KEY) || "[]");
    const repoSelect = document.getElementById("repoSelect");
    const accessBtn = document.getElementById("accessBtn");
    const deleteBtn = document.getElementById("deleteBtn");

    if (repoList.length === 0) {
      repoSelect.style.display = "none";
      accessBtn.style.display = "none";
      deleteBtn.style.display = "none";
      return;
    }

    repoSelect.innerHTML = ""; // Clear previous options
    repoList.forEach((entry, i) => {
      const option = document.createElement("option");
      option.value = i;
      option.textContent = `${entry.username}/${entry.repo}`;
      repoSelect.appendChild(option);
    });

    repoSelect.style.display = "inline-block";
    accessBtn.style.display = "inline-block";
    deleteBtn.style.display = "inline-block";

    // Set URL on first option or current selected option
    const selectedIndex = repoSelect.selectedIndex >= 0 ? repoSelect.selectedIndex : 0;
    const selectedRepo = repoList[selectedIndex];
    accessBtn.dataset.url = `https://${selectedRepo.username}.github.io/${selectedRepo.repo}`;

    repoSelect.onchange = () => {
      const selected = repoList[repoSelect.value];
      accessBtn.dataset.url = `https://${selected.username}.github.io/${selected.repo}`;
    };
  }

  function setupServer() {
    const repoUrl = prompt("Enter GitHub Repo URL (e.g. https://github.com/username/repo)");
    const token = prompt("Enter your GitHub Personal Access Token");

    if (!repoUrl || !token) {
      alert("Missing repo URL or token.");
      return;
    }

    const parts = repoUrl.replace("https://github.com/", "").split("/");
    const username = parts[0];
    const repo = parts[1];
    const apiBase = `https://api.github.com/repos/${username}/${repo}/contents/`;
    const headers = {
      "Authorization": "token " + token,
      "Content-Type": "application/json"
    };

    fetch("https://testtesting10101010.blogspot.com/")
      .then(response => {
        if (!response.ok) throw new Error("Failed to fetch Blogger HTML");
        return response.text();
      })
      .then(bloggerHTML => {
        const fileUrl = apiBase + "index.html";

        return fetch(fileUrl, { method: "GET", headers: headers })
          .then(res => (res.status === 200 ? res.json() : null))
          .then(existing => {
            const body = {
              message: "Upload index.html",
              content: btoa(unescape(encodeURIComponent(bloggerHTML)))
            };
            if (existing && existing.sha) body.sha = existing.sha;

            return fetch(fileUrl, {
              method: "PUT",
              headers: headers,
              body: JSON.stringify(body)
            });
          });
      })
      .then(() => {
        alert("Website uploaded successfully!");

        const repoList = JSON.parse(localStorage.getItem(LS_KEY) || "[]");

        // Avoid duplicate entries
        const exists = repoList.some(item => item.username === username && item.repo === repo);
        if (!exists) {
          repoList.push({ username, repo, token });
          localStorage.setItem(LS_KEY, JSON.stringify(repoList));
        }

        loadRepoDropdown();
      })
      .catch(err => {
        console.error("Setup error:", err);
        alert("Setup failed: " + (err.message || JSON.stringify(err)));
      });
  }

  function accessServer() {
    const url = document.getElementById("accessBtn").dataset.url + "/index.html";
    const iframe = document.getElementById("iframe");
    const popup = document.getElementById("popup");

    iframe.src = url;
    popup.style.display = "block";
  }

  function closePopup() {
    const popup = document.getElementById("popup");
    const iframe = document.getElementById("iframe");
    iframe.src = "";
    popup.style.display = "none";
  }

  function deleteSelectedRepo() {
    const repoSelect = document.getElementById("repoSelect");
    const repoList = JSON.parse(localStorage.getItem(LS_KEY) || "[]");

    if (repoList.length === 0) return alert("No repos to delete.");

    const selectedIndex = repoSelect.selectedIndex;
    if (selectedIndex < 0) return alert("Please select a repo to delete.");

    const confirmDelete = confirm(`Are you sure you want to delete ${repoList[selectedIndex].username}/${repoList[selectedIndex].repo}?`);
    if (!confirmDelete) return;

    repoList.splice(selectedIndex, 1);
    localStorage.setItem(LS_KEY, JSON.stringify(repoList));

    alert("Repo deleted.");
    loadRepoDropdown();
  }
</script>
</div>
<div class='clear'></div>
</div></div>
</div>
</div>
<div class='tabs-cap-bottom cap-bottom'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
</div>
<div class='main-outer'>
<div class='main-cap-top cap-top'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
<div class='fauxborder-left main-fauxborder-left'>
<div class='fauxborder-right main-fauxborder-right'></div>
<div class='region-inner main-inner'>
<div class='columns fauxcolumns'>
<div class='fauxcolumn-outer fauxcolumn-center-outer'>
<div class='cap-top'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
<div class='fauxborder-left'>
<div class='fauxborder-right'></div>
<div class='fauxcolumn-inner'>
</div>
</div>
<div class='cap-bottom'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
</div>
<div class='fauxcolumn-outer fauxcolumn-left-outer'>
<div class='cap-top'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
<div class='fauxborder-left'>
<div class='fauxborder-right'></div>
<div class='fauxcolumn-inner'>
</div>
</div>
<div class='cap-bottom'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
</div>
<div class='fauxcolumn-outer fauxcolumn-right-outer'>
<div class='cap-top'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
<div class='fauxborder-left'>
<div class='fauxborder-right'></div>
<div class='fauxcolumn-inner'>
</div>
</div>
<div class='cap-bottom'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
</div>
<!-- corrects IE6 width calculation -->
<div class='columns-inner'>
<div class='column-center-outer'>
<div class='column-center-inner'>
<div class='main section' id='main' name='Main'><div class='widget Blog' data-version='1' id='Blog1'>
<div class='blog-posts hfeed'>
<div class='status-msg-wrap'>
<div class='status-msg-body'>
No posts.
</div>
<div class='status-msg-border'>
<div class='status-msg-bg'>
<div class='status-msg-hidden'>No posts.</div>
</div>
</div>
</div>
<div style='clear: both;'></div>
</div>
<div class='blog-pager' id='blog-pager'>
<a class='home-link' href='https://testtesting10101010.blogspot.com/'>Home</a>
</div>
<div class='clear'></div>
<div class='blog-feeds'>
<div class='feed-links'>
Subscribe to:
<a class='feed-link' href='https://testtesting10101010.blogspot.com/feeds/posts/default' target='_blank' type='application/atom+xml'>Posts (Atom)</a>
</div>
</div>
</div>
<div class='widget PopularPosts' data-version='1' id='PopularPosts1'>
<div class='widget-content popular-posts'>
<ul>
</ul>
<div class='clear'></div>
</div>
</div></div>
</div>
</div>
<div class='column-left-outer'>
<div class='column-left-inner'>
<aside>
</aside>
</div>
</div>
<div class='column-right-outer'>
<div class='column-right-inner'>
<aside>
<div class='sidebar section' id='sidebar-right-1'><div class='widget HTML' data-version='1' id='HTML4'>
<div class='widget-content'>
<!doctype html>

<style>

/* Container to hold all buttons in a single row */
.button-container {
    display: flex;
    justify-content: space-evenly; /* Even spacing between buttons */
    align-items: center;
    flex-wrap: wrap; /* Wrap buttons if the screen is too narrow */
    padding: 20px;
width: 100%
    gap: 20px; /* Adds a gap if wrap happens */
}

/* Style for all buttons */
#backupBtn, #restoreBtn, #updateBtn, #resetBtn {
    font-size: 16px;
    padding: 12px 20px;
    border-radius: 8px;
    border: 2px solid #ccc;
    background-color: #f0f0f0;
    color: #333;
    cursor: pointer;
    transition: background-color 0.3s ease, transform 0.3s ease;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    width: 200px; /* Fixed width for consistent size */
    text-align: center;
}

/* Hover effect */
#backupBtn:hover, #restoreBtn:hover, #updateBtn:hover, #resetBtn:hover {
    background-color: #e0e0e0;
    transform: scale(1.05);
}




</style>
    
    
    


    <h1></h1>

    

    <!-- Backup Button -->
    <button id="backupBtn">👇Download👇</button>

    <!-- Restore Input -->
    <input type="file" id="restoreInput" accept=".json" style="display: none;" />

    <!-- Restore Button -->
    <button id="restoreBtn">👆Restore👆</button>



    <!-- Update Data Button -->
    <button id="updateBtn" style="position: absolute; top: 20px; right: 95px;">🔝Update&#10548;&#65039;</button>



 <!-- Reset Data Button -->
    <button id="resetBtn" style="position: absolute; top: 20px; left: 120px;">&#9851;&#65039;Reset🗑&#65039;</button>


    <!-- Update Input -->
    <input type="file" id="updateInput" accept=".json" style="display: none;" />

    <script>
        // Ensure this function is called whenever a new category is created
        function saveCategory(category) {
            let categories = JSON.parse(localStorage.getItem("categories")) || [];
            if (!categories.includes(category)) {
                categories.push(category);
                localStorage.setItem("categories", JSON.stringify(categories));
            }
        }

        // Function to backup data
function backupData() {
    const customFilename = prompt("Enter filename for backup:", "backup_data");

    if (customFilename !== null && customFilename.trim() !== "") {
        const includePeerSync = confirm("Do you want to include Peer Sync Links?");
        const floatingEarthData = {
            "universeNo": localStorage.getItem("universeNo") || 0,
            "nodeCount": localStorage.getItem("nodeCount") || 0
        };

        const checklistData = {
            "storedTasks": JSON.parse(localStorage.getItem("tasks")) || [],
            "completedTasks": JSON.parse(localStorage.getItem("completedTasks")) || [],
            "categories": JSON.parse(localStorage.getItem("categories")) || []
        };

        // Backup notes for each task
        const taskNotes = {};
        checklistData.storedTasks.forEach(task => {
            const note = localStorage.getItem(`task_${task.id}_note`);
            if (note) taskNotes[task.id] = note;
        });

        const backupData = {
            "floatingEarthData": floatingEarthData,
            "checklistData": checklistData,
            "taskNotes": taskNotes // Save notes here
        };

        if (includePeerSync) {
            const peerSyncData = {
                "peerList": JSON.parse(localStorage.getItem("peerList")) || [],
                "peerId": localStorage.getItem("peerId") || ""
            };
            backupData["peerSyncData"] = peerSyncData;
        }

        const backupJSON = JSON.stringify(backupData);
        const backupBlob = new Blob([backupJSON], { type: "application/json" });

        const downloadLink = document.createElement("a");
        downloadLink.href = URL.createObjectURL(backupBlob);
        downloadLink.download = customFilename + ".json";
        downloadLink.click();
    } else {
        alert("Please enter a valid filename for backup.");
    }
}


// Function to restore data
function restoreData(event) {
    const file = event.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = function(e) {
            const restoredData = JSON.parse(e.target.result);
            const restorePeerSync = confirm("Do you want to restore Peer Sync Links?");

            // Restore data for Floating Earth
            localStorage.setItem("universeNo", restoredData.floatingEarthData.universeNo);
            localStorage.setItem("nodeCount", restoredData.floatingEarthData.nodeCount);

            // Restore data for Checklist App
            localStorage.setItem("tasks", JSON.stringify(restoredData.checklistData.storedTasks));
            localStorage.setItem("completedTasks", JSON.stringify(restoredData.checklistData.completedTasks));
            localStorage.setItem("categories", JSON.stringify(restoredData.checklistData.categories));

            // Restore task notes
            const taskNotes = restoredData.taskNotes || {};
            for (const taskId in taskNotes) {
                localStorage.setItem(`task_${taskId}_note`, taskNotes[taskId]);
            }

            if (restorePeerSync) {
                if (restoredData.peerSyncData) {
                    localStorage.setItem("peerList", JSON.stringify(restoredData.peerSyncData.peerList));
                    localStorage.setItem("peerId", restoredData.peerSyncData.peerId);
                } else {
                    alert("No Peer Sync Links found.");
                }
            }

            alert("Run Restore Twice to Load Categories & Completed Tasks");
            window.location.reload();
        };
        reader.readAsText(file);
    }
}


// Function to update data
function updateData(event) {
    const file = event.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = function(e) {
            const updatedData = JSON.parse(e.target.result);

            const updateOption = prompt("Select update option:\n1. Update Checklist Information\n2. Update Node Information\n3. Update Both");
            const updatePeerSync = confirm("Do you want to update Peer Sync Links?");

            if (updateOption !== null && updateOption.trim() !== "") {
                if (updateOption === "1" || updateOption === "3") {
                    // Update Checklist Information
                    const existingTasks = JSON.parse(localStorage.getItem("tasks")) || [];
                    const existingCompletedTasks = JSON.parse(localStorage.getItem("completedTasks")) || [];
                    const existingCategories = JSON.parse(localStorage.getItem("categories")) || [];

                    const newTasks = updatedData.checklistData.storedTasks.filter(task => !existingTasks.some(existingTask => existingTask.text === task.text));
                    const newCompletedTasks = updatedData.checklistData.completedTasks.filter(task => !existingCompletedTasks.some(existingTask => existingTask.text === task.text));
                    const newCategories = updatedData.checklistData.categories.filter(category => !existingCategories.includes(category));

                    const updatedTasks = existingTasks.concat(newTasks);
                    const updatedCompletedTasks = existingCompletedTasks.concat(newCompletedTasks);
                    const updatedCategories = [...new Set(existingCategories.concat(newCategories))];

                    localStorage.setItem("tasks", JSON.stringify(updatedTasks));
                    localStorage.setItem("completedTasks", JSON.stringify(updatedCompletedTasks));
                    localStorage.setItem("categories", JSON.stringify(updatedCategories));

                    // Update notes for tasks
                    const updatedNotes = updatedData.taskNotes || {};
                    for (const taskId in updatedNotes) {
                        localStorage.setItem(`task_${taskId}_note`, updatedNotes[taskId]);
                    }

                    if (updateOption === "1") {
                        alert("Checklist information updated successfully!");
                    }
                }
                if (updateOption === "2" || updateOption === "3") {
                    // Update Node Information
                    localStorage.setItem("universeNo", updatedData.floatingEarthData.universeNo);
                    localStorage.setItem("nodeCount", updatedData.floatingEarthData.nodeCount);

                    if (updateOption === "2") {
                        alert("Node information updated successfully!");
                    } else {
                        alert("Run the Update Twice to Load Categories & Completed Tasks");
                    }
                }
                if (updatePeerSync) {
                    if (updatedData.peerSyncData) {
                        localStorage.setItem("peerList", JSON.stringify(updatedData.peerSyncData.peerList));
                        localStorage.setItem("peerId", updatedData.peerSyncData.peerId);
                    } else {
                        alert("No Peer Sync Links found.");
                    }
                }
            } else {
                alert("No update option selected.");
            }

            window.location.reload();
        };
        reader.readAsText(file);
    }
}




      
// Function to reset all data
        function resetData() {
            if (confirm("Are you sure you want to reset all data?")) {
                localStorage.clear();
                alert("Tasks Reset! (Categories and Completed Tasks retained for Extended Use)");
                window.location.reload();
            }
        }

        // Event listener for reset button
        document.getElementById("resetBtn").addEventListener("click", resetData);
     

        // Event listener for backup button
        document.getElementById("backupBtn").addEventListener("click", backupData);

        // Event listener for restore button
        document.getElementById("restoreBtn").addEventListener("click", function() {
            document.getElementById("restoreInput").click();
        });

        // Event listener for restore input change
        document.getElementById("restoreInput").addEventListener("change", restoreData);

        // Event listener for update button
        document.getElementById("updateBtn").addEventListener("click", function() {
            document.getElementById("updateInput").click();
        });

        // Event listener for update input change
        document.getElementById("updateInput").addEventListener("change", updateData);
    </script>

</!doctype>
</div>
<div class='clear'></div>
</div><div class='widget BlogSearch' data-version='1' id='BlogSearch1'>
<h2 class='title'>Search This Blog</h2>
<div class='widget-content'>
<div id='BlogSearch1_form'>
<form action='https://testtesting10101010.blogspot.com/search' class='gsc-search-box' target='_top'>
<table cellpadding='0' cellspacing='0' class='gsc-search-box'>
<tbody>
<tr>
<td class='gsc-input'>
<input autocomplete='off' class='gsc-input' name='q' size='10' title='search' type='text' value=''/>
</td>
<td class='gsc-search-button'>
<input class='gsc-search-button' title='search' type='submit' value='Search'/>
</td>
</tr>
</tbody>
</table>
</form>
</div>
</div>
<div class='clear'></div>
</div><div class='widget PageList' data-version='1' id='PageList1'>
<div class='widget-content'>
<ul>
<li class='selected'>
<a href='https://testtesting10101010.blogspot.com/'>Home</a>
</li>
</ul>
<div class='clear'></div>
</div>
</div>
</div>
<table border='0' cellpadding='0' cellspacing='0' class='section-columns columns-2'>
<tbody>
<tr>
<td class='first columns-cell'>
<div class='sidebar section' id='sidebar-right-2-1'><div class='widget ReportAbuse' data-version='1' id='ReportAbuse1'>
<h3 class='title'>
<a class='report_abuse' href='https://www.blogger.com/go/report-abuse' rel='noopener nofollow' target='_blank'>
Report Abuse
</a>
</h3>
</div></div>
</td>
<td class='columns-cell'>
<div class='sidebar no-items section' id='sidebar-right-2-2'>
</div>
</td>
</tr>
</tbody>
</table>
<div class='sidebar no-items section' id='sidebar-right-3'>
</div>
</aside>
</div>
</div>
</div>
<div style='clear: both'></div>
<!-- columns -->
</div>
<!-- main -->
</div>
</div>
<div class='main-cap-bottom cap-bottom'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
</div>
<footer>
<div class='footer-outer'>
<div class='footer-cap-top cap-top'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
<div class='fauxborder-left footer-fauxborder-left'>
<div class='fauxborder-right footer-fauxborder-right'></div>
<div class='region-inner footer-inner'>
<div class='foot no-items section' id='footer-1'></div>
<table border='0' cellpadding='0' cellspacing='0' class='section-columns columns-2'>
<tbody>
<tr>
<td class='first columns-cell'>
<div class='foot no-items section' id='footer-2-1'></div>
</td>
<td class='columns-cell'>
<div class='foot no-items section' id='footer-2-2'></div>
</td>
</tr>
</tbody>
</table>
<!-- outside of the include in order to lock Attribution widget -->
<div class='foot section' id='footer-3' name='Footer'><div class='widget Attribution' data-version='1' id='Attribution1'>
<div class='widget-content' style='text-align: center;'>
Simple theme. Theme images by <a href='https://www.istockphoto.com/googleimages.php?id=11394138&amp;platform=blogger&langregion=en_GB' target='_blank'>luoman</a>. Powered by <a href='https://www.blogger.com' target='_blank'>Blogger</a>.
</div>
<div class='clear'></div>
</div></div>
</div>
</div>
<div class='footer-cap-bottom cap-bottom'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
</div>
</footer>
<!-- content -->
</div>
</div>
<div class='content-cap-bottom cap-bottom'>
<div class='cap-left'></div>
<div class='cap-right'></div>
</div>
</div>
</div>
<script type='text/javascript'>
    window.setTimeout(function() {
        document.body.className = document.body.className.replace('loading', '');
      }, 10);
  </script>

<script type="text/javascript" src="https://www.blogger.com/static/v1/widgets/2838643729-widgets.js"></script>
<script type='text/javascript'>
window['__wavt'] = 'AOuZoY5iY6zpj2wUVMmD7UHLenIxCeniag:1750148123939';_WidgetManager._Init('//www.blogger.com/rearrange?blogID\x3d7134852494570757091','//testtesting10101010.blogspot.com/','7134852494570757091');
_WidgetManager._SetDataContext([{'name': 'blog', 'data': {'blogId': '7134852494570757091', 'title': 'test', 'url': 'https://testtesting10101010.blogspot.com/', 'canonicalUrl': 'https://testtesting10101010.blogspot.com/', 'homepageUrl': 'https://testtesting10101010.blogspot.com/', 'searchUrl': 'https://testtesting10101010.blogspot.com/search', 'canonicalHomepageUrl': 'https://testtesting10101010.blogspot.com/', 'blogspotFaviconUrl': 'https://testtesting10101010.blogspot.com/favicon.ico', 'bloggerUrl': 'https://www.blogger.com', 'hasCustomDomain': false, 'httpsEnabled': true, 'enabledCommentProfileImages': true, 'gPlusViewType': 'FILTERED_POSTMOD', 'adultContent': false, 'analyticsAccountNumber': '', 'encoding': 'UTF-8', 'locale': 'en-GB', 'localeUnderscoreDelimited': 'en_gb', 'languageDirection': 'ltr', 'isPrivate': false, 'isMobile': false, 'isMobileRequest': false, 'mobileClass': '', 'isPrivateBlog': false, 'isDynamicViewsAvailable': true, 'feedLinks': '\x3clink rel\x3d\x22alternate\x22 type\x3d\x22application/atom+xml\x22 title\x3d\x22test - Atom\x22 href\x3d\x22https://testtesting10101010.blogspot.com/feeds/posts/default\x22 /\x3e\n\x3clink rel\x3d\x22alternate\x22 type\x3d\x22application/rss+xml\x22 title\x3d\x22test - RSS\x22 href\x3d\x22https://testtesting10101010.blogspot.com/feeds/posts/default?alt\x3drss\x22 /\x3e\n\x3clink rel\x3d\x22service.post\x22 type\x3d\x22application/atom+xml\x22 title\x3d\x22test - Atom\x22 href\x3d\x22https://www.blogger.com/feeds/7134852494570757091/posts/default\x22 /\x3e\n', 'meTag': '', 'adsenseHostId': 'ca-host-pub-1556223355139109', 'adsenseHasAds': false, 'adsenseAutoAds': false, 'boqCommentIframeForm': true, 'loginRedirectParam': '', 'view': '', 'dynamicViewsCommentsSrc': '//www.blogblog.com/dynamicviews/4224c15c4e7c9321/js/comments.js', 'dynamicViewsScriptSrc': '//www.blogblog.com/dynamicviews/a332d1916da3fccd', 'plusOneApiSrc': 'https://apis.google.com/js/platform.js', 'disableGComments': true, 'interstitialAccepted': false, 'sharing': {'platforms': [{'name': 'Get link', 'key': 'link', 'shareMessage': 'Get link', 'target': ''}, {'name': 'Facebook', 'key': 'facebook', 'shareMessage': 'Share to Facebook', 'target': 'facebook'}, {'name': 'BlogThis!', 'key': 'blogThis', 'shareMessage': 'BlogThis!', 'target': 'blog'}, {'name': 'X', 'key': 'twitter', 'shareMessage': 'Share to X', 'target': 'twitter'}, {'name': 'Pinterest', 'key': 'pinterest', 'shareMessage': 'Share to Pinterest', 'target': 'pinterest'}, {'name': 'Email', 'key': 'email', 'shareMessage': 'Email', 'target': 'email'}], 'disableGooglePlus': true, 'googlePlusShareButtonWidth': 0, 'googlePlusBootstrap': '\x3cscript type\x3d\x22text/javascript\x22\x3ewindow.___gcfg \x3d {\x27lang\x27: \x27en_GB\x27};\x3c/script\x3e'}, 'hasCustomJumpLinkMessage': false, 'jumpLinkMessage': 'Read more', 'pageType': 'index', 'pageName': '', 'pageTitle': 'test'}}, {'name': 'features', 'data': {}}, {'name': 'messages', 'data': {'edit': 'Edit', 'linkCopiedToClipboard': 'Link copied to clipboard', 'ok': 'Ok', 'postLink': 'Post link'}}, {'name': 'template', 'data': {'name': 'Simple', 'localizedName': 'Simple', 'isResponsive': false, 'isAlternateRendering': false, 'isCustom': false, 'variant': 'literate', 'variantId': 'literate'}}, {'name': 'view', 'data': {'classic': {'name': 'classic', 'url': '?view\x3dclassic'}, 'flipcard': {'name': 'flipcard', 'url': '?view\x3dflipcard'}, 'magazine': {'name': 'magazine', 'url': '?view\x3dmagazine'}, 'mosaic': {'name': 'mosaic', 'url': '?view\x3dmosaic'}, 'sidebar': {'name': 'sidebar', 'url': '?view\x3dsidebar'}, 'snapshot': {'name': 'snapshot', 'url': '?view\x3dsnapshot'}, 'timeslide': {'name': 'timeslide', 'url': '?view\x3dtimeslide'}, 'isMobile': false, 'title': 'test', 'description': '', 'url': 'https://testtesting10101010.blogspot.com/', 'type': 'feed', 'isSingleItem': false, 'isMultipleItems': true, 'isError': false, 'isPage': false, 'isPost': false, 'isHomepage': true, 'isArchive': false, 'isLabelSearch': false}}]);
_WidgetManager._RegisterWidget('_NavbarView', new _WidgetInfo('Navbar1', 'navbar', document.getElementById('Navbar1'), {}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_HeaderView', new _WidgetInfo('Header1', 'header', document.getElementById('Header1'), {}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_HTMLView', new _WidgetInfo('HTML1', 'crosscol', document.getElementById('HTML1'), {}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_HTMLView', new _WidgetInfo('HTML2', 'crosscol-overflow', document.getElementById('HTML2'), {}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_HTMLView', new _WidgetInfo('HTML3', 'crosscol-overflow', document.getElementById('HTML3'), {}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_BlogView', new _WidgetInfo('Blog1', 'main', document.getElementById('Blog1'), {'cmtInteractionsEnabled': false, 'navMessage': 'No posts.', 'lightboxEnabled': true, 'lightboxModuleUrl': 'https://www.blogger.com/static/v1/jsbin/3668400948-lbx__en_gb.js', 'lightboxCssUrl': 'https://www.blogger.com/static/v1/v-css/123180807-lightbox_bundle.css'}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_PopularPostsView', new _WidgetInfo('PopularPosts1', 'main', document.getElementById('PopularPosts1'), {}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_HTMLView', new _WidgetInfo('HTML4', 'sidebar-right-1', document.getElementById('HTML4'), {}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_BlogSearchView', new _WidgetInfo('BlogSearch1', 'sidebar-right-1', document.getElementById('BlogSearch1'), {}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_PageListView', new _WidgetInfo('PageList1', 'sidebar-right-1', document.getElementById('PageList1'), {'title': '', 'links': [{'isCurrentPage': true, 'href': 'https://testtesting10101010.blogspot.com/', 'title': 'Home'}], 'mobile': false, 'showPlaceholder': true, 'hasCurrentPage': true}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_ReportAbuseView', new _WidgetInfo('ReportAbuse1', 'sidebar-right-2-1', document.getElementById('ReportAbuse1'), {}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_AttributionView', new _WidgetInfo('Attribution1', 'footer-3', document.getElementById('Attribution1'), {}, 'displayModeFull'));
</script>
</body>
</html>